@node btree
@section The binary tree container


@cindex Binary tree container
@cindex BTree container

@menu
* btree typedefs::              Implementation and type definitions.
* btree examples::              Usage examples.
* btree creation::              Building btree hierarchies.
* btree inspection::            Accessing nodes.
* btree removing::              Removing elements from a btree.
* btree find::                  Finding values.
* btree visitors::              Finding nodes.
* btree iteration::             Iterations in a btree hierarchy.
@end menu

@c ------------------------------------------------------------

@c page
@node btree typedefs
@subsection Implementation and type definitions


@noindent
The btree container is an implementation of binary tree; it is built as
a chain of structures:

@example
  ------  bro   ------
 | node |----->| node |
 |   1  |<-----|   2  |
  ------  dad   ------
   | ^
son| |dad
   v |
  ------
 | node |
 |   3  |
  ------
@end example

@noindent
each node data structure is a collection of pointers and of metadata
fields whose usage is reserved by @ucl{}; there's no data field.


@deftp {Struct Typedef} ucl_node_tag_t
@deftpx {Pointer Typedef} ucl_node_t
The data type of the node structure and of the pointer to the node
structure; nodes must be allocated and freed by client code.  Public
fields:

@table @code
@item ucl_node_t dad
pointer to the partent of this node; @null{} if this node has no parent;

@item ucl_node_t son
pointer to the son of this node; @null{} if this node has no son;

@item ucl_node_t bro
pointer to the bro of this node; @null{} if this node has no bro.
@end table
@end deftp

@c ------------------------------------------------------------

@c page
@node btree examples
@subsection Usage examples


@noindent
Let's say that we want to organise a set of characters in a binary tree;
we define the tree node type and allocation functions of the node like
these:

@example
typedef struct node_tag_t @{
  ucl_node_tag_t  node;
  char                  c;
@} node_tag_t;

typedef node_tag_t *    node_t;

ucl_memory_allocator_t  allocator = @{
  .data  = NULL,
  .alloc = ucl_memory_alloc
@};

node_t
node_make (char c)
@{
  node_t        p = NULL;

  allocator.alloc(allocator.data, &p, sizeof(node_tag_t));
  p->c = c;
  return p;
@}
void
node_final (node_t p)
@{
  allocator.alloc(allocator.data, &p, 0);
@}
__inline__ void
node_clean (node_t p)
@{
  ucl_struct_clean(p, node_tag_t);
@}
@end example

@noindent
and we remember that the built in @ucl{} allocation function,
@function{ucl_memory_alloc}, sets to zero all the bytes of newly
allocated blocks.

We define the getter/setter functions in ``generic'' form, like these:

@example
__inline__ void
node_set (node_t p, void * data)
@{
  p->c = *((char *)data);
@}
__inline__ char *
node_get (node_t p)
@{
  return &(p->c);
@}
@end example


Now if we want the following hierarchy:

@example
       ---  bro  ---
      | a |---->| c |
       ---       ---
        |         |
    son v     son v
       ---       ---
      | b |     | d |
       ---       ---
@end example

@noindent
we do it like this, taking advantage of the fact that the btree
functions accept @code{void *} values as arguments:

@example
node_t  a, b, c, d;

a = node_make('a');
b = node_make('b');
c = node_make('c');
d = node_make('d');

ucl_btree_dadson(a, b);
ucl_btree_dadbro(a, c);
ucl_btree_dadson(c, d);
@end example

@noindent
the following expressions are true:

@example
NULL == ucl_btree_getdad(a)
a    == ucl_btree_getdad(b)
a    == ucl_btree_getdad(c)
c    == ucl_btree_getdad(d)

c    == ucl_btree_getbro(a)
NULL == ucl_btree_getbro(b)
NULL == ucl_btree_getbro(c)
NULL == ucl_btree_getbro(d)

b    == ucl_btree_getson(a)
NULL == ucl_btree_getson(b)
d    == ucl_btree_getson(c)
NULL == ucl_btree_getson(d)
@end example

@c ------------------------------------------------------------

@c page
@node btree creation
@subsection Building btrees hierarchies


@noindent
The correct way of building btrees is to allocate node structures with a
function that cleans them up, like @function{calloc}, then use the
following functions to initialise the fields.  If a structure must be
recycled, we must reset its fields to zero first.

All the following functions accept @code{void *} values as arguments:
internally these pointers are cast @code{ucl_node_t}.


@subsubsection Single link setters


@deftypefn {Inline Function} void ucl_btree_set_dad (void * @var{self}, void * @var{dad})
Select a new parent node for @var{self}.
@end deftypefn


@deftypefn {Inline Function} void ucl_btree_set_bro (void * @var{self}, void * @var{bro})
Select a new brother node for @var{self}.
@end deftypefn


@deftypefn {Inline Function} void ucl_btree_set_son (void * @var{self}, void * @var{son})
Select a new child node for @var{self}.
@end deftypefn


@subsubsection Double link setters


@deftypefn {Inline Function} void ucl_btree_set_dadson (void * @var{dad}, void * @var{son})
Link @var{dad} and @var{son} to be the parent and the son respectively.
@end deftypefn


@deftypefn {Inline Function} void ucl_btree_set_dadbro (void * @var{dad}, void * @var{bro})
Link @var{dad} and @var{bro} to be the parent and the bro respectively.
@end deftypefn


@subsubsection Triple link setters


@deftypefn {Inline Function} void ucl_btree_set_dadsonbro (void * @var{dad}, void * @var{son}, void * @var{bro})
Link @var{dad}, @var{son} and @var{bro} to be the parent, the son and
the bro respectively.
@end deftypefn


@c ------------------------------------------------------------

@c page
@node btree inspection
@subsection Accessing nodes


@noindent
All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefn {Inline Function} {void *} ucl_btree_ref_dad (void * @var{self})
Return a pointer to the parent of @var{self} or @null{} if the node
has no parent.
@end deftypefn


@deftypefn {Inline Function} {void *} ucl_btree_ref_bro (void * @var{self})
Return a pointer to the brother of @var{self} or @null{} if the node has
no brother.
@end deftypefn


@deftypefn {Inline Function} {void *} ucl_btree_ref_son (void * @var{self})
Return a pointer to the son of @var{self} or @null{} if the node has no
son.
@end deftypefn


@deftypefn {Inline Function} {void *} ucl_btree_data (void * @var{self})
Assuming that the first field of the memory block referenced by
@var{self} is a structure of type @code{ucl_node_tag_t}, return a
pointer to the first byte after that structure.  The returned pointer
references the first byte of the data area of the tree node.
@end deftypefn


@deftypefn {Inline Function} ucl_bool_t ucl_btree_is_leaf (void * @var{self})
Return true if the node is a leaf (no brother and no son).
@end deftypefn


@c ------------------------------------------------------------

@c page
@node btree removing
@subsection Removing elements from a btree


@noindent
It's a matter of setting pointers to @null{}; care must be taken not to
loose references to subtrees.

All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefn {Inline Function} {void *} ucl_btree_detach_son (void * @var{self})
Detach the son of @var{self} and return a pointer to it.  The two nodes
hold references to each other no more.
@end deftypefn


@deftypefn {Inline Function} {void *} ucl_btree_detach_bro (void * @var{self})
Detach the bro of @var{self} and return a pointer to it.  The two nodes
hold references to each other no more.
@end deftypefn


@deftypefn {Inline Function} {void *} ucl_btree_detach_dad (void * @var{self})
Detach the dad of @var{self} and return a pointer to it.  The two nodes
hold references to each other no more.
@end deftypefn


@deftypefun void ucl_btree_clean (void * @var{self})
Set to zero all the bytes in the node structure.
@end deftypefun


@c ------------------------------------------------------------

@c page
@node btree find
@subsection Finding values


@noindent
The purpose of a binary tree is to organise values in a hierarchy; the
functions described in this section can be used to find values.

All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefun {void *} ucl_btree_find_value (void * @var{root}, ucl_comparison_t @var{compar})
Interpret @var{root} as a pointer to the root node of a btree (whose dad
is @null{}) and find
@end deftypefun



@c ------------------------------------------------------------

@c page
@node btree visitors
@subsection Finding nodes


@noindent
All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefun {void *} ucl_btree_find_leftmost (void * @var{self})
Find the leftmost node in the subtree of the supplied node.  To do this,
we traverse the tree choosing always the son of the current node.

Example:

@example   
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
starting from @code{5} the selected node is @code{1}, starting from
@code{10} the selected node is @code{6}.

Return a pointer to the leftmost node in the @var{self} sub--hierarchy
or to @var{self} itself if it has no son.
@end deftypefun


@deftypefun {void *} ucl_btree_find_rightmost (void * @var{self})
Find the rightmost node in the subtree of the supplied node.  To do this,
we traverse the tree choosing always the brother of the current node.

Example:

@example   
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
starting from @code{5} the selected node is @code{12}, starting from
@code{7} the selected node is @code{9}.

Return a pointer to the rightmost node in the @var{self} sub--hierarchy
or to @var{self} itself if it has no brother.
@end deftypefun


@deftypefun {void *} ucl_btree_find_deepest_son (void * @var{self})
Find the deepest leftmost son in a subtree.  This is different from
@function{ucl_btree_find_leftmost}.

Example:

@example   
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
starting from @code{5} the selected node is @code{2}, starting from
@code{10} the selected node is @code{6}.

Return a pointer to the deepest son in the @var{self} sub--hierarchy, or
@var{self} itself if it has no son.
@end deftypefun


@deftypefun {void *} ucl_btree_find_deepest_bro (void * @var{self})
Find the deepest rightmost bro in a subtree.  This is different from
@function{ucl_btree_find_rightmost}.

Example:

@example   
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
starting from @code{5} the selected node is @code{11}, starting from
@code{1} the selected node is @code{4}.

Return a pointer to the deepest bro in the @var{self} sub--hierarchy, or
@var{self} itself if it has no son.
@end deftypefun


@deftypefun {void *} ucl_btree_find_root (void * @var{node})
Step up the hierarchy, dad by dad, and return a pointer to a node that
has @null{} as dad.
@end deftypefun


@c ------------------------------------------------------------

@c page
@node btree iteration
@subsection Iterations in a btree hierarchy


@menu
* btree inorder iteration::     Inorder iteration.
* btree preorder iteration::    Preorder iteration.
* btree postorder iteration::   Postorder iteration.
* btree level iteration::       Level order iteration.
@end menu


@c ------------------------------------------------------------

@c page
@node btree inorder iteration
@subsubsection Inorder iteration


@noindent
Forward inorder iteration: visit all the nodes from the leftmost to the
rightmost.  Backward inorder iteration: visit all the nodes from the
rightmost to the leftmost.  Example: given the tree:
   
@example
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
the inorder iteration is:

@example
forward:   1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12
backward: 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1
@end example

All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefn {Inline Function} {void *} ucl_btree_first_inorder (void * @var{root})
@deftypefnx {Inline Function} {void *} ucl_btree_first_inorder_backward (void * @var{root})
Given a pointer to the root node of a tree, return the first node of an
inorder iteration.  For the forward iteration: it is the leftmost node;
for the backward iteration: it is the rightmost node.
@end deftypefn


@deftypefun {void *} ucl_btree_step_inorder (void * @var{current})
@deftypefunx {void *} ucl_btree_step_inorder_backward (void * @var{current})
Advance an inorder iteration.  Given a pointer to a node in a tree:
perform a single step and return a pointer to the next node, or @null{}
if the iteration is over.
@end deftypefun


@deftypefun void ucl_btree_iterator_inorder (ucl_iterator_t @var{iter}, void * @var{root})
@deftypefunx void ucl_btree_iterator_inorder_backward (ucl_iterator_t @var{iter}, void * @var{root})
Initialise a whole tree iterator; @var{root} must be the root node of a
btree.
@end deftypefun


@deftypefun void ucl_btree_subtree_iterator_inorder (ucl_iterator_t @var{iter}, void * @var{node})
@deftypefunx void ucl_btree_subtree_iterator_inorder_backward (ucl_iterator_t @var{iter}, void * @var{node})
Initialise a subtree iterator; @var{node} must be the a node of a btree,
and will be used as root node of the subtree.
@end deftypefun


@deftypefun void ucl_btree_range_iterator_inorder (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
@deftypefunx void ucl_btree_range_iterator_inorder_backward (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
Initialise a range iterator over the range of nodes selected by
@var{range} (remember that ranges are inclusive); the minimum field of
@var{range} is interpreted as the starting node of the iteration, while
the maximum field of @var{range} is interpreted as the ending node of
the iteration.
@end deftypefun


@c ------------------------------------------------------------

@subsubsection Examples of forward iteration


@noindent
To perform a complete forward inorder iteration, we have to start from
the leftmost node (@code{0} in the picture above), already visited, and
begin from there.  Example:

@example
ucl_node_t   cur = get_the_top_node();

for (cur = ucl_btree_find_leftmost(cur);
     cur;
     cur = ucl_btree_step_inorder(cur));
  @{
    do_something_with(cur);
  @}
@end example

To restrict the iteration to a subtree of a tree or to a range of nodes
in a tree, we have to select the first and last nodes and check when the
iterator reaches the last.

Example of subtree restriction: does an inorder iteration from the top
of a subtree to the rightmost node in the subtree:

@example
ucl_node_t        cur, end;

cur = get_a_node(...);
end = ucl_btree_find_rightmost(cur);

for (cur = ucl_btree_find_leftmost(cur);
     cur != end;
     cur = ucl_btree_step_inorder(cur))
  @{
    do_something_with(cur);
  @}

/* Here "cur == end" and we visit it. */
do_something_with(cur);
@end example

@noindent
@code{cur} can't be @null{} because @code{end} is in the subtree of the
top node; this code will work even when @code{cur == end} at the
beginning.

Example of range restriction: does an iteration starting from a node
(not the leftmost) to the rightmost one:

@example
ucl_node_t        root, cur, end;

root	= get_a_node();
end	= ucl_btree_find_rightmost(root);

for (cur = select_first(root, ...);
     cur != end;
     cur = ucl_btree_step_inorder(cur))
  @{
    do_something_with(cur);
  @}
@end example

@noindent
@code{cur} can't be @null{} because we selected the first and last nodes
in a subtree; this code will work even when @code{root == cur == end} at
the beginning.


@c ------------------------------------------------------------

@subsubsection Examples of backward iteration


@noindent
To perform a complete backward iteration, we have to start from the
rightmost node (@code{12} in the picture above), already visited, and
begin from there.  Example:

@example
ucl_node_t   cur = get_the_top_node();

for (cur = ucl_btree_find_rightmost(cur);
     cur;
     cur = ucl_btree_step_inorder_backward(cur))
  @{
    do_something_with(cur);
  @}
@end example

To restrict the iteration to a subtree of a tree or to a range of nodes
in a tree, we have to select the first and last nodes and check when the
iterator reaches the last.

Example of subtree restriction: does an iteration from the rightmost to
the leftmost nodes in a subtree:

@example
ucl_node_t        cur, end;

cur = get_a_node(...);
end = ucl_btree_find_leftmost(cur);

for (cur = ucl_btree_find_rightmost(cur);
     cur != end;
     cur = ucl_btree_step_inorder_backward(cur))
  @{
    do_something_with(cur);
  @}

/* Here "cur == end" and we visit it. */
do_something_with(cur);
@end example

@noindent
@code{cur} can't be @null{} because @code{end} is in the subtree of the
top node; this code will work even when @code{cur == end} at the
beginning.

Example of range restriction:

@example
ucl_node_t        root, cur, end;

root	= get_a_node();
end	= ucl_btree_find_leftmost(root);

for (cur = select_first(root, ...);
     cur != end;
     cur = ucl_btree_step_inorder_backward(cur))
  @{
    do_something_with(cur);
  @}

/* Here "cur == end" and we visit it. */
do_something_with(cur);
@end example

@noindent
@code{cur} can't be @null{} since we selected the first and last nodes
in a subtree; this code will work even when @code{root == cur == end} a
the beginning.

@c ------------------------------------------------------------

@c page
@node btree preorder iteration
@subsubsection Preorder iteration


@noindent
Preorder iteration: visit the current node then the son then the
brother.  Example:

@example
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent  
the preorder iteration is:

@example
forward:    5,  1,  3,  2,  4, 10,  7,  6,  9,  8, 12, 11
backward:   5, 10, 12, 11,  7,  9,  8,  6,  1,  3,  4,  2
@end example

@noindent
the forward iteration is a ``worm that always turns right'', while the
backward iteration is a ``worm that always turns left''.

All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefn {Inline Function} {void *} ucl_btree_first_preorder (void * @var{root})
@deftypefnx {Inline Function} {void *} ucl_btree_first_preorder_backward (void * @var{root})
Given a pointer to the root node of a tree, return the first node of a
preorder iteration.  For both the forward and backward iterations: it is
the root node itself.
@end deftypefn


@deftypefun {void *} ucl_btree_step_preorder (void * @var{current})
@deftypefunx {void *} ucl_btree_step_preorder_backward (void * @var{current})
Advance a preorder iteration.  Given a node in a btree: perform a single
step and return a pointer to the next node, or @null{} if the iteration
is over.
@end deftypefun


@deftypefun void ucl_btree_iterator_preorder (ucl_iterator_t @var{iter}, void * @var{root})
@deftypefunx void ucl_btree_iterator_preorder_backward (ucl_iterator_t @var{iter}, void * @var{root})
Initialise a whole tree iterator; @var{root} must be the root node of a
btree.
@end deftypefun


@deftypefun void ucl_btree_subtree_iterator_preorder (ucl_iterator_t @var{iter}, void * @var{node})
@deftypefunx void ucl_btree_subtree_iterator_preorder_backward (ucl_iterator_t @var{iter}, void * @var{node})
Initialise a subtree iterator; @var{node} must be the a node of a btree,
and will be used as root node of the subtree.
@end deftypefun


@deftypefun void ucl_btree_range_iterator_preorder (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
@deftypefunx void ucl_btree_range_iterator_preorder_backward (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
Initialise a range iterator over the range of nodes selected by
@var{range} (remember that ranges are inclusive); the minimum field of
@var{range} is interpreted as the starting node of the iteration, while
the maximum field of @var{range} is interpreted as the ending node of
the iteration.
@end deftypefun


@c ------------------------------------------------------------

@subsubsection Examples of forward iteration


@noindent
To perform a complete iteration, we have to start from the top node of
the tree (@code{5} in the picture above), already visited, and begin
from there.  Example:

@example
ucl_node_t        cur;

for (cur = select_the_top_node();
     cur;
     cur = ucl_btree_step_pre(cur))
  @{
    do_something_with(cur);
  @}
@end example

@noindent
this works because the top node of a btree has a @null{} value in the
dad pointer field.

To restrict the iteration to a subtree of a tree: we cannot loop until
the function returns @null{}, because the top node of a subtree has a
non--@null{} value in the dad pointer field.  With reference to the
picture above: we select the top node (number 10) and we visit it; then
we step to the next (number 7) and visit it; then we enter the loop
until the iterator reaches the top node (number 10 again).

Example:

@example
ucl_node_t        cur, end;

end = cur = get_a_node();

do_something_with(cur);
for (cur = ucl_btree_step_preorder(cur);
     cur != end;
     cur = ucl_btree_step_preorder(cur))
  @{
    do_something_with(cur);
  @}
@end example

@c ------------------------------------------------------------

@c page
@node btree postorder iteration
@subsubsection Postorder iteration


@noindent
Postorder iteration: visit the son, then the brother, then the parent
node.  Example:

@example
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example  

@noindent
the postorder iteration is:

@example
forward:    2,  4,  3,  1,  6,  8,  9,  7, 11, 12, 10,  5
backward:  11, 12,  8,  9,  6,  7, 10,  4,  2,  3,  1,  5
@end example

All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefn {Inline Function} {void *} ucl_btree_first_postorder (void * @var{root})
@deftypefnx {Inline Function} {void *} ucl_btree_first_postorder_backward (void * @var{root})
Given a pointer to the root node of a tree, return the first node of a
postorder iteration.  For the forward iteration: it is the deepest son
found by @function{ucl_btree_find_deepest_son}; for the backward
iteration: it is the deepest bro found by
@function{ucl_btree_find_deepest_bro}.
@end deftypefn


@deftypefun {void *} ucl_btree_step_postorder (void * @var{current})
@deftypefunx {void *} ucl_btree_step_postorder_backward (void * @var{current})
Advance a forward postorder iteration.  Given a node in a btree: perform
a single step and return a pointer to the next node, or @null{} if the
iteration is over.
@end deftypefun


@deftypefun void ucl_btree_iterator_postorder (ucl_iterator_t @var{iter}, void * @var{root})
@deftypefunx void ucl_btree_iterator_postorder_backward (ucl_iterator_t @var{iter}, void * @var{root})
Initialise a whole tree iterator; @var{root} must be the root node of a
btree.
@end deftypefun


@deftypefun void ucl_btree_subtree_iterator_postorder (ucl_iterator_t @var{iter}, void * @var{node})
@deftypefunx void ucl_btree_subtree_iterator_postorder_backward (ucl_iterator_t @var{iter}, void * @var{node})
Initialise a subtree iterator; @var{node} must be the a node of a btree,
and will be used as root node of the subtree.
@end deftypefun


@deftypefun void ucl_btree_range_iterator_postorder (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
@deftypefunx void ucl_btree_range_iterator_postorder_backward (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
Initialise a range iterator over the range of nodes selected by
@var{range} (remember that ranges are inclusive); the minimum field of
@var{range} is interpreted as the starting node of the iteration, while
the maximum field of @var{range} is interpreted as the ending node of
the iteration.
@end deftypefun


@c ------------------------------------------------------------

@subsubsection Examples of forward iteration


@noindent
To perform a complete iteration, we have to select the deepest leftmost
son in the tree (@code{2} in the example) and begin from there.  Example:

@example
ucl_node_t        cur;

cur = get_a_node();
for (cur = ucl_btree_find_deepest_son(cur);
     cur != NULL;
     cur = ucl_btree_step_postorder(cur));
  @{
    do_something_with(cur);
  @}
@end example

To restrict the iteration to a subtree of a tree, we have to check when
the iterator reaches the top node.  Example:

To restrict the iteration to a subtree of a tree: we cannot loop until
the function returns @null{}, because the top node of a subtree has a
non--@null{} value in the parent pointer field.  With reference to the
tree in the picture above: we select the top node (number 10); then we
move to the deepest son (number 6) and we visit it; then we enter the
loop until the iterator reaches the top node (number 10 again).

Example:

@example
ucl_node_t        cur, end;

cur = end = get_a_node();

for (cur = ucl_btree_find_deepest_son(cur);
     cur != end;
     cur = ucl_btree_step_postorder(cur));
  @{
    do_something_with(cur);
  @}

/* Here "cur == end" and we visit it. */
do_something_with(cur);
@end example

@noindent
@code{cur} can't be null in the loop.

@c ------------------------------------------------------------

@c page
@node btree level iteration
@subsubsection Level order iteration


@noindent
Level order iteration: visit the tree level by level.  Example:

@example  
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
the order of the forward iteration is: 5, 1, 10, 3, 7, 12, 2, 4, 6, 9,
11, 8.  To do it we need a moving cursor that always ``turns right''
keeping the count of the level.  The order of the backward iteration is:
5, 10, 1, 12, 7, 3, 11, 9, 6, 4, 2, 8.

All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefn {Inline Function} {void *} ucl_btree_first_levelorder (void * @var{root})
@deftypefnx {Inline Function} {void *} ucl_btree_first_levelorder_backward (void * @var{root})
Given a pointer to the root node of a tree, return the first node of a
levelorder iteration.  For both the forward and backward iterations: it
is the root node itself.
@end deftypefn


@deftypefun {void *} ucl_btree_step_levelorder (void * @var{self})
@deftypefunx {void *} ucl_btree_step_levelorder_backward (void * @var{self})
Advance a levelorder iteration.  Given a node in the three: perform a
single step and return a pointer to the next node, or @null{} if the
iteration is over.
@end deftypefun


@deftypefun void ucl_btree_iterator_levelorder (ucl_iterator_t @var{iter}, void * @var{root})
@deftypefunx void ucl_btree_iterator_levelorder_backward (ucl_iterator_t @var{iter}, void * @var{root})
Initialise a whole tree iterator; @var{root} must be the root node of a
btree.
@end deftypefun


@ignore
@deftypefun void ucl_btree_subtree_iterator_levelorder (ucl_iterator_t @var{iter}, void * @var{node})
@deftypefunx void ucl_btree_subtree_iterator_levelorder_backward (ucl_iterator_t @var{iter}, void * @var{node})
Initialise a subtree iterator; @var{node} must be the a node of a btree,
and will be used as root node of the subtree.
@end deftypefun


@deftypefun void ucl_btree_range_iterator_levelorder (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
@deftypefunx void ucl_btree_range_iterator_levelorder_backward (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
Initialise a range iterator over the range of nodes selected by
@var{range} (remember that ranges are inclusive); the minimum field of
@var{range} is interpreted as the starting node of the iteration, while
the maximum field of @var{range} is interpreted as the ending node of
the iteration.
@end deftypefun
@end ignore

@c ------------------------------------------------------------

@subsubsection Examples of forward iteration


@noindent
To perform a complete iteration, we just call the function until it
returns @null{}.  Example:

@example
ucl_node_t cur;

for (cur = get_the_top_node();
     cur != NULL;
     cur = ucl_btree_step_levelorder(cur));
  @{
    do_something_with(cur);
  @}
@end example

@c ------------------------------------------------------------

@subsubsection Examples of backward iteration


@noindent
To perform a complete iteration, we just call the function until it
returns @null{}.  Example:

@example
ucl_node_t cur;

for (cur = get_the_top_node();
     cur != NULL;
     cur = ucl_btree_step_levelorder_backward(cur));
  @{
    do_something_with(cur);
  @}
@end example


@c end of file
