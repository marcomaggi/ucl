\input texinfo.tex @c -*-texinfo-*-
@c %**start of header
@setfilename ucl.info
@settitle Useless Containers Library
@c %**end of header


@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@macro ucl{}
@acronym{UCL}
@end macro

@macro tcl{}
@acronym{TCL}
@end macro

@macro dfs{}
@acronym{DFS}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms

@macro ascii{}
@acronym{ASCII}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro urla{}
@acronym{URL}
@end macro

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c C language macros.

@macro function{NAME}
@code{\NAME\()}
@end macro

@macro null{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c Other programming language macros

@macro module{NAME}
@code{\NAME\}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Useless Containers Library

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @ucl{}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ucl

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marcomaggi@@gna.org}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a set of
containers that can hold the basic set of C language types and untyped
pointers.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://gna.org/projects/@value{PACKAGE_NICKNAME}}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front--Cover Texts, and no Back--Cover Texts.  A
copy of the license is included in the section entitled ``@gnu{} Free
Documentation License''.
@end quotation
@end copying

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifnottex
@dircategory Development
@direntry
* UCL: (ucl).                   Useless Containers Library. 
@end direntry
@end ifnottex

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c ------------------------------------------------------------

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the library.
* memory::                      Memory allocation.
* typedefs::                    Data types you have to know. 
* containers::                  The data structures. 
* iterators::                   Container iteration.
* generic::                     Generic functions.
* stub::                        The stubs mechanism.

Appendices

* library version::             How to interpret the library version.
* stub mechanism::              The stub mechanism.
* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references. 
* concept index::               An entry for each concept. 
* function index::              An entry for each function. 
* type index::                  An entry for each type. 
* variable index::              An entry for each variable. 

@detailmenu
 --- The Detailed Node Listing ---

Overview of the library

* overview using::              Using the library.
* overview autoconf::           Using @gnu{} Autoconf to load @ucl{}.
* overview pkgconfig::          Using pkgconfig to load @ucl{}.
* overview error::              Error handling.
* overview size::               Structures size.
* overview const::              Constification.

Memory allocation

* memory typedefs::             Allocator data types.
* memory functions::            The default allocator.
* memory blocks::               Handling blocks of memory.
* memory ascii::                Handling ASCII strings.
* memory macros::               Miscellaneous macros.

Data types you have to know

* typedefs value::              Collected values and others.
* typedefs ranges::             Range selectors.
* typedefs compar::             Comparison functions.
* typedefs hash::               Hash functions.
* typedefs callback::           Callback functions.

Range selectors

* typedefs ranges macros::      Macros to handle ranges.
* typedefs ranges types::       Type of ranges.

The data structures

* btree::                       The binary tree structure.
* circular::                    The circular list structure.
* graph::                       The graph structure.
* hash::                        The hash table structure.
* heap::                        The heap structure.
* list::                        The linked list structure.
* map::                         The map structure.
* tree::                        The tree structure.
* vector::                      The vector structure.

The binary tree container

* btree creation::              Building btree hierarchies.
* btree inspection::            Accessing nodes.
* btree removing::              Removing elements from a btree.
* btree find::                  Finding special nodes.
* btree iteration::             Iterations in a btree hierarchy.

Iterations in a btree hierarchy

* btree inorder iteration::     Inorder iteration.
* btree preorder iteration::    Preorder iteration.
* btree postorder iteration::   Postorder iteration.
* btree level iteration::       Level order iteration.

The circular list

* circular creation::           Creating and destroying circulars.
* circular adding::             Adding elements to a circular.
* circular removing::           Removing elements from a circular.
* circular moving::             Moving the cursor.
* circular search::             Searching elements.
* circular ops::                Various operations on a circular.
* circular data::               Another usage for links.

The graph structure

* graph implementation::        How it's done.
* graph insert::                Inserting links and nodes.
* graph extract::               Extracting links and nodes.
* graph merge::                 Merging links.
* graph node list::             Chaining nodes.
* graph value::                 Accessing values.
* graph link iter::             Link iterators.
* graph ops::                   Various operations on a graph.
* graph dfs::                   Depth first search.

The hash table structure

* hash implementation::         How it's done.
* hash creation::               Creating and destroying hash tables.
* hash adding::                 Adding elements to a hash table.
* hash removing::               Removing elements from a hash table.
* hash ops::                    Various operations on a hash table.
* hash resizing::               Resizing a hash table.
* hash iterator::               Visiting elements in the table.
* hash functions::              Provided hash function.

The heap structure

* heap creation::             Creating and destroying heaps.
* heap adding::               Adding elements to a heaps.
* heap removing::             Removing elements from a heaps.
* heap ops::                  Various operations on a heaps.

The linked list structure

* list creation::               Creating and destroying lists.
* list adding::                 Adding elements to a list.
* list removing::               Removing elements from a list.
* list ops::                    Various operations on a list.
* list iteration::              Iteration over a list.

The map structure

* map intro::                   Introduction to operations and
                                implementation.
* map creation::                Creating and destroying maps.
* map adding/removing::         Adding and removing elements to a map.
* map accessors::               Accessing values and keys.
* map ops::                     Various operations on a map.
* map iterators::               Iteration over a map.
* set iterators::               Composing map iterators.

The tree structure

* tree implementation::         How it's done.
* tree creation::               Creating tree nodes.
* tree testing::                Testing relationships between nodes.
* tree relatives::              Accessing or setting the relatives of
                                a node.
* tree adding::                 Adding elements to a tree.
* tree removing::               Removing elements from a tree.
* tree iterators::              Traversing a tree.

The vector structure

* vector implementation::       How it's done.
* vector fields::               Fields and default configuration
                                for vectors.
* vector creation::             Creating and destroying vectors.
* vector indexes::              Converting indexes to pointers.
* vector adding::               Adding elements to a vector.
* vector removing::             Removing elements from a vector.
* vector ops::                  Various operations on a vector.
* vector find::                 Finding elements.
* vector iteration::            Iteration over a vector.
* vector memory::               Allocating and freeing memory.
* vector as pqueue::            Using a vector as a priority queue.
* vector high::                 High level functions.

High level functions

* vector high stack::           Stack and queue.
* vector high append::          Appending data to a vector.
* vector high insert::          Inserting into a vector.
* vector high erase::           Removing from a vector.
* vector high access::          Setters and getters.
* vector high compare::         Comparing vectors.
* vector high apply::           Applying functions.

@end detailmenu
@end menu

@end ifnottex

@c ------------------------------------------------------------

@c page
@node overview
@chapter Overview of the library


@menu
* overview using::              Using the library.
* overview autoconf::           Using @gnu{} Autoconf to load @ucl{}.
* overview pkgconfig::          Using pkgconfig to load @ucl{}.
* overview error::              Error handling.
* overview size::               Structures size.
* overview const::              Constification.
@end menu


@noindent
This container library may be thought of as ``low level''.  Methods are
provided to handle collected data, but no container can be used without
wrapping it in a module whose functions ``know'' how to deal with the
type of collected data.

The containers have to be used as ``leaves'' in the graph of
dependencies of a whole application; they provide a service: collecting
data.  For example: if we need to store a data structure in a linked
list, we don't have to think that the structure ``is a'' list link, but
rather that, temporarily, the structure is ``referenced by'' a list
link.

We give to the container the responsibility to hold a reference to a
structure and we will come back later to take it out.

All the function and data type names are prefixed with @code{ucl_}.
There is no error reporting system: it is our responsibility to validate
function's arguments using the appropriate functions.  With the single
exception of the vector module: @ucl{} does no memory allocation.

@ref{stub} for details about how to use the stub mechanism.

The library is developed and tested under the Linux+@gnu{} system and
officially it supports only the @gnu{} infrastructure: requires the
@gnu{} C library and compiles fine with the @gnu{} C compiler
(@code{-std=c99 -pedantic} switches).


@c ------------------------------------------------------------

@set using_package_name         @value{PACKAGE}
@set using_package              @value{PACKAGE_NICKNAME}
@set using_PACKAGE              UCL
@set using_config_script        @value{PACKAGE_NICKNAME}-config
@set using_xversion             1.0a1
@set using_version              1.0.0
@set using_iface_version        1.2
@set using_autoconf_macro       USELESS_CONTAINERS_LIBRARY

@include overview-using.texiinc

@c ------------------------------------------------------------

@c page
@node overview error
@section Error handling


@noindent
The design of methods tries to be the one that maximises the number of
functions that cannot fail.  This sometimes leads to ``strange'' or
``dangerous'' methods: functions that will cause the application to
crash if an argument is incorrect.  But, in these cases, the library
provides a function to test the argument separately: to assert the
precondition.

For example: if a vector index is out of range, we have to make sure not
to hand it to an insertion/extraction method; we have to test it first
and make use of it only if the test result is good.

@c ------------------------------------------------------------

@c page
@node overview size
@section Structures size


@noindent
Under the tests directory of the source tree there is a small program
that links to the library and prints the size of the @ucl{} data
structures.  On a @code{i686-pc-linux-gnu} the output is:

@example
Size of common data types:

char            1 :)
void *          4
int             4
short int       2
long int        4
long long       8
float           4
double          8
long double     12
size_t          4
ptrdiff_t       4

Limits:

short int (SHRT_MIN, SHRT_MAX)  -32768 32767
integer (INT_MIN, INT_MAX)      -2147483648 2147483647
unsigned short int (USHRT_MAX)  65535
unsigned (UINT_MAX)             4294967295

Size of UCL structures:

ucl_value_t     4
ucl_circular_t  16
ucl_hash_t      68
ucl_iterator_t  20
ucl_list_t      20
ucl_map_t       20
ucl_vector_t    48

Size of UCL link structures:

ucl_btree_node_t        12
ucl_hash_entry_t        16
ucl_list_link_t         16
ucl_map_link_t          24
ucl_tree_node_t         12
ucl_graph_node_t        28
ucl_graph_link_t        28
@end example

@c ------------------------------------------------------------

@c page
@node overview const
@section Constification


@noindent
This library has the need to write functions, conceptually, like this
one:

@example
void data_type_t *
the_function (data_type_t * p)
@{
  return p;
@}
@end example

@noindent
that is: functions that do not modify the arguments, but whose return
value must be modifiable.  To write them like this:

@example
void data_type_t *
the_function (const data_type_t * p)
@{
  return p;
@}
@end example

@noindent
would be useful because:

@enumerate
@item
it makes clear to the user that the data referenced by @code{p} is not
modified;
@item
causes the compiler to raise an error if we attempt to modify the data;
@end enumerate

@noindent
but a warning is issued because the @code{return} statement discards the
@code{const} qualifier.

The adopted solution is to avoid the @code{-Wcast-qual} flag of the
@gnu{} C compiler, which is responsible to issue a warning if we discard
a qualifier with a cast; so the following implementation does not raise
warnings:

@example
void data_type_t *
the_function (const data_type_t * p)
@{
  return (data_type_t *)p;
@}
@end example

It is not beautiful.  But the ugliness is only in the @ucl{} code, the
user does not see it.

@c ------------------------------------------------------------

@c page
@node memory
@chapter Memory allocation


@noindent
The @ucl{} tries to avoid as much as possible the responsibility to
allocate and free memory.  Dynamic structures based on trees or linked
lists do not call any memory allocation function: the responsibility to
allocate @ucl{} data structures is delegated to the user's code.

This makes the library a little more complex to use, but it also makes
library's code simpler by reducing the error cases that have to be dealt
with.  Also, user's code can implement a custom allocator and feed
memory blocks to the @ucl{} functions.  This may come in handy because
the @ucl{} makes use of a lot of little data structures.

When needed: the library makes use of a default allocator that reverts
to the standard @function{malloc}, @function{realloc} and
@function{free} functions.

@menu
* memory typedefs::             Allocator data types.
* memory functions::            The default allocator.
* memory blocks::               Handling blocks of memory.
* memory ascii::                Handling ASCII strings.
* memory macros::               Miscellaneous macros.
@end menu

@c ------------------------------------------------------------

@c page
@node memory typedefs
@section Data types



@deftp {Struct Typedef} ucl_memory_allocator_t
Type of the memory allocator.  We may build structures of this type to
select a memory allocation policy.  Fields description follows.

@table @code
@item void * data
Pointer to an allocator data structure, which holds the state of the
allocator; it is used as first argument to the allocator function, it
can be @null{}.

@item ucl_memory_alloc_fun_t * alloc
Pointer to a function used to allocate/reallocate/free a memory block.
@end table
@end deftp


@deftypefun void ucl_memory_alloc_fun_t (void * @var{data}, void * @var{pp}, size_t @var{dim})
Function prototype declaration for the function that allocates memory
blocks.  @var{data} is the value of the @code{data} field in the
allocator data structure; @var{pp} is internally cast to @code{void **}
and is a pointer to the variable that holds the pointer to handle;
@var{dim} is the dimension, in bytes, of the memory block.

The protocol:

@itemize
@item
if @var{dim} is zero:

@itemize
@item
if @code{*@var{pp}} is @null{}: nothing happens,
@item
else @code{*@var{pp}} is not @null{}: the referenced memory is
freed;
@end itemize

@item
else @var{dim} is positive:

@itemize
@item
if @code{*@var{pp}} is @null{}: a new block of memory is allocated
and a pointer to it stored in @code{*@var{pp}};

@item
else @code{*@var{pp}} is not @null{}: the block of memory referenced
by @code{*@var{pp}} is reallocated and a pointer to the new block is
stored in @code{*@var{pp}}.
@end itemize
@end itemize

This function must work like @function{malloc}, @function{realloc} and
@function{free} with the fundamental difference that: in case of error
it must not return.  What it does instead of returning is not the
business of @ucl{}; the default allocator will terminate the process
with an invocation to @function{exit} with code @code{EXIT_FAILURE}.
@end deftypefun


Example of new memory block allocation:

@example
ucl_memory_allocator_t allocator;
void * p = NULL;

allocator.alloc(allocator.data, &p, 4096);
@end example

@noindent
example of memory block reallocation:

@example
ucl_memory_allocator_t allocator;
void * p = ...;

allocator.alloc(allocator.data, &p, 4096);
@end example

@noindent
example of memory releasing:

@example
ucl_memory_allocator_t allocator;
void * p = ...;

allocator.alloc(allocator.data, &p, 0);
@end example


@c ------------------------------------------------------------

@c page
@node memory functions
@section Public interface


@deftypefun void ucl_memory_alloc (void * @var{data}, void * @var{q}, size_t @var{dim})
Allocate, reallocate or free a block of memory.  @var{data} is ignored:
it is perfectly correct to invoke this function with @var{data} set to
@null{}.
@end deftypefun


The implementation is:

@example
void
ucl_memory_alloc (void * dummy, void * q, size_t dim)
@{
  void **  pp = q;
  void *   p;


  if (0 == dim)
    @{
      if (NULL != *pp)
        @{
          free(*pp);
          *pp = NULL;
        @}
    @}
  else
    @{
      p = (NULL == *pp)? calloc(1, dim) : realloc(*pp, dim);
      if (NULL == p)
        @{
          perror(strerror(errno));
          exit(EXIT_FAILURE);
        @}
      *pp = p;
    @}
@}
@end example


@c ------------------------------------------------------------

@c page
@node memory blocks
@section Memory blocks


@noindent
This module offers a set of functions to handle memory blocks.  All the
functions are declared as @code{__inline__}.


@deftp {Struct Typedef} ucl_block_t
The type of memory block.  Fields description follows.

@table @code
@item size_t len
The number of bytes in the block; can be zero.

@item uint8_t * ptr
Pointer to the memory block or @null{}.
@end table
@end deftp


@defmac UCL_BLOCK_NULL_VALUE
@defmacx UCL_BLOCK_EMPTY
@defmacx UCL_EMPTY_BLOCK
Define the nil values to initialise a block.  To be used like this:

@example
ucl_block_t     B = UCL_BLOCK_NULL_VALUE;
@end example
@end defmac


@deftypefun void ucl_block_set (ucl_block_t * @var{block}, void * @var{ptr}, size_t @var{len})
Set the fields of the block structure.
@end deftypefun


@deftypefun void ucl_block_reset (ucl_block_t * @var{block})
Reset to zero all the fields of the block.
@end deftypefun


@deftypefun bool ucl_block_is_null (ucl_block_t @var{block})
Return true if the @code{ptr} field of @var{block} is @null{}.
@end deftypefun


@deftypefun void ucl_block_clean_memory (ucl_block_t @var{block})
Reset to zero all the bytes in the memory block.
@end deftypefun


@deftypefun ucl_block_t ucl_block_alloc (ucl_memory_allocator_t @var{allocator}, size_t @var{dim})
@deftypefunx ucl_block_t ucl_block_realloc (ucl_memory_allocator_t @var{allocator}, ucl_block_t @var{block}, size_t @var{new_dim})
Allocate or reallocate a memory block using the @var{allocator} and
return the resulting block.
@end deftypefun


@deftypefun void ucl_block_free (ucl_memory_allocator_t @var{allocator}, ucl_block_t @var{block})
If the @code{ptr} field of @var{block} is not @null{}: free the
referenced memory block using @var{allocator}.
@end deftypefun


@c ------------------------------------------------------------

@c page
@node memory ascii
@section Handling ASCII strings


@noindent
This module offers a set of functions to handle @ascii{} coded, zero
terminated strings.  All the functions are declared as
@code{__inline__}.


@deftp {Struct Typedef} ucl_ascii_t
The type of string.  Fields description follows.

@table @code
@item size_t len
The number of characters in the block; can be zero; it does @strong{not}
include the terminating null character.

@item char * ptr
Pointer to the memory block or @null{}; the last @code{char} must be
zero.
@end table
@end deftp


@deftp {Struct Typedef} ucl_ascii_list_t
Holds an array of @code{char *}.  Fields:

@table @code
@item size_t len
the number of strings;
@item char ** ptr
the array of pointers.
@end table
@end deftp


@defmac UCL_ASCII_NULL_VALUE
@defmacx UCL_ASCII_EMPTY
@defmacx UCL_EMPTY_ASCII
Define the nil values to initialise a ascii.  To be used like this:

@example
ucl_ascii_t     B = UCL_ASCII_NULL_VALUE;
@end example
@end defmac



@deftypefun void ucl_ascii_set (ucl_ascii_t * @var{ascii}, void * @var{ptr}, size_t @var{len})
Initialise the fields of a structure.
@end deftypefun


@deftypefun void ucl_ascii_reset (ucl_ascii_t * @var{ascii})
Reset to zero the fields.
@end deftypefun


@deftypefun ucl_ascii_t ucl_ascii_const (const char * @var{string})
Build and return a structure initialised with @var{string}.  The length
is determined with the standard @function{strlen} function.
@end deftypefun


@deftypefun bool ucl_ascii_is_null (ucl_ascii_t @var{ascii})
Return true if the pointer field is set to @null{}.
@end deftypefun


@deftypefun void ucl_ascii_clean_memory (ucl_ascii_t @var{ascii})
Reset the block of memory to zero bytes.
@end deftypefun


@deftypefun ucl_block_t ucl_block_from_ascii (ucl_ascii_t @var{ascii})
Return a block initialised with the fields of an @ascii{} block.
@end deftypefun

@deftypefun ucl_ascii_t ucl_ascii_from_block (ucl_block_t @var{block})
Return an @ascii{} block initialised with the fields of a block.
@end deftypefun


@deftypefun ucl_ascii_t ucl_ascii_alloc (ucl_memory_allocator_t @var{allocator}, size_t @var{dim})
@deftypefunx ucl_ascii_t ucl_ascii_realloc (ucl_memory_allocator_t @var{allocator}, ucl_ascii_t @var{ascii}, size_t @var{new_dim})
Allocate or reallocate an @ascii{} block using @var{allocator};
@var{dim} and @var{new_dim} are the number of characters to be stored in
the block, with the @strong{exclusion} of the terminating zero.
@end deftypefun


@deftypefun void ucl_ascii_free (ucl_memory_allocator_t @var{allocator}, ucl_ascii_t @var{ascii})
If the @code{ptr} field of @var{ascii} is not @null{}: free the
referenced memory block using @var{allocator}.
@end deftypefun


@c ------------------------------------------------------------

@c page
@node memory macros
@section Miscellaneous macros


@subsection Structures


@defmac ucl_struct_clean (@var{struct_p}, @var{type})
@defmacx ucl_struct_reset (@var{struct_p}, @var{type})
Reset to zero, using @function{memset}, the structure of @var{type}
pointed to by @var{struct_p}.
@end defmac


@defmac ucl_struct_alloc (ucl_memory_allocator_t @var{allocator}, void * @var{p}, @var{type})
Allocate a new structure of @var{type} using @var{alloctor} and store a
pointer to it in @var{p}.  Example:

@example
typedef struct a_t @{
  int      i;
@} a_t;

a_t * p;

ucl_struct_alloc(allocator, p, a_t);
@end example
@end defmac

@c ------------------------------------------------------------

@c page
@node typedefs
@chapter Data types you have to know


@noindent
The types of container structures and links/nodes are described in the
sections dedicated to containers.  Here common data types are described.

@menu
* typedefs value::              Collected values and others.
* typedefs ranges::             Range selectors.
* typedefs compar::             Comparison functions.
* typedefs hash::               Hash functions.
* typedefs callback::           Callback functions.
@end menu


@c ------------------------------------------------------------

@c page
@node typedefs value
@section Collected values and others


@deftp {Union Typedef} ucl_value_t
The data type of objects that can be stored in the containers.  It's a
@code{union} with the following members:

@table @code
@item unsigned unum
@item int num
@item int integer
@item void * ptr
@item char * str
@item uint8_t * bytes
@end table
@end deftp


@deftp {Alias Typedef} ucl_bool_t
Alias for @code{_Bool}, which is defined by the C99 standard.  The
standard defines also the @code{true} and @code{false} values (in the
@file{stdbool.h} header).
@end deftp


@deftp {Alias Typedef} ucl_index_t
@deftpx {Alias Typedef} ucl_vector_index_t
Alias for @code{size_t}.  @code{ucl_vector_index_t} is deprecated.
@end deftp


@deftp {Alias Typedef} ucl_data_t
Alias for @code{void *}.
@end deftp


@deftp {Struct Typedef} ucl_array_of_pointers_t
Array of pointers.  Public fields:

@table @code
@item void ** slots
pointer to an array of pointers: @code{void *}; this type implies no
assumption upon the origin of the array memory, it can be statically or
dynamically allocated, or it can be on the stack;

@item size_t number_of_slots
the number of elements in @code{slots};

@item ucl_value_t data;
custom value that can be used to store a context associated to the
array; this field is useful when we need to hand a pointer to an array
to some function like a callback.
@end table
@end deftp


@subsection Temporary linked lists


@noindent
Let's say that we want to preallocate a set of structures to be used
with the @ucl{}, for example: @code{ucl_list_link_t}, the structure
representing a node in the @ucl{}'s doubly linked list.  We allocate them
with code like:

@example
#define NUMBER_OF_PREALLOCATED_STRUCTS          4096
ucl_memory_allocator    allocator;
ucl_list_link_t *       link_p;


for (size_t i=0; i<NUMBER_OF_PREALLOCATED_STRUCTS; ++i)
  @{
    link_p = NULL;
    allocator.alloc(allocator.data, &link_p, sizeof(ucl_list_link_t));
    /* here we have to put the links somewhere */
  @}
@end example

@noindent
it can be convenient to put the links in a linked list and extract them
at usage time.  We do not want to use the @code{ucl_list_t} container,
because it is overkill for this application, so we can use the following
special type.


@deftp {Struct Typedef} ucl_link_t
A structure with a single field, @code{ucl_link_t * next_p}, to be used
to collect structures in a linked list.
@end deftp


With it the preallocation code looks like this:

@example
#define NUMBER_OF_PREALLOCATED_STRUCTS          4096
ucl_memory_allocator    allocator;
ucl_link_t *            link_list_p = NULL;


@{
  ucl_link_t *          link_p;


  for (size_t i=0; i<NUMBER_OF_PREALLOCATED_STRUCTS; ++i)
    @{
      link_p = NULL;
      allocator.alloc(allocator.data, &link_p, sizeof(ucl_list_link_t));
      if (link_list_p)
        @{
          link_p->next_p = link_list_p;
          link_list_p    = link_p;
        @}
      else
        @{
          link_list_p = link_p;
          link_list_p->next_p = NULL; /* just to be sure */
        @}
    @}
@}
@end example

@noindent
to extract the links we do:

@example
ucl_link_t *            link_p;
ucl_link_t *            link_list_p;
ucl_list_link_t *       list_link_p;

...

if (link_list_p)
  @{
    link_p = link_list_p;
    link_list_p = link_p->next_p;
    list_link_p = (ucl_list_link_t *)link_p;
    /* here we can use 'list_link_p' */
  @}
else
  @{
    /* no more preallocated links */
  @}
@end example

@noindent
and to put them back:

@example
ucl_link_t *            link_p;
ucl_link_t *            link_list_p;

...

if (link_list_p)
  @{
    link_p->next_p = link_list_p;
    link_list_p    = link_p;
  @}
else
  @{
    link_list_p = link_p;
    link_list_p->next_p = NULL;
  @}
@end example

With better memory allocation:

@example
#define NUMBER_OF_PREALLOCATED_STRUCTS          4096
#define SIZE_OF_PREALLOCATED_MEMORY             \
  (NUMBER_OF_PREALLOCATED_STRUCTS * sizeof(ucl_list_link_t))

ucl_memory_allocator    allocator;
void *                  preallocated_links = NULL;
ucl_link_t *            link_list_p;


/* let's assume that this allocator initialises the
   block to zero bytes */
allocator.alloc(allocator.data, &preallocated_links,
                SIZE_OF_PREALLOCATED_MEMORY);

@{
  ucl_link_t *          link_p;


  link_p = link_list_p = preallocated_links;
  for (size_t i=0; i<NUMBER_OF_PREALLOCATED_STRUCTS-1; ++i)
    @{
      link_p->next_p = link_p + sizeof(ucl_list_link_t);
      link_p = link_p->next_p;
    @}
@}
@end example



@c ------------------------------------------------------------

@c page
@node typedefs ranges
@section Range selectors


@center @strong{RANGES ARE INCLUSIVE}

@menu
* typedefs ranges macros::      Macros to handle ranges.
* typedefs ranges types::       Type of ranges.
@end menu


@c ------------------------------------------------------------

@c page
@node typedefs ranges macros
@subsection Macros to handle ranges


@center @strong{RANGES ARE INCLUSIVE}

@noindent
All these macros accept as @var{range} arguments the name of a range
structure, @strong{not} the name of a pointer to the structure.


@defmac ucl_range_set_min_max (@var{range}, @var{min}, @var{max})
Initialise the min and max fields.
@end defmac

@defmac ucl_range_set_min_size (@var{range}, @var{min}, @var{size})
Initialise the min and sets the max to: @code{@var{min}+@var{size}-1}.
@end defmac

@defmac ucl_range_set_max_size (@var{range}, @var{max}, @var{size})
Initialise the max and sets the min to: @code{@var{max}-@var{size}+1}.
@end defmac

@defmac ucl_range_set_size_on_min (@var{range},  @var{size})
Set the max to: @code{@var{min}+@var{size}-1}.
@end defmac

@defmac ucl_range_set_size_on_max (@var{range},  @var{size})
Set the min to: @code{@var{max}-@var{size}+1}.
@end defmac

@defmac ucl_range_size (@var{range})
Return the size of the range.
@end defmac

@defmac ucl_range_is_empty (@var{range})
Return true if @var{range} is empty.
@end defmac

@defmac ucl_range_min (@var{range})
Return the min.
@end defmac

@defmac ucl_range_max (@var{range})
Return the max.
@end defmac

@defmac ucl_range_value_is_in (@var{range}, @var{value})
Return true if the value is inside the range.
@end defmac

@defmac ucl_range_value_is_out (@var{range}, @var{value})
Return true if the value is outside the range.
@end defmac

@defmac ucl_range_equal (@var{range_a}, @var{range_b})
Return true if the ranges are equal.
@end defmac


@c ------------------------------------------------------------

@c page
@node typedefs ranges types
@subsection Type of ranges


@center @strong{RANGES ARE INCLUSIVE}


@deftp {Struct Typedef} ucl_range_t
Data type used to describe a range of elements in a sequence, by
selecting the indexes.  The fields are of type @code{size_t}.
@end deftp


@deftp {Struct Typedef} ucl_char_range_t
@deftpx {Struct Typedef} ucl_unsigned_char_range_t
@deftpx {Struct Typedef} ucl_int_range_t
@deftpx {Struct Typedef} ucl_unsigned_range_t
@deftpx {Struct Typedef} ucl_long_range_t
@deftpx {Struct Typedef} ucl_unsigned_long_range_t
@deftpx {Struct Typedef} ucl_size_t_range_t
@deftpx {Struct Typedef} ucl_float_range_t
@deftpx {Struct Typedef} ucl_double_range_t
@deftpx {Struct Typedef} ucl_byte_pointer_range_t
Ranges of values.
@end deftp


@c ------------------------------------------------------------

@c page
@node typedefs compar
@section Comparison functions


@deftp {Struct Typedef} ucl_comparison_t
Structure holding a policy for values comparison.  Fields:

@table @code
@item ucl_value_t data
context to be used as first argument to the function;

@item ucl_comparison_fun_t * func
pointer to the function that compares two values of type
@code{ucl_value_t}.
@end table
@end deftp


@deftypefn {Function Typedef} int ucl_comparison_fun_t (ucl_value_t @var{data}, ucl_value_t @var{a}, ucl_value_t @var{b})
The type of functions used to compare values.  Functions of this type
are used by the associative containers.

The behaviour of the function must be the one of the standard function
@function{strcmp}: return @code{-1} if @code{a<b}, return @code{0} if
@code{a==b}, return @code{1} if @code{a>b}.

The function has the responsibility to provide the comparison policy: to
select a field in the @code{ucl_value_t} unions and establish when a
value is formally greater than the other.
@end deftypefn


Example:

@example
ucl_comparison_fun_t    intcmp;
ucl_comparison_t        compar = @{ NULL, intcmp @};
ucl_value_t             a, b;
int                     result;

result = compar.func(compar.data, a, v);
@end example


@c ------------------------------------------------------------

@c page
@node typedefs hash
@section Hash functions


@deftp {Struct Typedef} ucl_hash_t
Structure holding the hash function and its context.  Fields:

@table @code
@item ucl_value_t data
a context to be used as first argument to the function;

@item ucl_hash_fun_t * func
pointer to the function that computes the hash value.
@end table
@end deftp


@deftypefn {Function Typedef} ucl_index_t ucl_hash_fun_t (ucl_value_t @var{data}, ucl_value_t @var{key})
Type of hash functions used by the hash table.  The return value must be
the ``position'' of the key in a vector.  @ref{hash} for details.
@end deftypefn

@c ------------------------------------------------------------

@c page
@node typedefs callback
@section Callback functions


@deftp {Struct Typedef} ucl_callback_t
Holds a function pointer and a context value.  Public fields:

@table @code
@item ucl_callback_fun_t * func
pointer to the callback function;
@item ucl_value_t data
the context value.
@end table
@end deftp


@deftypefn {Function Prototype} void ucl_callback_fun_t (ucl_value_t @var{context}, va_list @var{ap})
Callback function.  @var{context} is the value stored in the callback
structure, representing the callback state.  @var{ap} is the list of
arguments: it is responsibility of the function to know how to interpret
them.
@end deftypefn


@defmac ucl_callback_is_present (ucl_callback_t @var{cb})
Evaluate to true if the @code{func} field of @var{cb} is not @null{}.
@end defmac


@deftypefun void ucl_callback_apply (ucl_callback_t @var{cb}, ...)
If @function{ucl_callback_is_present} applied to @var{cb} evaluates to
true: invoke the callback function using the callback context as first
argument and a @code{va_list} as second argument; the @code{va_list}
will hold references to the arguments to this function.
@end deftypefun


@deftypefun ucl_callback_eval_thunk (ucl_callback_t @var{cb})
Like @function{ucl_callback_invoke} but the @code{va_list} argument is
replaced by @null{}.
@end deftypefun


@subsection Example: callback initialisation


@noindent
To initialise a @code{ucl_callback_t} structure we can do:

@example
ucl_callback_t cb = @{
  .func = pointer_to_function,
  .data = @{ .ptr = pointer_to_data @}
@};
@end example

@noindent
to initialise to no--function and no--data:

@example
ucl_callback_t cb = UCL_CALLBACK_NULL_VALUE;
@end example


@subsection Example: callback invocation


@noindent
To invoke a callback we can do:

@example
ucl_callback_t  cb = ...;
int             a  = 123;
int             b  = 456;

ucl_callback_apply(cb, a, b);
@end example

@c ------------------------------------------------------------

@c page
@node containers
@chapter The data structures


@menu
* btree::                       The binary tree structure.
* circular::                    The circular list structure.
* graph::                       The graph structure.
* hash::                        The hash table structure.
* heap::                        The heap structure.
* list::                        The linked list structure.
* map::                         The map structure.
* tree::                        The tree structure.
* vector::                      The vector structure.
@end menu


@c ------------------------------------------------------------

@c page
@node btree
@section The binary tree container


@cindex Binary tree container
@cindex BTree container

@menu
* btree creation::              Building btree hierarchies.
* btree inspection::            Accessing nodes.
* btree removing::              Removing elements from a btree.
* btree find::                  Finding special nodes.
* btree iteration::             Iterations in a btree hierarchy.
@end menu

@noindent
The @ucl{} btree container provides an implementation of a binary tree.


@deftp {Struct Typedef} ucl_btree_node_t
The data type of the nodes.  Nodes must be allocated and freed by the
user's code.
@end deftp

The btree container is built as a chain of structures; each link has a
brother, a son and a parent:

@example
                 -----    bro     -----
                | no1 |--------->| no2 |
                 ----- <--------- -----
                 |  ^     dad
             son |  | dad
                 v  |
                 ----- 
                | no3 |
                 ----- 
@end example

@noindent
each node data structure is just a collection of pointers used to keep
trace of the tree hierarchy.  There's no data field: to use a tree to
store data we have to include the btree node structure in another
structure; that's what the @ucl{} map container does.

Each of the three pointers in the structure can be @null{}: that
means that the node has no parent, brother or son.  Functions and macros
are provided: to append nodes to other nodes; to extract nodes from the
tree; to traverse the hierarchy and to find particularly interesting
nodes.

@c page
@node btree creation
@subsection Building btrees hierarchies


@deftypefun void ucl_btree_constructor (ucl_btree_node_t * @var{self}, const ucl_btree_node_t * @var{dad})
Initialise an already allocated btree structure referenced by
@var{self}.  @var{dad} is a pointer to the parent node of @var{self}, or
@null{} if @var{self} has no parent node.   We can use this function to
initialise a new node and append it to an existing btree in a single
step.
@end deftypefun


@deftypefun void ucl_btree_destructor (ucl_btree_node_t * @var{self})
Reset all the node fields to @null{}.  It's a wrapper for
@function{ucl_struct_clean}.
@end deftypefun


@deftypefun void ucl_btree_setdad (ucl_btree_node_t * @var{self}, const ucl_btree_node_t * @var{dad})
Select a new parent node for @var{self}.
@end deftypefun


@deftypefun void ucl_btree_setbro (ucl_btree_node_t * @var{self}, const ucl_btree_node_t * @var{bro})
Select a new brother node for @var{self}.
@end deftypefun


@deftypefun void ucl_btree_setson (ucl_btree_node_t * @var{self}, const ucl_btree_node_t * @var{son})
Select a new child node for @var{self}.
@end deftypefun


@deftypefun void ucl_btree_dadson (ucl_btree_node_t * @var{dad}, ucl_btree_node_t * @var{son})
Link @var{dad} and @var{son} to be the parent and the son respectively.
@end deftypefun


@deftypefun void ucl_btree_dadbro (ucl_btree_node_t * @var{dad}, ucl_btree_node_t * @var{bro})
Link @var{dad} and @var{bro} to be the parent and the bro respectively.
@end deftypefun


Example of btree creation: we want @code{a} to be the root node;
@code{b} to be the son of @code{a}; @code{c} to be the brother of
@code{a}; @code{d} to be the son of @code{c}.

@example
ucl_memory_allocator_t  allocator;
ucl_btree_node_t        *a, *b, *c, *d;

a = b = c = d = NULL;
allocator.alloc(allocator.data, &a, sizeof(ucl_btree_node_t));
allocator.alloc(allocator.data, &b, sizeof(ucl_btree_node_t));
allocator.alloc(allocator.data, &c, sizeof(ucl_btree_node_t));
allocator.alloc(allocator.data, &d, sizeof(ucl_btree_node_t));

ucl_btree_constructor(a, NULL);

ucl_btree_constructor(b, a);
ucl_btree_setson(a, b);

ucl_btree_constructor(c, a);
ucl_btree_setbro(a, c);

ucl_btree_constructor(d, c);
ucl_btree_setson(c, d);
@end example

@noindent
now the hierarchy is:

@example
       ---  bro  ---
      | a |---->| c |
       ---       ---
        |         |
    son v     son v
       ---       ---
      | b |     | d |
       ---       ---
@end example

@noindent
the following expressions are true:

@example
(a == ucl_btree_getdad(b)) && (b == ucl_btree_getson(a))
(a == ucl_btree_getdad(c)) && (c == ucl_btree_getbro(a))
(c == ucl_btree_getdad(d)) && (d == ucl_btree_getson(c))
ucl_btree_getdad(a) == NULL
ucl_btree_getbro(c) == NULL
(ucl_btree_getson(b) == NULL) && (ucl_btree_getbro(b) == NULL)
(ucl_btree_getson(d) == NULL) && (ucl_btree_getbro(d) == NULL)
@end example

@c ------------------------------------------------------------

@c page
@node btree inspection
@subsection Accessing nodes


@deftypefun {ucl_btree_node_t *} ucl_btree_getdad (const ucl_btree_node_t * @var{self})
Return a pointer to the parent of @var{self} or @null{} if the node
has no parent.
@end deftypefun


@deftypefun {ucl_btree_node_t *} ucl_btree_getbro (const ucl_btree_node_t * @var{self})
Return a pointer to the brother of @var{self} or @null{} if the node has
no brother.
@end deftypefun


@deftypefun {ucl_btree_node_t *} ucl_btree_getson (const ucl_btree_node_t * @var{self})
Return a pointer to the son of @var{self} or @null{} if the node has no
son.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node btree removing
@subsection Removing elements from a btree


@noindent
It's a matter of setting pointers to @null{}.  Care must be taken not
to loose reference to subtrees.

We just use the @function{ucl_btree_setdad}, @function{ucl_btree_setbro}
and @function{ucl_btree_setson} macros.


Example: detach a subtree; the brother of the node @code{a} is detached
and made an independent tree:

@example
ucl_btree_node_t *   a;
ucl_btree_node_t *   b;

a = ...;
b = ucl_btree_getbro(a);

ucl_btree_setbro(a, NULL);
ucl_btree_setdad(b, NULL);
@end example

@c ------------------------------------------------------------

@c page
@node btree find
@subsection Finding special nodes


@deftypefun {ucl_btree_node_t *} ucl_btree_find_leftmost (const ucl_btree_node_t * @var{self})
Find the leftmost node in the subtree of the supplied node.  To do this,
we traverse the tree choosing always the son of the current node.

Example:

@example   
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
starting from @code{5} the selected node is @code{1}, starting from
@code{10} the selected node is @code{6}.

Return a pointer to the leftmost node in the @var{self} sub--hierarchy
or to @var{self} itself if it has no son.
@end deftypefun


@deftypefun {ucl_btree_node_t *} ucl_btree_find_rightmost (const ucl_btree_node_t * @var{self})
Find the rightmost node in the subtree of the supplied node.  To do this,
we traverse the tree choosing always the brother of the current node.

Example:

@example   
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
starting from @code{5} the selected node is @code{12}, starting from
@code{7} the selected node is @code{9}.

Return a pointer to the rightmost node in the @var{self} sub--hierarchy
or to @var{self} itself if it has no brother.
@end deftypefun


@deftypefun {ucl_btree_node_t *} ucl_btree_find_deepest_son (const ucl_btree_node_t * @var{self})
Find the deepest leftmost son in a subtree.  This is different from
@function{ucl_btree_find_leftmost}.

Example:

@example   
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
starting from @code{5} the selected node is @code{2}, starting from
@code{10} the selected node is @code{6}.

Return a pointer to the deepest son in the @var{self} sub--hierarchy,
or @var{self} itself if it has no son.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node btree iteration
@subsection Iterations in a btree hierarchy


@menu
* btree inorder iteration::     Inorder iteration.
* btree preorder iteration::    Preorder iteration.
* btree postorder iteration::   Postorder iteration.
* btree level iteration::       Level order iteration.
@end menu


@c page
@node btree inorder iteration
@subsubsection Inorder iteration


@noindent
Forward inorder iteration: visit all the nodes from the leftmost to the
rightmost.  Backward inorder iteration: visit all the nodes from the
rightmost to the leftmost.  Example: given the tree:
   
@example
      5-------10----12
      |        |     |
      1--3--4  7--9 11
      |  |     |  |
      0  2     6  8
@end example

@noindent
the inorder iteration is: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12; the
backward inorder iteration is: 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0.



@deftypefun {ucl_btree_node_t *} ucl_btree_step_inorder (const ucl_btree_node_t * @var{self})
Advance a forward inorder iteration.  Given a node in a btree, this
function performs a single step.  Return a pointer to the next node in
the iteration, or @null{} if the iteration is over.
@end deftypefun

@deftypefun {ucl_btree_node_t *} ucl_btree_step_inorder_backward (const ucl_btree_node_t * @var{self})
Advance a backward inorder iteration.  Given a node in a btree, this
function performs a single step.  Return a pointer to the next node in
the iteration, or @null{} if the iteration is over.
@end deftypefun


@subsubsection  Examples of forward iteration

@noindent
To perform a complete forward inorder iteration, we have to start from the
leftmost node (@code{0} in the picture), already visited, and begin from
there.  Example:

@example
ucl_btree_node_t *        cur;

cur     = select_a_btree(...);
cur     = ucl_btree_find_leftmost(cur);

while (cur);
  @{
    makes_use_of_node(cur);
    cur = ucl_btree_step_inorder(cur);
  @}
@end example

To restrict the iteration to a subtree of a tree or to a range of nodes
in a tree, we have to select the first and last nodes and check when the
iterator reaches the last.

Example of subtree restriction: does an inorder iteration from the top
of a subtree to the rightmost node in the subtree:

@example
ucl_btree_node_t *        cur, end;

cur     = select_a_node(...);
end     = ucl_btree_find_rightmost(cur);
cur     = ucl_btree_find_leftmost(cur);
makes_use_of_node(cur);

while (cur != end)
  @{
    cur = ucl_btree_step_inorder(cur);
    makes_use_of_node(cur);
  @}
@end example

@noindent
@code{cur} can't be @null{} because @code{end} is in the subtree of
the top node; this code should work even if: @code{cur == end}.

Example of range restriction: does an iteration starting from a node
(not the leftmost) to the rightmost one:

@example
ucl_btree_node_t *	root, cur, end;

root	= select_a_node(...);
cur	= select_first(root, ...);
end	= ucl_btree_find_rightmost(root);

makes_use_of_node(cur);

while (cur != end)
  @{
    cur = ucl_btree_step_inorder(cur);
    makes_use_of_node(cur);
  @}
@end example

@noindent
@code{cur} can't be @null{} since we selected the first and last
nodes in a subtree; this code should work even if: @code{root == cur ==
end}.


@subsubsection  Examples of backward iteration

@noindent
To perform a complete backward iteration, we have to start from the
rightmost node (@code{12} in the picture), already visited, and begin
from there.  Example:

@example
ucl_btree_node_t *        cur;

cur     = select_a_btree(...);
cur     = ucl_btree_find_rightmost(cur);

while (cur);
  @{
    makes_use_of_node(cur);
    cur = ucl_btree_step_inorder_backward(cur);
  @}
@end example

To restrict the iteration to a subtree of a tree or to a range of nodes
in a tree, we have to select the first and last nodes and check when the
iterator reaches the last.

Example of subtree restriction: does an iteration from the rightmost to
the leftmost nodes in a subtree:

@example
ucl_btree_node_t *        cur, end;

cur     = select_a_node(...);
end     = ucl_btree_find_leftmost(cur);
cur     = ucl_btree_find_rightmost(cur);

makes_use_of_node(cur);

while (cur != end)
  @{
    cur = ucl_btree_step_inorder_backward(cur);
    makes_use_of_node(cur);
  @}
@end example

@noindent
@code{cur} can't be @null{} because @code{end} is in the subtree of
the top node; this code should work even if: @code{cur == end}.

Example of range restriction:

@example
ucl_btree_node_t *        root, cur, end;

root    = select_a_node(...);
cur     = select_first(root, ...);
end     = ucl_btree_find_leftmost(root);

makes_use_of_node(cur);

while (cur != end)
  @{
    cur = ucl_btree_step_inorder_backward(cur);
    makes_use_of_node(cur);
  @}
@end example

@noindent
@code{cur} can't be @null{} since we selected the first and last
nodes in a subtree; this code should work even if: @code{root == cur ==
end}.

@c ------------------------------------------------------------

@c page
@node btree preorder iteration
@subsubsection Preorder iteration


@noindent
Preorder iteration: visit the current node then the son then the
brother.  Example:

@example
      5-------10----12
      |        |     |
      1--3--4  7--9 11
      |  |     |  |
      0  2     6  8
@end example

@noindent  
the order is: 5, 1, 0, 3, 2, 4, 10, 7, 6, 9, 8, 12, 11.  It's a worm that
always ``turns right''.


@deftypefun {ucl_btree_node_t *} ucl_btree_step_preorder (const ucl_btree_node_t *@var{self})
Advance a preorder iteration.  Given a node in a btree this function
performs a single step.  Return a pointer to the next node in the
preorder iteration, or @null{} if the iteration is over.
@end deftypefun


To perform a complete iteration, we have to start from the top node of
the tree (@code{5} in the example), already visited, and begin from
there.  Example:

@example
ucl_btree_node_t *    cur;

cur = select_a_btree(...);

while (cur);
  @{
    makes_use_of_node(cur);
    cur = ucl_btree_step_pre(cur);
  @}
@end example

@noindent
this works because the top node of a btree has a @null{} value in
the parent pointer field.

To restrict the iteration to a subtree of a tree: we cannot loop until
the function returns @null{}, because the top node of a subtree has a
non--@null{} value in the parent pointer field.  With reference to the
tree in the figure: we select the top node (number 10) and we visit it;
then we step to the next (number 7) and visit it; then we enter the loop
until the iterator reaches the top node (number 10 again).

Example:

@example
ucl_btree_node_t *        cur, end;

end = cur = select_a_node(...);

makes_use_of_node(cur);
cur = ucl_btree_step_preorder(cur);

while (cur != end);
  @{
    makes_use_of_node(cur);
    cur = ucl_btree_step_preorder(cur);
  @}
@end example

@c ------------------------------------------------------------

@c page
@node btree postorder iteration
@subsubsection Postorder iteration


@noindent
Postorder iteration: visit the son, then the brother, then the parent
node.  Example:

@example
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example  

@noindent
the order is: 2, 4, 3, 1, 6, 8, 9, 7, 11, 12, 10, 5.


@deftypefun {ucl_btree_node_t *} ucl_btree_step_postorder (const ucl_btree_node_t *@var{self})
Advance a postorder iteration.  Return a pointer to the next node in the
postorder iteration, or @null{} if the iteration is over.
@end deftypefun


To perform a complete iteration, we have to select the deepest leftmost
son in the tree (@code{2} in the example) and begin from there.  Example:

@example
ucl_btree_node_t *        cur;

cur     = select_a_node(...);
cur     = ucl_btree_find_deepest_son(cur);

while (cur != NULL);
  @{
    makes_use_of_node(cur);
    cur = ucl_btree_step_postorder(cur);
  @}
@end example

To restrict the iteration to a subtree of a tree, we have to check when
the iterator reaches the top node.  Example:

To restrict the iteration to a subtree of a tree: we cannot loop until
the function returns @null{}, because the top node of a subtree has a
non--@null{} value in the parent pointer field.  With reference to the
tree in the figure: we select the top node (number 10); then we moev to
the deepest son (number ) and we visit it; then we step to the next
(number 7) and visit it; then we enter the loop until the iterator
reaches the top node (number 10 again).

Example:

@example
ucl_btree_node_t *        cur, end;

cur = end = select_a_node(...);
cur = ucl_btree_find_deepest_son(cur);

makes_use_of_node(cur);
cur = ucl_btree_step_postorder(cur);

while (cur != end);
  @{
    cur = ucl_btree_step_postorder(cur);
    makes_use_of_node(cur);
  @}
@end example

@noindent
@code{cur} can't be null in the loop.

@c ------------------------------------------------------------

@c page
@node btree level iteration
@subsubsection Level order iteration


@noindent
Level order iteration: visit the tree level by level.  Example:

@example  
      5-------10----12
      |        |     |
      1--3--4  7--9 11
      |  |     |  |
      0  2     6  8
@end example

@noindent
the order is: 5, 1, 10, 0, 3, 7, 12, 2, 4, 6, 9, 11, 8.  We need a moving
cursor that always ``turns right'' keeping the count of the level.


@deftypefun {ucl_btree_node_t *} ucl_btree_step_levelorder (const ucl_btree_node_t *@var{self})
Advance a level--order iteration.  Return a pointer to the next node in
the levelorder iteration, or @null{} if the iteration is over.
@end deftypefun


To perform a complete iteration, we just call this function until it
returns @null{}.  Example:

@example
ucl_btree_node_t *        cur;

cur     = select_a_btree(...);

while (cur != NULL);
  @{
    makes_use_of_node(cur);
    cur = ucl_btree_step_levelorder(cur);
  @}
@end example

@c ------------------------------------------------------------

@c page
@node circular
@section The circular list


@menu
* circular creation::           Creating and destroying circulars.
* circular adding::             Adding elements to a circular.
* circular removing::           Removing elements from a circular.
* circular moving::             Moving the cursor.
* circular search::             Searching elements.
* circular ops::                Various operations on a circular.
* circular data::               Another usage for links.
@end menu

@noindent
The circular container provides a circular double linked list.  It's
implemented as a chain of little node structures; a pointer to the
@emph{current} position is stored in a base structure.  The current
position marker can be moved forward and backward as a cursor.


@deftp {Struct Typedef} ucl_circular_struct_t
Base structure of the container.  It must be allocated by the user's
code.
@end deftp


@deftp {Single Element Array Typedef} ucl_circular_t
A one--element array of @code{ucl_circular_struct_t}.
@end deftp


@deftp Struct ucl_circular_link_t
The data type of the nodes.  Nodes must be allocated and freed by the
user's code.
@end deftp


The handling of list links is derived from the handling of elements in
the @acronym{TCL} (Tool Command Language) hash table by John Ousterhout
and others (@url{http://www.tcl.tk} for more about @acronym{TCL}).

@c ------------------------------------------------------------

@c page
@node circular creation
@subsection Creating and destroying circulars


@deftypefun void ucl_circular_constructor (ucl_circular_t @var{self})
Initialises an already allocated structure.  Set all the fields of
@var{self} so that the structure represents an empty circular list.
@end deftypefun


@deftypefun void ucl_circular_destructor (ucl_circular_t @var{self})
Destroys the structure.  Set all the fields of @var{self} so that the
structure represents an empty circular list.  Before calling this
function the user's code has to make sure that all the links are
extracted from the list.
@end deftypefun


To extract all the links from a circular list, we can do:

@example
ucl_circular_t        circ;
ucl_circular_link_t * link_p;
ucl_value_t           val;

...

while (ucl_circular_size(circ))
  @{
    link_p = ucl_circular_extract(circ);
    val    = ucl_circular_getval(link_p);

    /* insert here the code to destroy the value */
    /* insert here the code to free the link memory */
  @}
@end example

@noindent
if the value needs no destructor and we are using a memory allocator as
implemented by @ucl{}, we can do:

@example
ucl_memory_allocator_t  allocator;
ucl_circular_t          circ;
ucl_circular_link_t *   link_p;

...

while (ucl_circular_size(circ))
  @{
    link_p = ucl_circular_extract(circ);
    allocator.alloc(allocator.data, &link_p, 0);
  @}
@end example

@c ------------------------------------------------------------

@c page
@node circular adding
@subsection Adding elements to a circular


@deftypefun void ucl_circular_insert (ucl_circular_t @var{self}, ucl_circular_link_t *@var{link_p})
Insert an element at the current position.  To do this the user's code
has to allocate a new circular link structure, store the value into it
and hand a pointer to the node to this function.

The old current link becomes the next link.
@end deftypefun


Example of element insertion:

@example
ucl_memory_allocator_t  allocator;
ucl_circular_t          circ;
ucl_circular_link_t *   link_p = NULL;
ucl_value_t             val;

...

allocator.alloc(allocator.data, &link_p, sizeof(ucl_circular_link_t));
val = ...;
ucl_circular_setval(link_p, val);
ucl_circular_insert(circ, link_p);
@end example

@c ------------------------------------------------------------

@c page
@node circular removing
@subsection Removing elements from a circular


@deftypefun {ucl_circular_link_t *} ucl_circular_extract (ucl_circular_t @var{self})
Extract the current link and return a pointer to it, or @null{} if the
list is empty.  The new current element is the next in the forward
direction.
@end deftypefun


Example of element removal:

@example
ucl_memory_allocator_t  allocator;
ucl_circular_t          circ;
ucl_circular_link_t *   link_p;
ucl_value_t             val;

...

link_p = ucl_circular_extract(circ);
if (NULL != link_p)
  @{
    val = ucl_circular_getval(link_p);
    /* do something with 'val' */
    allocator.alloc(allocator.data, &link_p, 0);
  @}
@end example


@c page
@node circular moving
@subsection Moving the cursor


@deftypefun void ucl_circular_forward (ucl_circular_t @var{self}, int @var{times})
Move forwards the current position, @var{times} is the forward offset:
it can be a positive or negative integer.  If the container is empty or
the offset is zero nothing happens.
@end deftypefun


@deftypefun void ucl_circular_backward (ucl_circular_t @var{self}, int @var{times})
A wrapper for @function{ucl_circular_forward}: move backwards the
current position, @var{times} is the backward offset.  If the container
is empty or the offset is zero nothing happens.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node circular search
@subsection Searching elements


@deftypefun void ucl_circular_set_compar (ucl_circular_t @var{this}, ucl_comparison_t @var{compar})
Register the function to be used to compare elements.
@end deftypefun


@deftypefun {ucl_circular_link_t *} ucl_circular_find (ucl_circular_t @var{self}, ucl_value_t @var{val})
Move the current position to the first forward element whose value is
equal to @var{val}; return a pointer to the link, or @null{} if the
value was not found.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node circular ops
@subsection Various operations on a circular


@deftypefun size_t ucl_circular_size (ucl_circular_t @var{self})
Return the number of elements in the container.
@end deftypefun


@deftypefun {ucl_circular_link_t *} ucl_circular_current (ucl_circular_t @var{self})
Return a pointer to the current link, or @null{} if the container is
empty.
@end deftypefun


@deftypefun ucl_value_t ucl_circular_getval (ucl_circular_link_t * @var{link_p})
@deftypefunx ucl_value_t ucl_circular_data (ucl_circular_link_t * @var{link_p})
Return a the data value in the link.
@end deftypefun


@deftypefun void ucl_circular_setval (ucl_circular_link_t * @var{link_p}, ucl_value_t @var{val})
Store a value in a link.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node circular data
@subsection Another usage for links


@noindent
It's possible to allocate memory for a value together with the link
structure.

@example
typedef struct my_link_t @{
  ucl_circular_link_t   link;
  my_data_t             bigdata;
@} my_link_t;

ucl_memory_allocator_t  allocator;
ucl_circular_link_t *   link_p = NULL;
ucl_value_t             val;

...

allocator.alloc(allocator.data, &p, sizeof(my_link_t));
val.ptr = &(((my_link_t *)link_p)->bigdata);
ucl_circular_setval(link_p, val);
@end example

@c ------------------------------------------------------------

@c page
@node graph
@section The graph structure


@menu
* graph implementation::        How it's done.
* graph insert::                Inserting links and nodes.
* graph extract::               Extracting links and nodes.
* graph merge::                 Merging links.
* graph node list::             Chaining nodes.
* graph value::                 Accessing values.
* graph link iter::             Link iterators.
* graph ops::                   Various operations on a graph.
* graph dfs::                   Depth first search.
@end menu


@noindent
A graph is a network of (not so) little structures.  The elements of the
graph are nodes and links.  Both node and link structures should be
allocated using an equivalent of @function{calloc}, or reset to zero
before being inserted in a graph.


@deftp {Struct Typedef} ucl_graph_node_t
The type of the node structure.  It should be treated as opaque even if
it is not.
@end deftp


@deftp {Struct Typedef} ucl_graph_link_t
The type of the link structure.  It should be treated as opaque even if
it is not.
@end deftp

@c ------------------------------------------------------------

@c page
@node graph implementation
@subsection How it's done


@noindent
@ucl{} does not enforce a collection of node structures: it is
responsibility of the user to put nodes somewhere.  For convenience: the
node structure has a ``next node'' field that allows us to put nodes
into a simply linked list, but it is not mandatory to use it.

Each node references two doubly linked lists of links: one for outgoing
links and one for incoming links.

@example   
                 ------
    NULL  ------| node |-----  NULL
      ^  |       ------      |  ^
      |  v                   v  |
 -----------               ------------
| in link 0 |             | out link 0 |
 -----------               ------------
     |^                         |^
     v|                         v|
 -----------               ------------
| in link 1 |             | out link 1 |
 -----------               ------------
     |^                         |^
     v|                         v|
 -----------               ------------
| in link 2 |             | out link 2 |
 -----------               ------------
     |                          |
     v                          v
   NULL                        NULL
@end example

Each link has references of both the source and destination nodes and is
part of two doubly linked lists: one of outgoing links of the source
node, one of incoming links of the destination node.

@example
    ------------------          -----------------
   | prev output link |        | prev input link |
    ------------------          -----------------
                   |^            ^|
                   ||            ||
                   | ---      --- |
                    --- |    | ---
                       ||    ||
                       v|    |v
 -------------       ------------       -----------
| source node |<----|    link    |---->| dest node |
 -------------       ------------       -----------
                       |^    ^|
                       ||    ||
                    --- |    | ---
                   | ---      --- |
                   ||            ||
                   v|            |v
    ------------------          -----------------
   | next output link |        | next input link |
    ------------------          -----------------
@end example

@c ------------------------------------------------------------

@c page
@node graph insert
@subsection Inserting links and nodes


@deftypefun void ucl_graph_link (@var{source_node}, @var{link}, @var{dest_node})
Insert a link between two nodes.  The source and destination node
structures cannot be exchanged: the link is directed.  Arguments:

@table @code
@item ucl_graph_node_t * @var{source_node}
pointer to the source node structure;
@item ucl_graph_link_t * @var{link}
pointer to the link structure;
@item ucl_graph_node_t * @var{dest_node}
pointer to the destination node structure.
@end table
@end deftypefun


Example:

@example
ucl_memory_allocator_t  allocator;
ucl_graph_node_t        *src, *dst;
ucl_graph_link_t *      lnk;

src = dst = lnk = NULL;
allocator.alloc(allocator.data, &src, sizeof(ucl_graph_node_t));
allocator.alloc(allocator.data, &dst, sizeof(ucl_graph_node_t));
allocator.alloc(allocator.data, &lnk, sizeof(ucl_graph_link_t));

ucl_graph_link(src, lnk, dst);
@end example


@deftypefun ucl_bool_t ucl_graph_nodes_are_linked (ucl_graph_node_t * @var{src}, ucl_graph_node_t * @var{dst})
Return true if there is a link between @var{src} and @var{dst}, with
source @var{src} and destination @var{dst}.
@end deftypefun


@deftypefun ucl_bool_t ucl_graph_nodes_are_connected (ucl_graph_node_t * @var{src}, ucl_graph_node_t * @var{dst})
Return true if there is a link between @var{src} and @var{dst}, no
matter what is the direction.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node graph extract
@subsection Extracting links and nodes


@subsubsection Unlinking links


@deftypefun void ucl_graph_unlink (ucl_graph_link_t * @var{link_p})
Remove a link from the graph.  After this function has been called, it is
safe to free the memory of the link.
@end deftypefun

Unlinking example:

@example
ucl_memory_allocator_t  allocator;
ucl_graph_link_t *      link_p;
ucl_value_t             value;

...

link_p = ...;
value  = ucl_graph_get_value(link_p);
/* release 'value' if needed */
allocator.alloc(allocator.data, &link_p, 0);
@end example


@c ------------------------------------------------------------

@subsubsection Erasing a node with loops


@noindent
To erase a node from a graph we have to remove all the links between it
and the other nodes.  To do it:

@example
ucl_memory_allocator_t  allocator;
ucl_graph_node_t *      node_p = ...;
ucl_graph_link_t *      link_p;
ucl_value_t             value;


for (link_p = ucl_graph_output_link(node_p);
     NULL != link_p;
     link_p = ucl_graph_output_link(node_p))
  @{
    ucl_graph_unlink(link_p);
    value = ucl_graph_link_get_value(link_p);
    /* release 'value' if needed */
    allocator.alloc(allocator.data, &link_p, 0);
  @}

for (link_p = ucl_graph_input_link(node_p);
     NULL != link_p;
     link_p = ucl_graph_input_link(node_p))
  @{
    ucl_graph_unlink(link_p);
    value = ucl_graph_link_get_value(link_p);
    /* release 'value' if needed */
    allocator.alloc(allocator.data, &link_p, 0);
  @}

value = ucl_graph_node_get_value(node_p)
/* release 'value' if needed */
allocator.alloc(allocator.data, &node_p, 0);
@end example


@c ------------------------------------------------------------

@subsubsection Erasing a node with loop macros


@noindent
The following two macros do the same loops described above.


@defmac UCL_GRAPH_FIRST_INPUT_LINK_LOOP (@var{node}, @var{link})
Loop over the first input link until it is @null{}.
@end defmac

@defmac UCL_GRAPH_FIRST_OUTPUT_LINK_LOOP (@var{node}, @var{link})
Loop over the first output link until it is @null{}.
@end defmac

With them the extraction code looks like this:

@example
ucl_memory_allocator_t  allocator;
ucl_graph_node_t *      node_p = ...;
ucl_graph_link_t *      link_p;
ucl_value_t             value;

UCL_GRAPH_FIRST_INPUT_LINK_LOOP(node_p, link_p)
  @{
    ucl_graph_unlink(link_p);
    value = ucl_graph_link_get_value(link_p);
    /* release 'value' if needed */
    allocator.alloc(allocator.data, &link_p, 0);
  @}

UCL_GRAPH_FIRST_OUTPUT_LINK_LOOP(node_p, link_p)
  @{
    ucl_graph_unlink(link_p);
    value = ucl_graph_link_get_value(link_p);
    /* release 'value' if needed */
    allocator.alloc(allocator.data, &link_p, 0);
  @}

value = ucl_graph_node_get_value(node_p)
/* release 'value' if needed */
allocator.alloc(allocator.data, &node_p, 0);
@end example


@c ------------------------------------------------------------

@subsubsection Erasing a node with a link destructor


@noindent
If it is fine to release the link structure by invoking a destructor,
the following function does it.

@deftypefun void ucl_graph_erase_node_free_links (@var{node}, @var{destructor})
Erase a node from a graph finalising all the links.

The node structure itself is not finalised: its link fields are set to
@null{}, the value field is left untouched, the structure memory is
not freed.  @var{node} can still be used as argument to
@function{ucl_graph_get_next_node}.

@table @code
@item ucl_graph_node_t * @var{node}
The node to erase.
@item void (* @var{destructor}) (void *)
The destructor function to invoke upon all the links.
@end table
@end deftypefun

With it the erasure code looks like this:

@example
ucl_memory_allocator_t  allocator;
ucl_graph_node_t *      node_p = ...;
ucl_value_t             value;


ucl_graph_erase_node_free_links(node_p, link_destructor);
value = ucl_graph_node_get_value(node_p)
/* release 'value' if needed */
allocator.alloc(allocator.data, &node_p, 0);
@end example

@noindent
and we can implement:

@example
ucl_memory_allocator_t  allocator;

void
link_destructor (void * p)
@{
  ucl_graph_link_t *    link_p = p;
  ucl_value_t           value;

  value = ucl_graph_link_get_value(link_p);
  /* release 'value' if needed */
  allocator.alloc(allocator.data, &link_p, 0);
@}
@end example


@c ------------------------------------------------------------

@subsubsection Erasing a node by collecting links


@noindent
Another function collects the links in a simply linked list and returns
its first node.


@deftypefun {ucl_graph_link_t *} ucl_graph_erase_node_return_links (ucl_graph_node_t * @var{node})
Erase a node from a graph.

The node structure itself is not finalised: its link fields are set to
@null{}, the value field is left untouched, the structure memory is
not freed.  @var{node} can still be used as argument to
@function{ucl_graph_get_next_node}.

All the unlinked links are chained together in a simply linked list that
can be handled later.  A pointer to the first link is returned.
@end deftypefun


With it the erasure code looks like this:

@example
ucl_memory_allocator_t  allocator;
ucl_graph_node_t *      node_p = ...;
ucl_link_t *            link_p;
ucl_link_t *            next_p;
ucl_value_t             value;


link_p = ucl_graph_erase_node_return_links(node_p);
for ((link_p && (next_p = link_p->next_p));
     NULL != link_p;
     (link_p = next_p && next_p = next_p->next_p))
  @{
    allocator.alloc(allocator.data, &link_p, 0);
  @}

value = ucl_graph_node_get_value(node_p)
/* release 'value' if needed */
allocator.alloc(allocator.data, &node_p, 0);
@end example

@c ------------------------------------------------------------

@c page
@node graph merge
@subsection Merging links


@noindent
Merging means to replace two links with one that represents the whole
path; before merging the scenario is:

@example
 --------     ---------     --------     ----------     ------
| source |<--| in link |-->| middle |<--| out link |-->| dest |
|  node  |    ---------    |  node  |    ----------    | node |
 --------                   --------                    ------
@end example

@noindent
merging can be done upon the input or the output link; after merging
upon the input link:

@example
 --------     ---------     ------
| source |<--| in link |-->| dest |
|  node  |    ---------    | node |
 --------                   ------
@end example

@noindent
after merging upon the output link:

@example
 --------     ----------     ------
| source |<--| out link |-->| dest |
|  node  |    ----------    | node |
 --------                    ------
@end example


@deftypefun void ucl_graph_merge_upon_input_link (@var{in}, @var{out})
@deftypefunx void ucl_graph_merge_upon_output_link (@var{in}, @var{out})
Merge two links using @var{in} or @var{out} to replace them.

@table @code
@item ucl_graph_link_t * @var{in}
Pointer to the link incoming to the middle node.
@item ucl_graph_link_t * @var{out}
Pointer to the link outgoing from the middle node.
@end table

Merging is meaningful if @var{in} and @var{out} are connected to the
same node, but these functions do not check for this.

The middle node is excluded from the path: if other links connect the
node to the graph nothing needs to be done, but if merging the links
removes the last links between the node and the graph: the node must be
finalised (free memory, do what is needed with the node's vlaue).
@end deftypefun


Example of merging upon the input link:

@example
ucl_graph_link_t * in  = ...;
ucl_graph_link_t * out = ...;
ucl_value_t        iv, ov, nv;

iv = ucl_graph_link_get_value(in);
ov = ucl_graph_link_get_value(out);
nv.integer = iv.integer + ov.integer;

ucl_graph_merge_upon_input_link (in, out);
ucl_graph_link_set_value(in, nv);

free_memory_of(out);
@end example

@noindent
example of merging upon the output link:

@example
ucl_graph_link_t * in  = ...;
ucl_graph_link_t * out = ...;
ucl_value_t        iv, ov, nv;

iv = ucl_graph_link_get_value(in);
ov = ucl_graph_link_get_value(out);
nv.integer = iv.integer + ov.integer;

ucl_graph_merge_upon_output_link (in, out);
ucl_graph_link_set_value(on, nv);

free_memory_of(in);
@end example


@c page
@node graph node list
@subsection Chaining nodes


@noindent
Nodes can be chained in a simply linked list.  The @code{next_node_p}
field of @code{ucl_graph_node_t} is a pointer that can be used to
reference the ``next node''; if it is @null{} no next node exists.


@subsubsection Setting/getting the next node


@deftypefun void ucl_graph_set_next_node (ucl_graph_node_t * @var{node}, const ucl_graph_node_t * @var{next})
Store @var{next} into the ``next node'' field of @var{node}.  @var{next}
can be @null{} to represent the end of the linked list.
@end deftypefun


@deftypefun {ucl_graph_node_t *} ucl_graph_get_next_node (const ucl_graph_node_t * @var{node})
Return the pointer stored in the ``next node'' field of @var{node}.  The
return value can be @null{} if no next node exists.
@end deftypefun

Example of building the chain:

@example
ucl_memory_allocator_t  allocator;
ucl_graph_node_t        *A, *B, *C;

A = B = C = NULL;
allocator.alloc(allocator.data, &A, sizeof(ucl_graph_node_t));
allocator.alloc(allocator.data, &B, sizeof(ucl_graph_node_t));
allocator.alloc(allocator.data, &C, sizeof(ucl_graph_node_t));

ucl_graph_set_next_node(A, B);
ucl_graph_set_next_node(B, C);
ucl_graph_set_next_node(C, NULL);
@end example

@example
 ---      ---      ---
| A |--->| B |--->| C |---> NULL
 ---      ---      ---
@end example



@subsubsection Insertion and removal


@deftypefun {ucl_graph_node_t *} ucl_graph_remove_next_node (ucl_graph_node_t * @var{node})
Extract the node next to @var{node} and return its pointer.  If, before
the invocation of this function, the scenario is:

@example
 ------          ------          -------
| node |------->| next |------->| other |---> NULL
 ------          ------          -------
@end example

@noindent
after the invocation of this function the scenario is:

@example
 ------          -------
| node |------->| other |---> NULL
 ------          -------

         ------
        | next |
         ------
@end example
@end deftypefun


@deftypefun void ucl_graph_insert_next_node (ucl_graph_node_t * @var{node}, ucl_graph_node_t * @var{next})
Insert @var{next} in the list as next node of @var{node}.  The old next
node becomes the next node of @var{next}.  This function works even when
@var{node} is the last of the list and when @var{next} is @null{}.

If, before the invocation of this function, the scenario is:

@example
 ------      -------
| node |--->| other |---> NULL
 ------      -------

    ------
   | next |
    ------
@end example

@noindent
after the invocation of this function the scenario is:

@example
 ------      ------      -------
| node |--->| next |--->| other |---> NULL
 ------      ------      -------
@end example
@end deftypefun


@subsubsection Iteration


@noindent
Example of iterating over the nodes:

@example
ucl_graph_node_t * first_p = ...;
ucl_graph_node_t * next_p;

for (next_p = first_p;
     NULL != next_p;
     next_p = ucl_graph_get_next_node(next_p))
  @{
    do_something_with(next_p);
  @}
@end example

The following macro implements the @code{for()}.

@defmac UCL_GRAPH_NODE_LIST_LOOP (@var{first}, @var{iter})
Expands into a @code{for()} loop that iterates the list starting at
@var{first} and using @var{iter} as iterator.
@end defmac

With it the iteration becomes:

@example
ucl_graph_node_t * first_p = ...;
ucl_graph_node_t * next_p;

UCL_GRAPH_NODE_LIST_LOOP(first_p, next_p)
  @{
    do_something_with(next_p);
  @}
@end example


@defmac UCL_GRAPH_NODE_LIST_DELETE_LOOP (@var{first}, @var{iter_node}, @var{tmp_node})
Iterates over the list of nodes in a way that allows to delete the
current node from the list.  @var{first} is a pointer to the first node
of the list, @var{iter_node} is the iterator variable, @var{tmp_node} is
a variable used to store a temporary value.
@end defmac

Example of iteration that deletes nodes:

@example
ucl_graph_node_t * first_p = ...;
ucl_graph_node_t * current_p;
ucl_graph_node_t * tmp_p;
ucl_graph_link_t * link_p;

UCL_GRAPH_NODE_LIST_DELETE_LOOP(first_p, current_p, tmp_p)
  @{
    UCL_GRAPH_FIRST_INPUT_LINK_LOOP(current_p, link_p)
      @{
        ucl_graph_unlink(link_p);
        free_memory_of(link_p);
      @}

    UCL_GRAPH_FIRST_OUTPUT_LINK_LOOP(current_p, link_p)
      @{
        ucl_graph_unlink(link_p);
        free_memory_of(link_p);
      @}

      free_memory_of(current_p);
  @}
@end example

@c ------------------------------------------------------------

@c page
@node graph value
@subsection Accessing values


@deftypefun void ucl_graph_node_set_value (ucl_graph_node_t * @var{p}, ucl_value_t @var{newval})
@deftypefunx void ucl_graph_link_set_value (ucl_graph_link_t * @var{p}, ucl_value_t @var{newval})
Store a new value in the structure.
@end deftypefun


@deftypefun ucl_value_t ucl_graph_node_get_value (ucl_graph_node_t * @var{p})
@deftypefunx ucl_value_t ucl_graph_link_get_value (ucl_graph_link_t * @var{p})
Return the current value in the structure.
@end deftypefun


@deftypefun void ucl_graph_node_set_mark (ucl_graph_node_t * @var{p}, ucl_value_t @var{mark})
@deftypefunx ucl_value_t ucl_graph_node_get_mark (ucl_graph_link_t * @var{p})
Set/get the mark value, a field of @code{ucl_value_t} type.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node graph link iter
@subsection Link iterators


@noindent
It is possible to iterate over the lists of incoming and outgoing links
with @code{for()} loops.

@defmac UCL_GRAPH_OUTPUT_LINKS_LOOP (@var{node}, @var{link})
Iterate over the outgoing links of @var{node} using @var{link} as
iterator.
@end defmac

@defmac UCL_GRAPH_INPUT_LINKS_LOOP (@var{node}, @var{link})
Iterate over the incoming links of @var{node} using @var{link} as
iterator.
@end defmac

Example of iteration over outgoing links:

@example
ucl_graph_node_t * node_p = ...;
ucl_graph_link_t * link_p;

UCL_GRAPH_OUTPUT_LINKS_LOOP(node_p, link_p)
  @{
    do_something_with(link_p);
  @}
@end example

@noindent
example of iteration over incoming links:

@example
ucl_graph_node_t * node_p = ...;
ucl_graph_link_t * link_p;

UCL_GRAPH_INPUT_LINKS_LOOP(node_p, link_p)
  @{
    do_something_with(link_p);
  @}
@end example


@subsubsection Finding first and last links


@deftypefun {ucl_graph_link_t *} ucl_graph_input_link (ucl_graph_node_t * @var{node})
@deftypefunx {ucl_graph_link_t *} ucl_graph_output_link (ucl_graph_node_t * @var{node})
Return a pointer to the first incoming or outgoing link of @var{node}.
@end deftypefun


@deftypefun {ucl_graph_link_t *} ucl_graph_last_output_link (ucl_graph_link_t * @var{link})
@deftypefunx {ucl_graph_link_t *} ucl_graph_last_input_link (ucl_graph_link_t * @var{link})
Traverse toward the end the list of incoming or outgoing links, starting
at @var{link}.  Return the last link.
@end deftypefun


@deftypefun {ucl_graph_link_t *} ucl_graph_first_output_link (ucl_graph_link_t * @var{link})
@deftypefunx {ucl_graph_link_t *} ucl_graph_first_input_link (ucl_graph_link_t * @var{link})
Traverse toward the beginning the list of incoming or outgoing links,
starting at @var{link}.  Return the first link.
@end deftypefun



@subsubsection Finding previous and next links


@deftypefun {ucl_graph_link_t *} ucl_graph_prev_input_link (ucl_graph_link_t * @var{link})
@deftypefunx {ucl_graph_link_t *} ucl_graph_prev_output_link (ucl_graph_link_t * @var{link})
Return a pointer to the previous link in the chain.  The return value is
@null{} if @var{link} is the first link.
@end deftypefun

@deftypefun {ucl_graph_link_t *} ucl_graph_next_input_link (ucl_graph_link_t * @var{link})
@deftypefunx {ucl_graph_link_t *} ucl_graph_next_output_link (ucl_graph_link_t * @var{link})
Return a pointer to the next link in the chain.  The return value is
@null{} if @var{link} is the last link.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node graph ops
@subsection Various operations on a graph


@deftypefun size_t ucl_graph_number_of_input_links (ucl_graph_node_t * @var{node})
@deftypefunx size_t ucl_graph_number_of_output_links (ucl_graph_node_t * @var{node})
Return the number of incoming or outgoing links.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node graph dfs
@subsection Depth first search


@noindent
Depth first search (@dfs{}) is an iteration over the nodes of a graph
that starts from a selected node and visits a node only once; the result
of the iteration is a string of nodes.  The iteration is analogous to the
preorder iteration in trees (the worm that always turns right in the
labyrinth).

The iteration may not touch all the nodes:

@itemize
@item
if the graph is not connected: the @dfs{} does not touch all the nodes;

@item
if the @dfs{} follows the direction of the links and there are nodes
with outgoing links only: the @dfs{} does not touch all the nodes.
@end itemize

@ucl{} implements two types of @dfs{}: one that honors the direction of
the links; one that does not.


@c ------------------------------------------------------------

@subsubsection @dfs{} example


@noindent
Given the following connected graph:

@example
 -- A ---> B ---> C
|   |      |
|   |       ------
|   |             |
|   |             v
|    ----> D <--- E
|          ^
v          |
F ---------
@end example

@noindent
we see that we can partition the nodes in two sets:

@example
one = @{ A, F @}  two = @{ B, C, E, D @}
@end example

@noindent
there are no links going from partition @code{two} to partition
@code{one}; the directed @dfs{} starting at node @code{B} is:

@example
B, C, E, D
@end example

@noindent
nodes in partition @code{one} are not touched; while the undirected
@dfs{} starting at node @code{B} is:

@example
B, C, E, D, F, A
@end example

@noindent
all the nodes are touched.

We note that:

@enumerate
@item
if the number of nodes touched by the directed @dfs{} equals the number
of nodes in the graph: the graph is connected;

@item
the iteration goes ``deep'' inside a graph and then steps back in search
of new ramifications;

@item
if every time the iterator does a step we increment a counter: by saving
the values of counter when entering a node and leaving a node, we can
infer properties of the graph.
@end enumerate

@c ------------------------------------------------------------


@subsubsection Programming interface


@noindent
The @dfs{} is implemented as a recursive process that puts touched nodes
on a stack.  The stack is the result of the iteration.  A @dfs{} is not
reentrant because nodes are marked by setting a field in
@code{ucl_graph_node_t} structures: while a @dfs{} is performed the
graph must be locked for mutual exclusion.

Also, do not modify a graph while a @dfs{} is running: the result is
undefined.


@deftp {Struct Typedef} ucl_graph_dfs_t
Type of structure that holds the result of a @dfs{}, both directed and
not.  Public fields:

@table @code
@item ucl_vector_t visited_nodes
handles memory allocation for the nodes touched by the iteration: its
elements are instances of @code{ucl_graph_dfs_item_t}.
@end table
@end deftp


@deftp {Struct Typedef} ucl_graph_dfs_item_t
Represents a node touched by the iteration.  Public fields:

@table @code
@item ucl_graph_node_t * node_p
pointer to the node;
@item size_t in_counter
the value of the counter when the node was entered;
@item size_t out_counter
the value of the counter when the node was left.
@end table

The initial value of the counter is zero; the root node of the @dfs{} is
marked with @code{in_counter = 0}.
@end deftp


@deftypefun void ucl_graph_initialise_dfs_handle (ucl_graph_dfs_t * @var{search_handle})
Initialise an already allocated search handle.
@end deftypefun


@deftypefun void ucl_graph_finalise_dfs_handle (ucl_graph_dfs_t * @var{search_handle})
Finalise a search handle.  All the memory is released.  A @dfs{} must
@strong{always} be finalised with a call to this function.
@end deftypefun


@deftypefun void ucl_graph_directed_depth_first_search (ucl_graph_dfs_t * @var{search_handle}, ucl_graph_node_t * @var{root_p})
Perform a directed @dfs{} over a graph starting from @code{root_p};
store the result into @var{search_handle}.
@end deftypefun


@deftypefun void ucl_graph_depth_first_search (ucl_graph_dfs_t * @var{search_handle}, ucl_graph_node_t * @var{root_p})
Perform a non--directed @dfs{} over a graph starting from @code{root_p};
store the result into @var{search_handle}.
@end deftypefun


Example:

@example
ucl_graph_dfs_t         search_handle;
ucl_iterator_t          iterator;
ucl_graph_dfs_item_t *  item;
ucl_graph_node_t *      root_p = ...;


ucl_graph_initialise_dfs_handle(&search_handle);
@{
  ucl_graph_directed_depth_first_search(&search_handle, root_p);

  for (ucl_vector_iterator_forward(search_handle.visited_nodes, iterator);
       ucl_iterator_more(iterator);
       ucl_iterator_next(iterator))
    @{
      item = ucl_iterator_ptr(iterator);
      do_something_with(item);
    @}
@}
ucl_graph_finalise_dfs_handle(&search_handle);
@end example

@c ------------------------------------------------------------

@c page
@node hash
@section The hash table structure


@cindex Hash table container

@menu
* hash implementation::         How it's done.
* hash creation::               Creating and destroying hash tables.
* hash adding::                 Adding elements to a hash table.
* hash removing::               Removing elements from a hash table.
* hash ops::                    Various operations on a hash table.
* hash resizing::               Resizing a hash table.
* hash iterator::               Visiting elements in the table.
* hash functions::              Provided hash function.
@end menu

@noindent
A hash table is a structure that maps keys to values in a way that
allows the search operation to be performed with constant time for all
the keys.


@deftp {Struct Typedef} ucl_hash_struct_t
The base structure.  The vector of buckets is available as the field
@code{ucl_vector_t buckets}.
@end deftp


@deftp {Single Element Array Typedef} ucl_hash_t
A one--element array of @code{ucl_hash_struct_t}.
@end deftp


@deftp {Struct Typedef} ucl_hash_entry_t
The type of table elements.  Both the key and the value stored in a hash
table entry are of type @code{ucl_value_t} (@ref{typedefs}).
@end deftp


The hash was inspired by the book on C++ by Bjarne Stroustrup and the
hash structure in the @tcl{} (Tool Command Language) source code, by
John Ousterhout and others (@url{http://www.tcl.tk/} for more about
@tcl{}).  However, no code comes from @tcl{}.

@c ------------------------------------------------------------

@c page
@node hash implementation
@subsection How it's done


@noindent
A @ucl{} vector of pointers is allocated by the constructor; each
pointer, called ``bucket'' in this document, can be @null{} (empty
bucket) or referencing an entry structure.  Entry structures are chained
in a linked list.

@example
            buckets

             ----         -----     -----
            |  o-+------>|entry|-->|entry|
            |----|        -----     -----
empty  .....|NULL|
buckets  .  |----|        -----
         .  |  o-+------>|entry|
         .  |----|        -----    -----
         .  |  o-+--------------->|entry|
         .  |----|                 -----
          ..|NULL|
             ----
@end example


The @ucl{} way of managing a vector is to allocate a block of memory,
with hysteresis, and consider a sub--block of it as ``in use'', that is:
as holding the collected data.  When the hash table is constructed all
the slots are marked as used, even when the bucket is set to
@null{}.  Reallocations can cause some of the slots to be unused, but if
we never reallocate the vector all the memory is used to hold buckets.


@c ------------------------------------------------------------

@subsubsection Elements insertion and removal

@noindent
When inserting a new entry in the table, the hash function converts the
keys to integers in the range @code{[0, number_of_buckets)}, selecting a
bucket; then the bucket is examined:

@itemize
@item
if it's @null{}, it's set to the entry pointer:

@example
before the insertion           after the insertion

   ----                           ----
  |    |                         |    |
   ----     -----                 ----     -----
  |NULL|   |entry|               |  o-+-->|entry|
   ----     -----                 ----     -----
  |    |                         |    |
   ----                           ----
@end example

@item
if it's not @null{}, the referenced entry is appended to the new entry
and the bucket is set to a pointer to the new entry:

@example
           ---
 ---   ...|new|               ---
|   | .    ---               |   |
 ---  v  ---     ---          ---     ---     ---     ---
| o-+-->|en1|-->|en2|   ->   | o-+-->|new|-->|en1|-->|en2|
 ---     ---     ---          ---     ---     ---     ---
|   |                        |   |
 ---                          ---
@end example
@end itemize

It's obvious how the extraction operation works.

If the keys are such that the hash function distributes entries
uniformly over all the buckets, the time spent to find an entry is (more
or less) constant.

@c ------------------------------------------------------------

@subsubsection Resizing


@noindent
Enlarging or restricting the hash table means enlarging or restricting
te vector of buckets.  This happens with rules similar, but not equal, to
the ones for the @code{ucl_vector_t} structure; the differences are:

@itemize
@item
when enlarging all the allocated slots are marked as used, so each
allocated slot becomes a bucket;

@item
when restricting the number of used slots is artificially reduced by the
amount of slots selected with the ``step down'' parameter of the @ucl{}
vector;

@item
when restricting the number of used slots cannot become smaller than the
amount selected by the preprocessor symbol @code{UCL_HASH_MINIMUM_SIZE},
which defaults to @code{16}.
@end itemize

Enlarging and restricting changes the number of buckets, so it requires
a rehashing of all the entries in the table: this is expensive.


@c ------------------------------------------------------------

@c page
@node hash creation
@subsection Creating and destroying hash tables


@noindent
The construction of a hash table is split in two steps, to allow custom
configuration of the vector of buckets.  A simple construction, using the
default values, for a table using strings as keys goes like this:

@example
ucl_hash_t      table;
ucl_comparison_t    key_comparison_function = @{
  .data = @{ .ptr = NULL @},
  .func = ucl_strcmp
@};
ucl_comparison_t    key_hash_function       = @{
  .data = @{ .ptr = NULL @},
  .func = ucl_hash_string
@};

ucl_hash_initialise(table, key_comparison_function, key_hash_function);
ucl_hash_constructor(table);
@end example

@noindent
to configure a custom initial size and step up parameter for the vector
of buckets:

@example
ucl_hash_t      table;
ucl_comparison_t    key_comparison_function = @{
  .data = @{ .ptr = NULL @},
  .func = ucl_strcmp
@};
ucl_comparison_t    key_hash_function       = @{
  .data = @{ .ptr = NULL @},
  .func = ucl_hash_string
@};

ucl_hash_initialise(table, key_comparison_function, key_hash_function);
ucl_vector_initialise_size(table->buckets, 256);
ucl_vector_initialise_step_up(table->buckets, 256);
ucl_hash_constructor(table);
@end example

@noindent
the custimisations must go between @function{ucl_hash_initialise} and
@function{ucl_hash_constructor}.


@deftypefun void ucl_hash_initialise (ucl_hash_t @var{self}, ucl_comparison_t @var{keycmp}, ucl_hashcmp_t @var{hash})
Initialise the hash table referenced by @var{self}.  The @ucl{} vector
of buckets is initialised to use the default @ucl{} memory allocator and
with the following preprocessor symbols:

@table @code
@item UCL_HASH_DEFAULT_SIZE
the initial number of buckets, it defaults to @code{16};

@item UCL_HASH_DEFAULT_STEP_UP
the step up parameter, it defaults to @code{16};

@item UCL_HASH_DEFAULT_STEP_DOWN
the step down parameter, it defaults to
@code{((UCL_HASH_DEFAULT_STEP_UP) + 1)};
@end table

@var{keycmp} is the function+context used to compare keys.

@var{hash} is the function+context used to compute the hash value of
keys, @ref{typedefs hash}.
@end deftypefun


@deftypefun void ucl_hash_constructor (ucl_hash_t @var{self})
Build the hash table referenced by @var{self}.

Notice that this function configures the padding area of the vector of
buckets to be of size zero.
@end deftypefun


@deftypefun void ucl_hash_destructor (ucl_hash_t @var{self})
Destroys a hash table.

@strong{Note}: before invoking this function all the entries must be
extracted from the table.
@end deftypefun


Example of destruction, using the standard @function{free} function to
release the memory allocated for the entries:

@example
ucl_hash_t              table;
ucl_hash_entry_t *      entry_p;
ucl_value_t             key, val;

while ((entry_p = ucl_hash_first(table)))
  @{
    ucl_hash_extract(table, entry_p);
    key = ucl_hash_getval(entry_p);
    /* free 'key' if needed */
    val = ucl_hash_getval(entry_p);
    /* free 'val' if needed */
    free(entry_p);
  @}
ucl_hash_destructor(table);
@end example


@c ------------------------------------------------------------

@c page
@node hash adding
@subsection Adding elements to a hash table


@deftypefun void ucl_hash_insert (ucl_hash_t @var{self}, ucl_hash_entry_t * @var{ent_p})
Insert a new entry in the table.  The entry structure must be allocated
and filled with key and value by the user's code.

Inserting an entry with a key that already exists in the table will
work, but future invocations of @function{ucl_hash_find} will return one
or the other: nobody knows which.
@end deftypefun

To avoid collision of keys, we have to check the existence of a key with
@function{ucl_hash_find} before attempting to insert a new entry.

Example:

@example
ucl_memory_allocator_t  allocator;
ucl_hash_t              hash;
ucl_hash_entry_t *      entry_p;
ucl_value_t             key, value;


key = ...
entry_p = ucl_hash_find(hash, key);
if (NULL == entry_p)
  @{
    allocator.alloc(allocator.data, &entry_p, sizeof(ucl_hash_entry_t));
    ucl_hash_setkey(entry_p, key);
    value = ...;
    ucl_hash_setval(entry_p, value);
    ucl_hash_insert(hash, entry_p);
  @}
@end example

@c ------------------------------------------------------------

@c page
@node hash removing
@subsection Removing elements from a hash table



@deftypefun void ucl_hash_extract (ucl_hash_t @var{self}, ucl_hash_entry_t *@var{ent_p})
Extract an entry from the table.  @var{ent_p}, a pointer to the entry to
be removed, must be the return value of a previous invocation to
@function{ucl_hash_find}.  The entry structure is not destroyed nor
freed, just extracted.
@end deftypefun


Example:

@example
ucl_memory_allocator_t  allocator;
ucl_hash_t              hash;
ucl_hash_entry_t *      entry_p;
ucl_value_t             value, key, key1;


hash    = ...;
key     = ...;
entry_p = ucl_hash_find(hash, key);
if (NULL != entry_p)
  @{
    ucl_hash_extract(hash, entry_p);

    key1  = ucl_hash_getkey(entry_p);
    /* destroy key1 if needed */

    value = ucl_hash_getval(entry_p);
    /* destroy value if needed */

    allocator.alloc(allocator.data, &entry_p, 0);
  @}
@end example

@c ------------------------------------------------------------

@c page
@node hash ops
@subsection Various operations on a hash table


@deftypefun {ucl_hash_entry_t *} ucl_hash_find (const ucl_hash_t @var{self}, const ucl_value_t @var{key})
Search in the table an entry associated with the selected key.  Return a
pointer to the entry or @null{} if the key was not found.
@end deftypefun


@deftypefun {ucl_hash_entry_t *} ucl_hash_first (const ucl_hash_t @var{self})
Return a pointer to the first entry in the table: the first link in the
list of the first non--@null{} bucket.  If the has table is empty: return
@null{}.
@end deftypefun


@deftypefun size_t ucl_hash_size (const ucl_hash_t @var{self})
Return a value representing the number of entries in the table.
@end deftypefun


@deftypefun size_t ucl_hash_number_of_buckets (const ucl_hash_t @var{self})
Return the number of buckets.
@end deftypefun


@deftypefun size_t ucl_hash_number_of_used_buckets (const ucl_hash_t @var{self})
Return the number of used buckets.
@end deftypefun


@deftypefun size_t ucl_hash_bucket_chain_length (const ucl_hash_t @var{this}, ucl_index_t @var{position})
Return the number of entries in the chain refereces by bucket at
@var{position}.  @var{position} must be a valid bucket index: a
non--negative integer in the range @code{[0,
ucl_hash_number_of_buckets(@var{this}))}.
@end deftypefun


@deftypefun double ucl_hash_average_search_distance (const ucl_hash_t @var{this})
Return the average number of entries per bucket.
@end deftypefun


@subsubsection Key functions


@deftypefun void ucl_hash_setkey (ucl_hash_entry_t * @var{ent_p}, const ucl_value_t @var{newkey})
Store a new key in an entry structure.  The old key, if present, is
overwritten.
@end deftypefun


@deftypefun ucl_value_t ucl_hash_getkey (const ucl_hash_entry_t *@var{ent_p})
Return the key stored in an entry structure.
@end deftypefun


@subsubsection Value functions


@deftypefun void ucl_hash_setval (ucl_hash_entry_t * @var{ent_p}, const ucl_value_t @var{newval})
Store a new value in an entry structure.  The old value, if present, is
overwritten.
@end deftypefun


@deftypefun ucl_value_t ucl_hash_getval (const ucl_hash_entry_t * @var{ent_p})
Return the value stored in an entry structure.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node hash resizing
@subsection Resizing a hash table


@noindent
At present the hash table is not enlarged automatically.  The decision is
delegated to the user's code.


@deftypefun void ucl_hash_enlarge (ucl_hash_t @var{self})
Enlarge the table using the underlying @ucl{} vector module.  This is an
expensive operation because it requires rehashing all the entries.

If an error occurs reallocating the vector: the table is not corrupted.
@end deftypefun


@deftypefun void ucl_hash_restrict (ucl_hash_t @var{self})
Restrict the table using the underlying @ucl{} vector module.  This is
an expensive operation because it requires rehashing all the entries.

If an error occurs reallocating the vector: the table is not corrupted.
@end deftypefun


@c ------------------------------------------------------------

@c page
@node hash iterator
@subsection Visiting elements in the table


@deftypefun void ucl_hash_iterator (const ucl_hash_t @var{self}, ucl_iterator_t @var{iterator})
Initialise the table iterator.  The iterator pointer references the
entries in the table.  The order in which the entries are visited is
unknown.
@end deftypefun


Example:

@example
ucl_hash_t          hash;
ucl_hash_entry_t *  entry_p;
ucl_value_t         key, val;
ucl_iterator_t      iterator;

hash  = ...;

for (ucl_hash_iterator(hash, iterator);
     ucl_iterator_more(iterator);
     ucl_iterator_next(iterator))
  @{
    entry_p = ucl_iterator_ptr(iterator);
    key     = ucl_hash_getkey(entry_p);
    val     = ucl_hash_getval(entry_p);
    ...
  @}
@end example

@c ------------------------------------------------------------

@c page
@node hash functions
@subsection Provided hash function


@deftypefun size_t ucl_hash_string (const ucl_value_t @var{val})
Return an unsigned integer representing the hash value for the string
in @var{val}.  The @code{str} member of @var{val} must be a pointer to a
@null{}--terminated string of characters.

The hashing algorithm comes from a C++ book by Bjarne Stroustrup
(@ref{references}).
@end deftypefun

@c ------------------------------------------------------------

@c page
@node heap
@section The heap structure


@cindex Heap container

@menu
* heap creation::             Creating and destroying heaps.
* heap adding::               Adding elements to a heaps.
* heap removing::             Removing elements from a heaps.
* heap ops::                  Various operations on a heaps.
@end menu


@noindent
The heap container allows us to insert a bunch of values and extract
them sorted, from the lesser to the greater.  The concepts of ``lesser''
and ``greater'' are established by a user--provided function.

The heap is implemented as a binary tree.  The heap node structure is
compatible with the link structure of the @code{ucl_list_t} container
(@ref{list}), so it's possible to sort a list converting it to a heap
and then rebuilding it, using list links as heap nodes directly.


@deftp {Struct Typedef} ucl_heap_struct_t
The base structure for the heap container.
@end deftp


@deftp {Single Element Array Typedef} ucl_heap_t
A one--element array of @code{ucl_heap_struct_t}.
@end deftp


@deftp {Struct Typedef} ucl_heap_node_t
The type of heap nodes.
@end deftp

@c ------------------------------------------------------------

@c page
@node heap creation
@subsection Creating and destroying heap



@deftypefun void ucl_heap_constructor (ucl_heap_t @var{self}, ucl_comparison_t @var{valcmp})
Initialise the heap structure to represent an empty heap.  @var{self} is
a pointer to an already allocated heap structure, @var{valcmp} is the
function+context used to compare values.
@end deftypefun


@deftypefun void ucl_heap_destructor (ucl_heap_t @var{self})
Reset a heap structure to represent an empty heap.  Before invoking this
function all the nodes must be extracted and freed by the user's code.
@end deftypefun


Example of heap destruction:

@example
ucl_memory_allocator_t  allocator;
ucl_heap_t              heap;
ucl_heap_node_t *       node_p;

...

while (ucl_heap_size(heap))
  @{
    node_p = ucl_heap_extract(heap);
    allocator.alloc(allocator.data, &node_p, 0);
  @}
@end example

@c ------------------------------------------------------------

@c page
@node heap adding
@subsection Adding elements to a heap


@deftypefun void ucl_heap_insert (ucl_heap_t @var{self}, ucl_heap_node_t *@var{node})
Insert a new node in the heap.  @var{node} is a pointer to an already
allocated heap node structure.
@end deftypefun


Example of node insertion:

@example
ucl_memory_allocator_t  allocator;
ucl_heap_t              heap;
ucl_heap_node_t *       node_p = NULL;
ucl_value_t             value;

...

allocator.alloc(allocator.data, &node_p, sizeof(ucl_heap_node_t));
ucl_heap_setval(node_p, value);
ucl_heap_insert(heap, node_p);
@end example

@c ------------------------------------------------------------

@c page
@node heap removing
@subsection Removing elements from a heap


@deftypefun {ucl_heap_node_t *} ucl_heap_extract (ucl_heap_t @var{self})
Extract a node from the heap; return a pointer to it, or @null{} if the
heap is empty.  The extracted node is the one with the smallest value.
@end deftypefun


Example of node extraction:

@example
ucl_memory_allocator_t  allocator;
ucl_heap_t              heap;
ucl_heap_node_t *       node_p;
ucl_value_t             value;

...

node_p = ucl_heap_extract(heap);
value  = ucl_heap_getval(node_p);
allocator.alloc(allocator.data, &node_p, 0);
@end example

@c ------------------------------------------------------------

@c page
@node heap ops
@subsection Various operations on a heap


@deftypefun size_t ucl_heap_size (const ucl_heap_t @var{self})
Return a value of type @code{size_t} representing the number of nodes in
the heap.
@end deftypefun


@deftypefun void ucl_heap_setval (ucl_heap_node_t * @var{node_p}, const ucl_value_t @code{newval})
Store a new value in a heap node.  The old value is overwritten.
@end deftypefun


@deftypefun ucl_value_t ucl_heap_getval (ucl_heap_node_t * @var{node_p})
Return a copy of the value stored in a heap node.
@end deftypefun


@deftypefun void ucl_heap_merge (ucl_heap_t @var{this}, ucl_heap_t @var{other})
Merge two heaps: nodes from @var{other} are extracted and inserted into
@var{this}.  When the function returns @var{other} is empty.
@end deftypefun


@c ------------------------------------------------------------

@c page
@node list
@section The linked list structure


@menu
* list creation::               Creating and destroying lists.
* list adding::                 Adding elements to a list.
* list removing::               Removing elements from a list.
* list ops::                    Various operations on a list.
* list iteration::              Iteration over a list.
@end menu

@noindent
The @ucl{} list container is an implementation of the classic double
linked list: elements are stored in little structures chained together
with pointers that allow the user's code to iterate forward and backward.

@deftp {Struct Typedef} ucl_list_struct_t
The data type of the base structure.  It must be allocated by the user's
code.
@end deftp

@deftp {Single Element Array Typedef} ucl_list_t
One--element array of @code{ucl_list_struct_t}.
@end deftp

@deftp {Struct Typedef} ucl_list_link_t
The data type of the nodes.  Nodes must be allocated and freed by the
user's code.
@end deftp

The handling of  list links is derived from the  handling of elements in
the @acronym{TCL} (Tool Command  Language) hash table by John Ousterhout
and others (@url{http://www.tcl.tk} for more about @acronym{TCL}).


@c page
@node list creation
@subsection Creating and destroying lists


@deftypefun void ucl_list_constructor (ucl_list_t @var{self})
Initialise an already allocated structure to represent an empty list.
@end deftypefun


@deftypefun void ucl_list_destructor (ucl_list_t @var{self})
Reset the structure to represent an empty list.  The structure itself is
not deallocated.  Before calling this the user's code has to make sure
that all the links are extracted from the list.

All the structure fields are reset to zero.  This concept of
``destruction'' is still in development in the head of the author, so it
may change in future releases; it's better, though, to have the code
invoke a destructor, so if things will change we have it in place.  It
may even be replaced by a do--nothing @code{#define}.
@end deftypefun


To extract all the links from a list, we can do:

@example
ucl_list_t              list;
ucl_list_link_t *       link_p;
ucl_value_t             val;

...

link_p = ucl_list_front(list);
while (NULL != link_p)
  @{
    ucl_list_popfront(list);
    val = ucl_list_getval(link_p);

    /* insert here the code to destroy the object */
    /* insert here the code to free the link memory */
  @}
@end example

@noindent
popping elements from the front or from the back makes no difference.

@c ------------------------------------------------------------

@c page
@node list adding
@subsection Adding elements to a list


@deftypefun void ucl_list_insertafter (@var{self}, @var{link_p}, @var{new_p})
Insert the ink referenced by @var{new_p} after the one referenced by
@var{link_p}.  If @var{link_p} is the last in the chain, then @var{new_p}
becomes the last in the chain.

This function can't be used to insert an element in an empty list.

Arguments:

@table @code
@item ucl_list_t @var{self}
pointer to the base structure;

@item ucl_list_link_t *@var{link_p}
pointer to a link in the list, it must be the return value of a previous
invocation of @function{ucl_list_index};

@item ucl_list_link_t *@var{new_p}
pointer to a new list link.
@end table
@end deftypefun


@deftypefun void ucl_list_insertbefore (@var{self}, @var{link_p}, @var{new_p})
Insert the link referenced by @var{new_p} before the one referenced by
@var{link_p}.  If @var{link_p} is the first in the chain, then
@var{new_p} becomes the first in the chain.

This function can't be used to insert an element in an empty list.

Arguments:

@table @code
@item ucl_list_t @var{self}
pointer to the base structure;

@item ucl_list_link_t *@var{link_p}
pointer to a link in the list, it must be the return value of a previous
invocation of @function{ucl_list_index};

@item ucl_list_link_t *@var{new_p}
pointer to a new list link.
@end table
@end deftypefun


@deftypefun void ucl_list_pushfront (ucl_list_t @var{self}, ucl_list_link_t *@var{link_p})
Insert a link at the beginning of the list.  This function can be used to
insert an element in an empty list.
@end deftypefun


@deftypefun void ucl_list_pushback (ucl_list_t @var{self}, ucl_list_link_t *@var{link_p})
Insert a link at the end of the list.  This function can be used to
insert an element in an empty list.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node list removing
@subsection Removing elements from a list


@deftypefun void ucl_list_extract (ucl_list_t @var{self}, ucl_list_link_t * @var{link_p})
Extract the link referenced by @var{link_p}.  @var{link_p} must be the
return value of a previous invocation of @function{ucl_list_index}.
@end deftypefun


Example of element removal:

@example
ucl_list_t        list;
ucl_list_link_t * link_p;
size_t            position;

position = ...

link_p = ucl_list_index(this, position);
if (! link_p)
  @{
    /* handle the error */
  @}
ucl_list_extract(this, link_p);
@end example


@deftypefun void ucl_list_popfront (ucl_list_t @var{self})
Remove an element at the beginning of the list.  This is a wrapper for
@function{ucl_list_extract}.
@end deftypefun


@deftypefun void ucl_list_popback (ucl_list_t @var{self})
Remove an element at the end of the list.  This is a wrapper for
@function{ucl_list_extract}.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node list ops
@subsection Various operations on a list



@deftypefun size_t ucl_list_size (ucl_list_t @var{self})
Return the number of elements in the container.
@end deftypefun


@deftypefun {ucl_list_link_t *} ucl_list_index (ucl_list_t @var{self}, size_t @var{index})
Convers a position in a pointer to the corresponding list link.   Return
a pointer to the selected link, or @null{} if the index is out of range.
@end deftypefun


@deftypefun ucl_value_t ucl_list_getval (ucl_list_link_t * @var{link_p})
Return a value representing the data of a link.
@end deftypefun


@deftypefun void ucl_list_setval (ucl_list_link_t * @var{link_p}, ucl_value_t @var{val})
Store a new value in a link.
@end deftypefun


@deftypefun {ucl_list_link_t *} ucl_list_front (const ucl_list_t @var{self})
Return a pointer to the first link in the list or @null{} if the list is
empty.
@end deftypefun


@deftypefun {ucl_list_link_t *} ucl_list_back (const ucl_list_t @var{self})
Return a pointer to the last link in the list or @null{} if the list is
empty.
@end deftypefun


@deftypefun {ucl_list_link_t *} ucl_list_next (ucl_list_link_t * @var{link_p})
Return a pointer to the link next to @var{link_p} or @null{} if
@var{link_p} is the last in the chain.
@end deftypefun


@deftypefun {ucl_list_link_t *} ucl_list_prev (ucl_list_link_t * @var{link_p})
Return a pointer to the previous link of @var{link_p} or @null{} if
@var{link_p} is the first in the chain.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node list iteration
@subsection Iteration over a list


@noindent
Example of forward iteration:

@example
ucl_list_t        this;
ucl_list_link_t * link_p;
ucl_value_t       val;

...

for (link_p = ucl_list_front(list); link_p; link_p = ucl_list_next(link_p))
  @{
    val = ucl_list_getval(link_p);
    ...
  @}
@end example


Example of backward iteration:

@example
ucl_list_t        this;
ucl_list_link_t *  link_p;
ucl_value_t        val;

...

for (link_p = ucl_list_back(list); link_p; link_p = ucl_list_prev(link_p))
  @{
    val = ucl_list_data(link_p);
    ...
  @}
@end example

@c ------------------------------------------------------------

@c page
@node map
@section The map structure


@cindex Map container

@menu
* map intro::                   Introduction to operations and
                                implementation.
* map creation::                Creating and destroying maps.
* map adding/removing::         Adding and removing elements to a map.
* map accessors::               Accessing values and keys.
* map ops::                     Various operations on a map.
* map iterators::               Iteration over a map.
* set iterators::               Composing map iterators.
@end menu

@noindent
The @code{ucl_map_t} structure can be used to implement an associative
array; it's implemented as an AVL tree.


@deftp {Struct Typedef} ucl_map_struct_t
Base structure for the container.  It must be allocated by the user's
code.
@end deftp

@deftp {Single Element Array Typedef} ucl_map_t
One--element array of @code{ucl_map_struct_t}.
@end deftp

@deftp {Struct Typedef} ucl_map_link_t
The data type of the nodes.  Nodes must be allocated and freed by the
user's code.
@end deftp


The map/multimap idea was inspired by the book on C++ by Bjarne
Stroustrup and by the STL C++ (Standard Template Library) by Stepanov
and Lee.

The handling of nodes is influenced by the handling of elements in the
@acronym{TCL} (Tool Command Language) hash table by John Ousterhout and
others (@url{http://www.tcl.tk/} for more about @acronym{TCL}).


@c page
@node map intro
@subsection Introduction to operations and implementation


@noindent
Maps are often used as associative arrays, that is: as collections of
key/value pairs.  The operations we want to do on a map are:

@itemize
@item
add a key/value pair, if the element already exists replace the old
value with the new one or add a new key/value pair;

@item
find a key/value pair with a specified key;

@item
remove all key/value pairs with a selected key, or the one with a
selected value among the ones having the same key;

@item
traverse the collection of key/value pairs from the lesser key to the
greater;

@item
traverse the collection of key/value pairs from the greater key to the
lesser.
@end itemize

Clearly there are two sub--types of map container: the one that allows
multiple values to be associated to the same key, and the one that
doesn't.  We call the first a @dfn{multimap} and the second a @dfn{simple
map}.

@c ------------------------------------------------------------

@c page
@node map creation
@subsection Creating and destroying maps


@deftypefun void ucl_map_constructor (@var{self}, @var{flags}, @var{keycmp})
Initialise an already allocated map structure.  Arguments:

@table @code
@item ucl_map_t  @var{self}
pointer to the already allocated map structure;

@item unsigned int @var{flags}
map behaviour flags;

@item ucl_comparison_t @var{keycmp}
function+context used to compare keys.
@end table

Map configuration @var{flags} can be zero of an ORed combination of:

@table @code
@item UCL_ALLOW_MULTIPLE_OBJECTS
allows more than one object to be associated to the same key, with this
the map behaves like a multimap.
@end table
@end deftypefun


@deftypefun void ucl_map_destructor (ucl_map_t @var{self})
Destroy a map structure, the structure itself is not deallocated.  The
elements are reset to zero.

Before invoking this function the user's code has to extract all the nodes
from the map.   If the elements are not extracted before this function is
invoked, at least memory leakage will happen.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node map adding/removing
@subsection Adding and removing elements to a map


@deftypefun void ucl_map_insert (ucl_map_t @var{self}, ucl_map_link_t * @var{link_p})
Given an already allocated and constructed map link, insert it in the
map.

An invocation to this function always succeeds if @var{self} references
a multimap, but it can lead to an error if @var{self} is a simple map
and an element with the same key already exists.  If such a condition
occurs, this function @strong{silently does nothing}; it's our
responsibility to use @function{ucl_map_find} to check for the element
existence.
@end deftypefun

Example of link insertion in a simple map:

@example
ucl_memory_allocator_t  allocator;
ucl_map_t               this;
ucl_map_link_t *        link;
ucl_value_t             key;
ucl_value_t             val;

...

key = ...;
val = ...;

link = ucl_map_find(this, key);
if (NULL == link)
  @{
    allocator.alloc(allocator.data, &link, sizeof(ucl_map_link_t));
    ucl_map_setkey(link, key);
    ucl_map_setval(link, val);
    ucl_map_insert(this, link);
  @}
@end example

@noindent
memory handling for the key and the value are full responsibility of the
user's code.


@deftypefun {ucl_map_link_t *} ucl_map_remove (ucl_map_t @var{self}, ucl_map_link_t * @var{link_p})
@deftypefunx {ucl_map_link_t *} ucl_map_extract (ucl_map_t @var{self}, ucl_map_link_t * @var{link_p})
Remove from the map the key/value pair in the element referenced by
@var{link_p}.  This must be the return value of a previous invocation of
@function{ucl_map_find}.  This function only removes the link from the
map: it's our responsibility to free the key, the value and the link
structure itself.

Return a pointer to the extracted link.
@end deftypefun


Example of link removal:

@example
ucl_memory_allocator_t  allocator;
ucl_map_t               this;
ucl_map_link_t *        link;
ucl_value_t             key;
ucl_value_t             val;

...

link = ucl_map_find(this, key);
if (NULL != link)
  @{
    ucl_map_remove(this, link);
    key = ucl_map_getkey(link);
    val = ucl_map_getval(link);
    allocator.alloc(allocator.data, &link, 0);

    /* free "key" and "val" */
  @}
@end example

@c ------------------------------------------------------------

@c page
@node map accessors
@subsection Accessing values and keys


@deftypefun void ucl_map_setkey (ucl_map_link_t * @var{link_p}, ucl_value_t @var{newKey})
Store a key in a link.
@end deftypefun


@deftypefun void ucl_map_setval (ucl_map_link_t * @var{link_p}, ucl_value_t @var{newObj})
Store an value in a link.
@end deftypefun


@deftypefun ucl_value_t ucl_map_getkey (ucl_map_link_t * @var{link_p})
Return the key in a map link. 
@end deftypefun


@deftypefun ucl_value_t ucl_map_getval (ucl_map_link_t * @var{link_p})
Return the value in a map link. 
@end deftypefun

@c ------------------------------------------------------------

@c page
@node map ops
@subsection Various operations on a map


@deftypefun size_t ucl_map_count (const ucl_map_t @var{self}, const ucl_value_t @var{key})
Return the number of elements with @var{key}; this is always 0 or 1 for
simple maps.
@end deftypefun


@deftypefun {ucl_map_link_t *} ucl_map_find (const ucl_map_t @var{self}, const ucl_value_t @var{key});
Return a pointer to the (first found) element associated with
@var{key}.  The return value is @null{} if such an element doesn't
exist.

For a multimap, this function returns a pointer to the first element
with the selected key, so that the others can be found with repeated
invocations of @function{ucl_map_next}.
@end deftypefun


@deftypefun {ucl_map_link_t *} ucl_map_first (const ucl_map_t @var{self})
Return a pointer to the element with lesser key in the map, or
@null{} if the map is empty.
@end deftypefun


@deftypefun {ucl_map_link_t *} ucl_map_last (const ucl_map_t @var{self})
Return a pointer to the element with greater key in the map, or
@null{} if the map is empty.
@end deftypefun


@deftypefun {ucl_map_link_t *} ucl_map_next (const ucl_map_link_t * @var{link_p})
Return a pointer to the element adjacent to the one referenced by
@var{link_p} with greater key, or @null{} if @var{link_p} has the
greater key in the map.
@end deftypefun


@deftypefun {ucl_map_link_t *} ucl_map_prev (const ucl_map_link_t * @var{link_p})
Return a pointer to the element adjacent to the one referenced by
@var{link_p} with lesser key, or @null{} if @var{link_p} has the
lesser key in the map.
@end deftypefun


@deftypefun {ucl_map_link_t *} ucl_map_find_or_next (const ucl_map_t @var{self}, const ucl_value_t @var{key})
Given a key find the element in the map associated with it, or the
element with the lesser key greater than the selected one.  Return a
pointer to the requested link or @null{} if all the keys in the map
are lesser than the selected one.
@end deftypefun


@deftypefun {ucl_map_link_t *} ucl_map_find_or_prev (const ucl_map_t @var{self}, const ucl_value_t @var{key})
Given a key find the element in the map associated with it, or the
element with the greater key lesser than the selected one.  Return a
pointer to the requested link or @null{} if all the keys in the map
are greater than the selected one.
@end deftypefun


@deftypefun size_t ucl_map_size (const ucl_map_t @var{self})
Return the number of elements in the map.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node map iterators
@subsection Iteration over a map


@noindent
For the map, the iteration is over the map links:
@function{ucl_iterator_ptr} returns a pointer to the current map link.
We can use the @function{ucl_map_getkey} and @function{ucl_map_setkey}
to acquire the keys and values.


@deftypefun void ucl_map_iterator_inorder (const ucl_map_t @var{self}, ucl_iterator_t @var{iterator})
@deftypefunx void ucl_map_iterator_preorder (const ucl_map_t @var{self}, ucl_iterator_t @var{iterator})
@deftypefunx void ucl_map_iterator_postorder (const ucl_map_t @var{self}, ucl_iterator_t @var{iterator})
@deftypefunx void ucl_map_iterator_levelorder (const ucl_map_t @var{self}, ucl_iterator_t @var{iterator})
Initalise an inorder, preorder, postorder or levelorder
iteration.  @ref{btree iteration}, for details.
@end deftypefun


@deftypefun void ucl_map_lower_bound (const ucl_map_t @var{self}, ucl_iterator_t @var{iterator}, ucl_value_t @var{key})
Initialise an iteration over the elements with the selected key,
starting with the first element.
@end deftypefun


@deftypefun void ucl_map_upper_bound (const ucl_map_t @var{self}, ucl_iterator_t @var{iterator}, ucl_value_t @var{key})
Initialise an iteration over the elements with the selected key,
starting with the last element.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node set iterators
@subsection Composing map iterators


@cindex Set iterators


@noindent
It's possible to compose map iterators to implement set operations: the
keys from a map are used as set elements, the values are not
considered.  A set operation is implemented as an iterator that visits
one by one the result of the operation itself.

The key values must be of the same data type.  That means that the
compare function used by both the maps, must accept the same type of
values and return the same values when called with the same arguments.

For all the set iterators, the arguments are:

@table @code
@item ucl_iterator_t  @var{it1}
pointer to an in--order iterator over set 1, already initialised;

@item ucl_iterator_t  @var{it2}
pointer to an in--order iterator over set 2, already initialised;

@item ucl_iterator_t  @var{iter}
pointer to the set iterator structure.
@end table

The input map iterators must be of in--order type: if the sequences are
visited from the lesser to the greater key, the minimum amount of key
comparison is performed.

If the sequences are not visited with the in--order iterator, the result
is not defined.

The set iterators are used in the same fashion of all the other
iterators in the @acronym{UCL} (@ref{iterators}).  The value retrieved
with @function{ucl_iterator_ptr} is the pointer to the referenced map
link.


@deftypefun void ucl_map_iterator_union (@var{it1}, @var{it2}, @var{iter})
Initialise the iteration over all the elements from both the
sequences.  Elements present in both sequences are included twice.
@end deftypefun


@deftypefun void ucl_map_iterator_intersection (@var{it1}, @var{it2}, @var{iter})
Initialise  the iteration  over all  the elements  present in  both the
sequences.  Elements included in only one sequence are discarded.
@end deftypefun


@deftypefun void ucl_map_iterator_complintersect (@var{it1}, @var{it2}, @var{iter})
Initialise the iteration over all the elements present in only one of
the two sequences.
@end deftypefun


@deftypefun void ucl_map_iterator_subtraction (@var{it1}, @var{it2}, @var{iter})
Initialise the iteration over all the elements from sequence 1 that are
not present in sequence 2.
@end deftypefun


Example:

@example
Sequence 1: 0 1 2 3 4 5 6
Sequence 2: 4 5 6 7 8 9
Union: 0 1 2 3 4 4 5 5 6 6 7 8 9
Intersection: 4 5 6
Complementary intersection: 0 1 2 3 7 8 9
Subtraction: 0 1 2 3
@end example


@c page
@node tree
@section The tree structure


@menu
* tree implementation::         How it's done.
* tree creation::               Creating tree nodes.
* tree testing::                Testing relationships between nodes.
* tree relatives::              Accessing or setting the relatives of
                                a node.
* tree adding::                 Adding elements to a tree.
* tree removing::               Removing elements from a tree.
* tree iterators::              Traversing a tree.
@end menu


@noindent
The tree container is basically different from the others in the @ucl{}.
There is no ``base struct'', like @code{ucl_list_t} and
@code{ucl_map_t}, that holds fundamental data and that can be used to
``keep a grab'' on the structure itself.

Instead, the tree is just a collection of nodes linked together, and we
control the struct keeping a pointer to one of the nodes.   Which one
doesn't matter.  Nothing prevents us from storing somewhere a pointer to
the ``root node'', but this is not required.

At any time we must take care of holding a pointer to at least one tree
node; if we loose it, we will not be able to free the struct.  Keeping
two or more references to nodes is possible but dangerous: if we delete
a subtree we may end up with a pointer to a memory block already freed.

The referenced node is called ``current''.  To handle the tree we use a
``walking'' pattern.  We can add/remove nodes relative to the ``current'' and
move step by step from the ``current'' to adjacent nodes.

Care must be taken to distinguish between the node's classification from
the ``logic'' point of view and the ``implementation'' point of view.  A
tree is implemented with a binary tree.  Here we talk about the logic
point of view; so: the ``dad'' of a node is the uplevel node in the
hierarchy, the ``brother'' of a node is in the same level of the
``current'' node.


@deftp {Struct Typedef} ucl_tree_node_t
The type of the tree nodes.
@end deftp


@c page
@node tree implementation
@subsection How it's done


@noindent
The implementation is a binary tree in which: the son of the node A is
the first child of the node A, the brother of the child is the second
son of the node A, and so on.

@example
   -----
  | dad |
   -----
    ^ |son
dad | v
   -----  bro   -----  bro   -----  bro   -----  bro
  | 1st |----->| 2nd |----->| 3rd |----->| 4th |----->NULL
   -----        -----        -----        -----
    |            |
    v son        v son
   -----        -----
  | nep |      |     |
   -----        -----
@end example

Pointers condition meaning:

@table @code
@item node.bro_p == NULL
the node has no brothers, so it's the last brother between the children
of its father;

@item node.son_p == NULL
the node has no children;

@item node.dad_p == NULL
the node is the root node of a tree;

@item A.dad_p == B && B.son_p == A
A is the first between the children of node B;

@item A.dad_p == B && B.bro_p == A 
A and B are brothers, and children of the same parent node.
@end table


@c page
@node tree creation
@subsection Creating tree nodes


@noindent
The tree node structures must be allocated by the user's code, none of
the @acronym{UCL} tree methods will invoke memory allocation/release
functions.


@deftypefun void ucl_tree_constructor (ucl_tree_node_t * @var{nod_p})
A wrapper for @function{ucl_struct_clean}.  Initialise to zero all the
members of the structure referenced by @var{nod_p}.  This is recommended
before inserting a node into a tree.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node tree testing
@subsection Testing relationships between nodes


@deftypefun ucl_bool_t ucl_tree_is_dad (const ucl_tree_node_t * @var{dad_p}, const ucl_tree_node_t * @var{cld_p})
Return true if the node referenced by @var{dad_p} is the father of the
node referenced by @var{cld_p}, otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_is_bro (const ucl_tree_node_t * @var{nod_p}, const ucl_tree_node_t * @var{bro_p})
Return true if the node referenced by @var{nod_p} is a brother of the
node referenced by @var{bro_p}, otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_has_dad (const ucl_tree_node_t * @var{self})
Return true if the node referenced by @var{self} has a parent,
otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_has_prev (const ucl_tree_node_t * @var{self})
Return true if the node referenced by @var{self} has a brother to the
left, otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_has_next (const ucl_tree_node_t * @var{self})
Return true if the node referenced by @var{self} has a brother to the
right, otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_has_son (const ucl_tree_node_t * @var{self})
Return true if the node referenced by @var{self} has a son, otherwise
return false.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node tree relatives
@subsection Accessing or setting the relatives of a node


@deftypefun {ucl_tree_node_t *} ucl_tree_get_dad (const ucl_tree_node_t * @var{self})
Return a pointer to the father of the node referenced by @var{self}; if
the node has no parent: return @null{}.
@end deftypefun


@deftypefun {ucl_tree_node_t *} ucl_tree_get_prev (const ucl_tree_node_t * @var{self})
Return a pointer to the left brother of the node referenced by
@var{self}; if the node has no left brother: return @null{}.
@end deftypefun


@deftypefun {ucl_tree_node_t *} ucl_tree_get_next (const ucl_tree_node_t * @var{self})
Return a pointer to the right brother of the node referenced by
@var{self}; if the node has no right brother: return @null{}.
@end deftypefun


@deftypefun {ucl_tree_node_t *} ucl_tree_get_son (const ucl_tree_node_t * @var{self})
Return a pointer to the son of the node referenced by @var{self}; if the
node has no child: return @null{}.
@end deftypefun


@deftypefun {ucl_tree_node_t *} ucl_tree_get_first (const ucl_tree_node_t * @var{self})
Return a pointer to the first between the brothers of the node
referenced by @var{self}; it can be a pointer to @var{self} itself, if
@var{self} is the first.
@end deftypefun


@deftypefun {ucl_tree_node_t *} ucl_tree_get_last (const ucl_tree_node_t * @var{self})
Return a pointer to the last between the brothers of the node
referenced by @var{self}; it can be a pointer to @var{self} itself, if
@var{self} is the last.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node tree adding
@subsection Adding elements to a tree


@noindent
The @code{ucl_tree_set_*()} functions are used to append a new subtree
to a tree.


@deftypefun void ucl_tree_set_son (ucl_tree_node_t * @var{nod_p}, ucl_tree_node_t * @var{son_p})
Link together the nodes referenced by @var{nod_p} and @var{son_p} so
that one is the son of the other.  The old reference to the son of
@var{nod_p} is lost; the old reference to the dad of @var{son_p} is
lost.
@end deftypefun


@deftypefun void ucl_tree_set_bro (ucl_tree_node_t * @var{nod_p}, ucl_tree_node_t * @var{bro_p})
Link together the nodes referenced by @var{nod_p} and @var{bro_p} so
that one is the brother of the other.  The node referenced by @var{bro_p}
becomes the right brother of the node referenced by @var{nod_p}.  The old
references to the brothers of the two nodes are lost.
@end deftypefun


The following functions are used to insert subtrees in a tree.  None of
the nodes in the target tree are detached.  The links in the new subtrees
that are not interested by the relations in these functions, are left
untouched.


@deftypefun void ucl_tree_insert_dad (ucl_tree_node_t * @var{nod_p}, ucl_tree_node_t * @var{dad_p})
Inserts a new dad for a node.  The dad node becomes the father of the
node and the first son of the old dad (if any).

@example	
 ---       ---
| A |     | A |
 ---       ---
  |         |
 ---       ---
|nod| ->  |dad|
 ---       ---
            |
           ---
          |nod|
           ---
@end example
@end deftypefun


Example of dad insertion:

@example
ucl_tree_insert_dad( 1, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   A--C
|  |            |         |
5  6            B         1--2--3--4
                          |  |
                          5  6
@end example

@noindent
the @code{D} and @code{B} nodes are detached and will be lost if we
don't keep a reference to them.


@deftypefun void ucl_tree_insert_son (ucl_tree_node_t * @var{nod_p}, ucl_tree_node_t * @var{son_p})
Insert a new child for a node.  The node referenced by @var{son_p}
becomes the last between the children of the node referenced by
@var{nod_p}.

@example
 ---         ---
|nod|       |nod|
 ---         ---
  |     ->    |
 ---         ---     ---
| A |       | A |-->|son|
 ---         ---     ---
@end example
@end deftypefun


Example of son insertion:

@example
ucl_tree_insert_son( 0, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   1--2--3--4--A--C
|  |            |         |  |        |
5  6            B         5  6        B
@end example

@noindent
the node @code{D} is detached and will be lost if we don't keep a
reference to it.


@deftypefun void ucl_tree_insert_prev (ucl_tree_node_t * @var{nod_p}, ucl_tree_node_t * @var{bro_p})
Insert a new brother for a node.  The node referenced by @var{bro_p}
becomes the left brother of the node referenced by @var{nod_p}.

@example
 ---    ---          ---    ---    ---
| A |--|nod|   ->   | A |--|bro|--|nod|
 ---    ---          ---    ---    ---
@end example
@end deftypefun


Example of prev node insertion:

@example
ucl_tree_insert_prev( 2, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   1--A--2--3--4
|  |            |         |  |  |
5  6            B         5  B  6
@end example

@noindent
the @code{D} and @code{C} nodes are detached and will be lost if we
don't keep a reference to them.


@deftypefun void ucl_tree_insert_next (ucl_tree_node_t * @var{nod_p}, ucl_tree_node_t * @var{bro_p})
Insert a new brother for a node.  The node referenced by @var{bro_p}
becomes the right brother of the node referenced by @var{nod_p}.

@example
 ---    ---          ---    ---    ---
|nod|--| A |   ->   |nod|--|bro|--| A |
 ---    ---          ---    ---    ---
@end example
@end deftypefun


Example of next brother insertion:

@example
ucl_tree_insert_next( 2, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   1--2--A--3--4
|  |            |         |  |
5  6            B         5  6
@end example

@noindent
the @code{D}, @code{B} and @code{C} nodes are detached and will be lost
if we don't keep a reference to them.

@c ------------------------------------------------------------

@c page
@node tree removing
@subsection Removing elements from a tree


@noindent
These functions will extract a node from a tree, returning a pointer to
the extracted node.


@deftypefun {ucl_tree_node_t *} ucl_tree_extract_dad (ucl_tree_node_t * @var{nod_p})
Extract the dad of the node referenced by @var{nod_p} from the tree.
The referenced node and all its brothers are inserted in place of the
extracted dad.

Returns a pointer to the extracted node, or @null{} if the selected node
has nod dad.  All the pointers in the extracted node structure are reset
to @null{}.

@example
 ---    ---    ---       ---    ---    ---    ---
| A |--|dad|--| B |     | A |--|nod|--| C |--| B |
 ---    ---    ---       ---    ---    ---    ---
         |          ->
        ---    ---              ---
       |nod|--| C |            |dad|
        ---    ---              ---
@end example
@end deftypefun


@deftypefun {ucl_tree_node_t *} ucl_tree_extract_son (ucl_tree_node_t * @var{nod_p})
Extract the son of the node referenced by @var{nod_p} from the tree.
The son of the selected node is extracted from the hierarchy.  All of its
children become children of the selected node.

Return a pointer to the extracted node or @null{} if the selected node
has no son.  All the pointers in the extracted node structure are reset
to @null{}.

@example
 ---               ---
|nod|             |nod|
 ---               ---
  |                 |
 ---    ---        ---    ---    ---
|son|--| C |  ->  | A |--| B |--| C |
 ---    ---        ---    ---    ---
  |
 ---    ---            ---
| A |--| B |          |son|
 ---    ---            ---
@end example
@end deftypefun


@deftypefun {ucl_tree_node_t *} ucl_tree_extract_prev (ucl_tree_node_t * @var{nod_p})
Extract the left brother of the node referenced by @var{nod_p}.  The
left brother of the selected node is extracted from the hierarchy.  Its
children become left brothers of the selected node.

Return a pointer to the extracted node, or @null{} if the selected node
has no left brother.   All the pointers in the extracted node structure
are reset to @null{}.

@example
 ---               ---
| A |             | A |
 ---               ---
  |                 |
 ---    ---        ---    ---
|prv|--|nod|  ->  | B |--|nod|
 ---    ---        ---    ---
  |
 ---                   ---
| B |                 |prv|
 ---                   ---
@end example
@end deftypefun


@deftypefun {ucl_tree_node_t *} ucl_tree_extract_next (ucl_tree_node_t * @var{nod_p})
Extract the right brother of the node referenced by @var{nod_p}.   The
right brother of the selected node is extracted from the hierarchy.  Its
children become right brothers of the selected node.

Return a pointer to the extracted node, or @null{} if the selected node
has no right brother.   All the pointers in the extracted node structure
are reset to @null{}.

@example
 ---    ---    ---       ---    ---    ---
|nod|--|nxt|--| A |     |nod|--| B |--| A |
 ---    ---    ---       ---    ---    ---
         |           ->
        ---                 ---
       | B |               |nxt|
        ---                 ---
@end example
@end deftypefun

@c ------------------------------------------------------------

@c page
@node tree iterators
@subsection Traversing a tree


@noindent
For the tree iterators, the return value of @function{ucl_iterator_ptr}
is a pointer to the current node.


@deftypefun void ucl_tree_iterator_inorder (ucl_tree_node_t *@var{nod_p}, ucl_iterator_t @var{iter})
Initialises an in--order iteration.
@end deftypefun


@deftypefun void ucl_tree_iterator_preorder (ucl_tree_node_t *@var{nod_p}, ucl_iterator_t @var{iter})
Initialises a pre--order iteration.
@end deftypefun


@deftypefun void ucl_tree_iterator_postorder (ucl_tree_node_t *@var{nod_p}, ucl_iterator_t @var{iter})
Initialises a post--order iteration.
@end deftypefun


@c page
@node vector
@section The vector structure

@cindex Vector container

@menu
* vector implementation::       How it's done.
* vector fields::               Fields and default configuration
                                for vectors.
* vector creation::             Creating and destroying vectors.
* vector indexes::              Converting indexes to pointers.
* vector adding::               Adding elements to a vector.
* vector removing::             Removing elements from a vector.
* vector ops::                  Various operations on a vector.
* vector find::                 Finding elements.
* vector iteration::            Iteration over a vector.
* vector memory::               Allocating and freeing memory.
* vector as pqueue::            Using a vector as a priority queue.
* vector high::                 High level functions.
@end menu

@noindent
The @ucl{} vector container is an implementation of array, with
hysteresis in memory allocation.  This module was inspired by the book
on C++ by Bjarne Stroustrup and by the @acronym{STL} C++ (Standard
Template Library).

This container is heavyweight: its complexity is overkill for simple
arrays with fixed size.

In the following documentation, when describing valid values for vector
indexes, we denote a range of values with @code{[min, max)}, where
@code{[} means inclusive bound and @code{(} means exclusive bound.


@deftp {Struct Typedef} ucl_vector_struct_t
The data type of the base structure.  It must be allocated by the user
code.
@end deftp

@deftp {Single Element Array Typedef} ucl_vector_t
A one--element array of @code{ucl_vector_struct_t}.
@end deftp

@deftp {Struct Typedef} ucl_vector_array_t
Holds an array of vectors.  Public slots:

@table @code
@item size_t number_of_vectors
the number of vectors in the array;

@item ucl_vector_struct_t ** vectors
array of pointers to vectors; this type implies no assumption upon the
origin of the array memory, it can be statically or dynamically
allocated, or it can be on the stack.
@end table

To declare an array of vectors we can do:

@example
ucl_vector_struct_t * vectors[NUMBER];
ucl_vector_array_t    array = @{
  .number_of_vectors = NUMBER,
  .vectors           = vectors
@};
@end example
@end deftp

@c ------------------------------------------------------------

@c page
@node vector implementation
@subsection How it's done


@noindent
The vector structure can be allocated anywhere; the array is always
dynamically allocated and it is described by four pointers:
@code{first_allocated_slot}, @code{first_used_slot},
@code{last_used_slot}, @code{last_allocated_slot}.  All the pointers are
of byte type (usually @code{unsigned char}).

A "slot" is a section of the allocated memory that can hold an element;
the dimension of the slots is configured at initialisation time.  A "free
slot" is a slot that does not contain an element; free slots can be
present at the beginning and end of the allocated memory.  A "used slot"
is a slot that holds an element; used slots are always contiguous in the
allocated memory.


@subsubsection Pointer usage charts

@noindent
Pointers when some slot is used:

@example
 free     used slots           free
|'''''|.................|''''''''''''''''''''|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
^     ^              ^                    ^
|     |              |                    last_allocated_slot
|     |              |
|     |              last_used_slot
|     |
|     first_used_slot
|
first_allocated_slot
@end example


@noindent
pointers when the used area is attached to the beginning of the
allocated memory:

@example
      used slots           free
|.................|''''''''''''''''''''''''''|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
^              ^                          ^
|              |                          last_allocated_slot
|              |
|              last_used_slot
|
first_allocated_slot == first_used_slot
@end example


@noindent
pointers when the used area is attached to the end of the allocated
memory:

@example
   free slots           used slots
|''''''''''''''|.............................|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
^              ^                          ^
|              |         last_allocated_slot == last_used_slot
|              |
|              first_used_slot
|
first_allocated_slot
@end example


@noindent
pointers when the allocated memory is full:

@example
                 used slots
|............................................|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
^                                         ^
|                        last_allocated_slot == last_used_slot
|              
|              
|
first_allocated_slot == first_used_slot
@end example


@noindent
pointers when only one slot is used:

@example
      used
 free slot              free
|'''''|..|'''''''''''''''''''''''''''''''''''|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
^     ^                                   ^
|     |                                   last_allocated_slot
|     |
|     first_used_slot == last_used_slot
|
first_allocated_slot
@end example


@noindent
pointers when the vector is empty and a non-zero pad area was
configured:

@example
  free pad           free slots
  area
|'''''''''''|''''''''''''''''''''''''''''''''|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
^        ^  ^                             ^
|        |  |                             last_allocated_slot
|        |  first_used_slot
|        |
|        last_used_slot
|
first_allocated_slot
@end example

@noindent
pointers when the vector is empty and a zero pad area was configured:

@example
   |''''''''''''''''''''''''''''''''''''''''''''|
|__|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
^  ^                                         ^
|  |                                         last_allocated_slot
|  |
|  first_allocated_slot == first_used_slot
|
last_used_slot
@end example


@subsubsection Pointers usage rules


@itemize
@item
@code{first_allocated_slot} references the first byte/slot of the
allocated memory; its value is modified only when the memory is
reallocated.

It represents the mimimum allowed value of @code{first_used_slot}; when
the two are equal: it means that the used area is attached to the
beginning of the allocated block.

@item
@code{last_allocated_slot} references the last slot of the allocated
memory (not the last byte, unless the size of the slot is one); its
value is modified only when the memory is reallocated and is always:

@example
last_allocated_slot =
    first_allocated_slot + slot_dimension * allocated_slot_number
@end example

It represents the maximum allowed value for @code{last_used_slot}; when
the two are equal: it means that the used area is attached to the end of
the allocated block.

@item
When some slot is used: @code{first_used_slot} references the first slot
that holds data and it can be casted to the type of contained elements,
to reference the first element in the array.

When the vector is empty: @code{first_used_slot} references the first
byte after a (dynamic and configurable) padding area; if the size of the
padding area is zero: its value is equal to @code{first_allocated_slot}.

@code{first_used_slot} can be accessed to start a forward iteration over
all the elements in the array.

@item
When the array is used: @code{last_used_slot} references the first byte
of the last used slot.

When the array is empty: @code{last_used_slot} has the value of
@code{first_used_slot} minus the slot dimension.

@code{last_used_slot} can be accessed to start a backward iteration over
all the elements in the array.

@item
When some slot is used, it is always:

@example
first_used_slot <= last_used_slot
@end example

@noindent
the two are equal when only one slot is used; it must always be:

@example
number_of_used_slots * slot_dimension =
     last_used_slot - first_used_slot + slot_dimension
@end example

@item
When no slots are used, it is always:

@example
first_used_slot == last_used_slot + slot_dimension
@end example

@noindent
and @code{first_used_slot} is set to reference the beginning of the
padding area.  We use this definition of empty vector so that it is
possible to iterate with:

@example
ucl_byte_t *   p;

for (p =  vector->first_used_slot;
     p <= vector->last_used_slot;
     p += vector->slot_dimension) @{ ... @}

for (p =  vector->last_used_slot;
     p >= vector->first_used_slot;
     p -= vector->slot_dimension) @{ ... @}
@end example
@end itemize

The padding area, whose starting size can be configured, has the purpose
of allowing fast insertion of elements at the beginning, with no
reallocation of the memory block.

@c ------------------------------------------------------------

@c page
@node vector fields
@subsection Fields and configuration for vectors


@noindent
The public fields in the @code{ucl_vector_t} structure are:

@table @code
@item size_t size
it has two manings, depending on the vector's situation:

@table @emph
@item at initialisation
the number of slots to allocate for the new vector, it must be a
non--null positive integer;
@item in the lifetime of the vector
the number of elements in the container;
@end table

@item size_t step_up
the number of slots to add when reallocating the array to enlarge it, it
must be a non--zero positive integer;

@item size_t step_down
the number of free slots that will trigger the reallocation of he array
for restriction, it must be a non--zero positive integer;

@item size_t pad
the numer of slots to keep free, if possible, at the beginning of the
array when moving elements (during insertion, removal and reallocation),
it must be a positive or null integer; at initialisation it must be
lesser than @code{size};

@item size_t dim
the size, in bytes, of the elements that the vector will hold, this
should be the result of the @code{sizeof()} operator applied to the data
type;

@item ucl_comparison_t compar
function+context used to compare elements; this function is used only by
the sort operations, so this field can be left blank if no sort
operations are required.
@end table

@noindent
@ref{vector memory} for deatils on (re)allocation.


The following are the default values: a set of preprocessor symbols
declared in @file{ucl.h}, they are set at initialisation time and can be
overridden before constructing the vector.

@defmac UCL_VECTOR_DEFAULT_SIZE
Default value for the @code{size} structure field.  Value: 16.
@end defmac


@defmac UCL_VECTOR_DEFAULT_STEP_UP
Default value for the @code{step_up} structure field.  Value: 8.
@end defmac


@defmac UCL_VECTOR_DEFAULT_STEP_DOWN
Default value for the @code{step_down} structure field.  Value: 10.
@end defmac


@defmac UCL_VECTOR_DEFAULT_PAD
Default value for the @code{pad} structure field.  Value: 3.
@end defmac

The declaration allows overriding, for example:

@example
#ifndef UCL_VECTOR_DEFAULT_SIZE
#  define UCL_VECTOR_DEFAULT_SIZE       16
#endif
@end example

@c page
@node vector creation
@subsection Creating and destroying vectors


@noindent
The construction of a new vector is a three step sequence: declaration,
initialisation, allocation:

@example
ucl_vector_t V;

ucl_vector_initialise(V, sizeof(int));
ucl_vector_initialise_size(V, 100);
ucl_vector_constructor(V);
@end example


@subsubsection Initialisation functions

@deftypefun void ucl_vector_initialise (ucl_vector_t @var{self}, size_t @var{dim})
Initialise the members of the structure with the default values.  After
the invocation to this function, the user's code may override the default
values by explicitly setting them before invoking the constructor.

@var{dim} is the dimension of the elements that will be stored in the
array.
@end deftypefun


@deftypefun void ucl_vector_initialise_size (ucl_vector_t @var{self}, size_t @var{size})
Initialise the requested size of the vector.
@end deftypefun

@deftypefun void ucl_vector_initialise_pad (ucl_vector_t @var{self}, size_t @var{pad})
Initialise the requested size of the padding area, in slot size units.
@end deftypefun

@deftypefun void ucl_vector_initialise_step_up (ucl_vector_t @var{self}, size_t @var{step_up})
Initialise the requested size of the step up value, in slot size units.
@end deftypefun

@deftypefun void ucl_vector_initialise_step_down (ucl_vector_t @var{self}, size_t @var{step_down})
Initialise the requested size of the step down value, in slot size
units.
@end deftypefun


@subsubsection Construction and destruction functions

@deftypefun void ucl_vector_constructor (ucl_vector_t @var{self})
Allocate memory with the current @ucl{} allocator and initialise the
fields of @var{self}.

If the @code{step_up} field holds a value greater than the
@code{step_down} field: the @code{step_down} field is changed to
@code{step_up+1}.  @ref{vector memory} for details.
@end deftypefun


@deftypefun void ucl_vector_destructor (ucl_vector_t @var{self})
Destroy the structure pointed by @var{self}, only if it has been built
(it is safe to call this function on an already destroyed vector).  The
structure itself is not deallocated.  Any block of dynamically allocated
memory is freed.   All the structure fields are reset to zero.

If the contained values need some sort of destruction, it is
responsibility of the user's code to extract them before invoking this
function.
@end deftypefun

@deftypefun ucl_bool_t ucl_vector_running (const ucl_vector_t @var{self})
Return true if the vector has been constructed.
@end deftypefun


@subsubsection Inspection functions


@deftypefun size_t ucl_vector_number_of_step_up_slots (const ucl_vector_t @var{self})
Return the number of stup up slots.
@end deftypefun


@deftypefun size_t ucl_vector_number_of_step_down_slots (const ucl_vector_t @var{self})
Return the number of step down slots.
@end deftypefun


@deftypefun size_t ucl_vector_number_of_padding_slots (const ucl_vector_t @var{self})
Return the number of padding slots.
@end deftypefun


@subsubsection Updating configuration functions


@deftypefun void ucl_vector_update_number_of_step_up_slots (ucl_vector_t @var{self}, size_t @var{step_up})
Update the number of the step up slots.
@end deftypefun


@deftypefun void ucl_vector_update_number_of_step_down_slots (ucl_vector_t @var{self}, size_t @var{step_down})
Update the number of the step down slots.
@end deftypefun


@deftypefun void ucl_vector_update_number_of_padding_slots (ucl_vector_t @var{self}, size_t @var{padding})
Update the number of the padding slots.
@end deftypefun


@subsubsection Special functions

@deftypefun void ucl_vector_mark_all_slots_as_used (ucl_vector_t @var{self})
Set the fields of @var{self} to describe a vector that uses all the
allocated memory.  This means:

@example
self->first_used_slot = self->first_allocated_slot;
self->last_used_slot  = self->last_allocated_slot;
@end example

This is for special vector usage.
@end deftypefun


@deftypefun void ucl_vector_mark_allocated_range_as_used (ucl_vector_t @var{self}, ucl_range_t @var{range})
Mark a range of slots as used.  This destroys the previous concept of
used slots.  Notice that @var{range} is relative to the allocated slots,
not to the previously used slots.
@end deftypefun


@deftypefun void ucl_vector_reset (ucl_vector_t @var{self})
Reset the internal fields so that the vector appears to be empty.  The
allocated slots memory is not touched.
@end deftypefun


@deftypefun void ucl_vector_clean (ucl_vector_t @var{self})
Set all the allocated memory to null bytes, without touching anything
else.
@end deftypefun


@deftypefun void ucl_vector_initialise_buffer (ucl_vector_t @var{self})
Initialise the vector with: slot dimension one; initial size, step up
and down all to 4096; pad size zero.  This function does not call
@function{ucl_vector_constructor}.

Example:

@example
ucl_vector_t    vector;

ucl_vector_initialise_buffer(vector);
ucl_vector_constructor(vector);
@end example
@end deftypefun


@deftypefun void ucl_vector_swallow_block (ucl_vector_t @var{self}, ucl_block_t @var{block})
A replacement for @function{ucl_vector_constructor} that takes an
already allocated block as data area; it is mandatory for the size of
the block to be an integer multiple of the slot's dimension registered
in @var{self}.  The vector is initialised to be full: all the slots are
marked as used.

The responsibility of the block memory is transferred to the vector, so
the block must be freed only by calling
@function{ucl_vector_destructor}; this means that the memory will be
freed by the allocator registered in @var{self}.

Example:

@example
ucl_vector_t    vector;
ucl_block_t     block;


ucl_block_alloc(block, sizeof(int)*1000);
...

ucl_vector_initialise(vector, sizeof(int));
ucl_vector_swallow_block(vector, block);
@end example
@end deftypefun


@deftypefun void ucl_vector_set_compar (ucl_vector_t @var{self}, ucl_comparison_t @var{compar})
Register the function+context used to compare elements.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node vector indexes
@subsection Converting indexes to pointers


@subsubsection Index to pointer conversion


@deftypefun {void *} ucl_vector_index_to_slot (const ucl_vector_t @var{self}, ucl_index_t @var{index})
Convert @var{index} into the corresponding pointer to a slot in the
vector.

Return a pointer to the selected slot, or @null{} if the selected index
is out of range.  The range of valid values for @var{index} is @code{[0,
size)}, where @code{size} is the return value of
@function{ucl_vector_size}.

Applying @function{ucl_vector_enlarge} or @function{ucl_vector_restrict}
to @var{self} invalidates the return value of this function.

Example:

@example
ucl_vector_t    V;
data_type_t *   ptr;
data_type_t     val;

ucl_vector_initialise(V, sizeof(data_type_t));
ucl_vector_constructor(V);
fill_with_values(V);

ptr = ucl_vector_index_to_slot(V, 13);
if (ptr)
  val = *ptr;
else
  error();
@end example
@end deftypefun


@deftypefun {void *} ucl_vector_index_to_new_slot (const ucl_vector_t @var{self}, ucl_index_t @var{index})
Convert @var{index} into the corresponding pointer to a slot in the
vector.

This is different from @function{ucl_vector_index_to_slot} in that the
requested position can be one unit greater than the last position in the
vector: that way the returned value can be used with
@function{ucl_vector_insert} to append an element to the end of the
vector.

Return a pointer to the selected slot, or @null{} if the selected index
is out of range.  The range of valid values for @var{index} is @code{[0,
size]}, where @code{size} is the return value of
@function{ucl_vector_size}.

Applying @function{ucl_vector_enlarge} or @function{ucl_vector_restrict}
to @var{self} invalidates the return value of this function.  When
adding a new slot: we have to make room for the new slot before
attempting to convert the index to the slot's pointer.

Example:

@example
ucl_vector_t    V;
data_type_t *   ptr;
data_type_t     val;

ucl_vector_initialise(V, sizeof(data_type_t));
ucl_vector_constructor(V);
fill_with_values(V);

ucl_vector_enlarge(V);
ptr = ucl_vector_index_to_new_slot(V, 13);
if (ptr)
  val = *ptr;
else
  error();
@end example
@end deftypefun


@deftypefun {void *} ucl_vector_front (const ucl_vector_t @var{self})
A wrapper for @function{ucl_vector_index_to_slot} that returns a pointer
to the first element in the array.
@end deftypefun


@deftypefun {void *} ucl_vector_back (const ucl_vector_t @var{self})
A wrapper for @function{ucl_vector_index_to_slot} that returns a pointer
to the last element in the array.
@end deftypefun


@subsubsection Pointer to index conversion


@deftypefun ucl_index_t ucl_vector_last_index (const ucl_vector_t @var{self})
Return the index of the last element.
@end deftypefun


@deftypefun ucl_index_t ucl_vector_slot_to_index (const ucl_vector_t @var{self}, const void * @var{pointer_to_slot_p})
Return the index corresponding to a pointer to slot.  It is the inverse
of @function{ucl_vector_index_to_slot}.
@end deftypefun


@subsubsection Validation


@deftypefun ucl_bool_t ucl_vector_pointer_is_valid_slot (const ucl_vector_t @var{self}, const void * @var{pointer_to_slot_p})
Return true if the pointer is a valid slot pointer, else return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_index_is_valid (const ucl_vector_t @var{self}, ucl_index_t @var{index})
Return true if @var{index} is a valid index for the vector.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_index_is_valid_new (const ucl_vector_t @var{self}, ucl_index_t @var{index})
Return true if @var{index} is a valid index for a new slot of the
vector.
@end deftypefun


@subsubsection Range functions


@deftypefun ucl_bool_t ucl_vector_range_is_valid (const ucl_vector_t @var{self}, ucl_range_t @var{range})
Return true if @var{range}, interpreted as inclusive range of indexes,
is valid for @code{self}.
@end deftypefun


@deftypefun ucl_range_t ucl_vector_range (const ucl_vector_t @var{self})
Return the inclusive range of indexes representing the whole vector.
@end deftypefun


@deftypefun ucl_range_t ucl_vector_range_from_position_to_end (const ucl_vector_t @var{self}, ucl_index_t @var{position})
Return the inclusive range of indexes from @var{position} to the end of
the vector.  @var{position} must be a valid index for @var{self}.
@end deftypefun


Notice that to build the range of indexes from the beginning of a vector
to a selected position we just need to do:

@example
ucl_range_t     range;

ucl_range_set_min_max(range, 0, position);
@end example


@deftypefun ucl_range_t ucl_vector_range_from_end_to_position (const ucl_vector_t @var{self}, ucl_index_t @var{position})
Return the inclusive range of indexes from the end of the vector to
@var{position}.  @var{position} must be greater or equal to the size of
@var{self}.

The returned range of indexes is invalid for @var{self}, but it can be
used to append new elements to it; to add slots from the end to index 15
included:

@example
ucl_vector_t    V;
data_type_t *   ptr;
ucl_range_t     range;

ucl_vector_initialise(V, sizeof(data_type_t));
ucl_vector_constructor(V);
fill_with_10_values(V);

range = ucl_vector_range_from_end_to_position(V, 15);

for (size_t i=ucl_range_min(range); i<=ucl_range_max(range); ++i)
  @{
    ucl_vector_enlarge(V);
    ptr  = ucl_vector_index_to_new_slot(V, i);
    *ptr = ...;
  @}
@end example
@end deftypefun


@deftypefun ucl_range_t ucl_vector_range_from_end_with_span (const ucl_vector_t @var{self}, size_t @var{span})
Return the inclusive range of indexes from the end of the vector with
@var{span}.

The returned range of indexes is invalid for @var{self}, but it can be
used to append new elements to it; to add 5 slots to the end:

@example
ucl_vector_t    V;
data_type_t *   ptr;
ucl_range_t     range;

ucl_vector_initialise(V, sizeof(data_type_t));
ucl_vector_constructor(V);
fill_with_values(V);

range = ucl_vector_range_from_end_with_span(V, 5);

for (size_t i=ucl_range_min(range); i<=ucl_range_max(range); ++i)
  @{
    ucl_vector_enlarge(V);
    ptr  = ucl_vector_index_to_new_slot(V, i);
    *ptr = ...;
  @}
@end example

@noindent
of course this is just an example, because it is much easiear to use
@function{ucl_vector_push_back}.
@end deftypefun


@subsubsection Range/block conversion


@deftypefun ucl_block_t ucl_vector_block_from_range (const ucl_vector_t @var{self}, const ucl_range_t @var{range})
Return a block referencing the slots selected by a range.
@end deftypefun


@deftypefun ucl_range_t ucl_vector_range_from_block (const ucl_vector_t @var{self}, const ucl_block_t @var{block})
Return the range of slots referenced by a block.
@end deftypefun


@c ------------------------------------------------------------

@c page
@node vector adding
@subsection Adding elements to a vector


@deftypefun {void *} ucl_vector_insert (ucl_vector_t @var{self}, void * @var{target})
Insert an empty slot at a selected position.  This function assumes that
the array has a free slot to hold the new element: to make sure that
this is true, a call to this function must be preceeded by a call to
@function{ucl_vector_enlarge}.

The pointer to the slot must be the return value of a previous
invocation to @function{ucl_vector_index_to_new_slot}.

This function tries to move as less elements as possible to create an
empty slot at the selected position.  The return value is a pointer to
the empty slot: it can be different from the value of the @var{target}
argument.
@end deftypefun


@deftypefun {void *} ucl_vector_insert_sort (ucl_vector_t @var{self}, void * @var{data_p})
Find the position in the vector in which an element must be inserted to
keep the array sorted and create a new slot there.  This function assumes
that:

@enumerate
@item
there's room in the vector to insert a new element;
@item
the array is sorted;
@item
a comparison function has been registered in @var{self} to be used to
compare elements.
@end enumerate

@var{data_p} is a pointer to a block of memory or variable holding a
copy of the element to be inserted, it's used as first argument to the
comparison function.

The return value is a pointer to the empty slot.
@end deftypefun


The correct sequence of function calls required to insert a new element
is: enlarge the vector, acquire the pointer, make a free slot, copy the
value.  Example of insertion:

@example
ucl_vector_t     vector;
ucl_index_t      index;
data_type_t      data;
data_type_t *    ptr;

...

data  = ...;
index = ...;
ucl_vector_enlarge(vector);
ptr   = ucl_vector_index_to_new_slot(vector, index);
ptr   = ucl_vector_insert(vector, ptr);
*ptr  = data;
@end example

@noindent
example of insert sort operation:

@example
ucl_vector_t     vector;
ucl_index_t      index;
data_type_t      data;
data_type_t *    ptr;

...

data  = ...;
index = ...;
ucl_vector_enlarge(vector);
ptr   = ucl_vector_insert_sort(vector, &data);
*ptr  = data;
@end example


@c ------------------------------------------------------------

@c page
@node vector removing
@subsection Removing elements from a vector


@deftypefun void ucl_vector_erase (ucl_vector_t @var{self}, void * @var{slot})
Erase an element at a selected position: the slot is overwritten by
moving as less elements as possible.  After the invocation: the pointer
represented by the @var{slot} argument value, it's not guaranteed to be
a pointer to a valid slot in the vector.
@end deftypefun

After the invocation of this function, it's possible to attempt a
reallocation of the array to free some unused memory with a call to
@function{ucl_vector_restrict}.


Example of data erasure:

@example
ucl_vector_t     V;
ucl_index_t      index;
data_type_t *    ptr;

...

index = ...
ptr   = ucl_vector_index_to_slot(V, index);
ucl_vector_erase(V, ptr);
ucl_vector_restrict(V);
@end example

@noindent
example of data extraction:

@example
ucl_vector_t     V;
ucl_index_t      index;
data_type_t *    ptr;
data_type_t      data;

...

index = ...
ptr   = ucl_vector_index_to_slot(V, index);
data  = *ptr;
ucl_vector_erase(V, ptr);
ucl_vector_restrict(V);
@end example

@c ------------------------------------------------------------

@c page
@node vector ops
@subsection Various operations on a vector


@subsubsection Dimension inspection


@deftypefun size_t ucl_vector_size (const ucl_vector_t @var{self})
Return a value representing the number of elements in the container.
@end deftypefun


@deftypefun size_t ucl_vector_slot_dimension (const ucl_vector_t @var{self})
Return a value representing the size of the elements.
@end deftypefun


@deftypefun {void *} ucl_vector_increment_slot (const ucl_vector_t @var{self}, void * @var{slot})
Interpret @var{slot} as a pointer to a slot of @var{self} and increment
it so that it references the next element.  This function does no bounds
checking.
@end deftypefun


@deftypefun {void *} ucl_vector_dencrement_slot (const ucl_vector_t @var{self}, void * @var{slot})
Interpret @var{slot} as a pointer to a slot of @var{self} and decrement
it so that it references the previous element.  This function does no
bounds checking.
@end deftypefun


@subsubsection Access to memory blocks


@deftypefun ucl_block_t ucl_vector_get_memory_block (const ucl_vector_t @var{self})
Return a block referencing the allocated memory block.
@end deftypefun

@deftypefun ucl_block_t ucl_vector_get_data_block (const ucl_vector_t @var{self})
Return a block referencing the data block: the used slots.
@end deftypefun

@deftypefun ucl_block_t ucl_vector_get_free_block_at_end (ucl_vector_t @var{self}, size_t @var{count})
Return a block referencing @var{count} free slots at the end of the
vector; the slots are still marked as free.

This function may haul the used slots inside the allocated memory, so
slot pointers requested early will become invalid.

This function has to be called only if there are at least @var{count}
free slots already allocated, see
@function{ucl_vector_enlarge_for_slots} (@ref{vector memory} for
details).

At present blocks returned by this function cannot be converted to a
range with @function{ucl_vector_range_from_block}.
@end deftypefun

@deftypefun ucl_block_t ucl_vector_get_free_block_at_beginning (ucl_vector_t @var{self}, size_t @var{count})
Return a block referencing @var{count} free slots at the beginning of
the vector; the slots are still marked as free.

This function may haul the used slots inside the allocated memory, so
slot pointers requested early will become invalid.

This function has to be called only if there are at least @var{count}
free slots already allocated, see
@function{ucl_vector_enlarge_for_slots} (@ref{vector memory} for
details).

At present blocks returned by this function cannot be converted to a
range with @function{ucl_vector_range_from_block}.
@end deftypefun

@deftypefun void ucl_vector_mark_as_used (ucl_vector_t @var{self}, ucl_block_t @var{block})
Mark the range of free slots referenced by @var{block} as used.  This
function is meant to commit usage of blocks requested with
@function{ucl_vector_get_free_block_at_beginning} and
@function{ucl_vector_get_free_block_at_end}.

@var{block} must be adjacent to the used slots inside the vector, its
size must be an integer multiple of the slot dimension, its memory must
be completely contained in the allocated vector memory.
@end deftypefun


@subsubsection Sorting


@deftypefun void ucl_vector_quick_sort (ucl_vector_t @var{self})
Quick sort the vector using the C library function
@function{ucl_quicksort}.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_sorted (ucl_vector_t @var{self})
Return true if the vector is sorted.  This function scans the whole
vector, so it is slow.
@end deftypefun


@c ------------------------------------------------------------

@c page
@node vector find
@subsection Finding elements


@noindent
The functions described in this section search for an element in the
vector, given a copy of the element to be found.  The @var{data_p}
argument is a pointer to a memory block or variable holding a copy of
the element to be found, it's used as first argument to the comparison
function.

The return value is always a pointer to the found element in the array,
or @null{} if the element is not present.


@deftypefun {void *} ucl_vector_find (const ucl_vector_t @var{self}, const void * @var{data_p})
Find an element in the array with a linear search.
@end deftypefun


@deftypefun {void *} ucl_vector_binary_search (const ucl_vector_t @var{self}, const void * @var{data_p})
Find an element in the array with a binary search; this function assumes
that the array is sorted.
@end deftypefun


@deftypefun {void *} ucl_vector_sort_find (const ucl_vector_t @var{self}, const void * @var{data_p})
Find an element in the array; this function assumes that the array is
sorted.  If there are few elements in the vector: a linear search is
performed, else a binary search is used.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node vector iteration
@subsection Iteration over a vector


@noindent
It's easy to iterate over all the elements of a vector.

Example of forward iteration:

@example
ucl_vector_t     this;
data_type_t *    ptr

...

for (ptr = ucl_vector_front(vect_p);
     ptr <= (data_type_t *) ucl_vector_back(vect_p);
     ++ptr)
  @{
    /* do something with "*ptr" */
  @}
@end example

Example of backward iteration:

@example
ucl_vector_t     this;
data_type_t *    ptr

...

for (ptr = ucl_vector_back(vect_p);
     ptr >= (data_type_t *) ucl_vector_front(vect_p);
     --ptr)
  @{
    /* do something with "*ptr" */
  @}
@end example


Nevertheless: the following iterators are provided.


@deftypefun void ucl_vector_iterator_forward (const ucl_vector_t @var{self}, ucl_iterator_t @var{iterator})
Initialise a forward iteration.
@end deftypefun


@deftypefun void ucl_vector_iterator_backward (const ucl_vector_t @var{self}, ucl_iterator_t @var{iterator})
Initialise a backward iteration.
@end deftypefun


@deftypefun void ucl_vector_iterator_range_forward (const ucl_vector_t @var{self}, ucl_range_t @var{range}, ucl_iterator_t @var{iterator})
Initialise a forward iteration over the inclusive range of elements
selected by @var{range}.  @var{range} must be a valid range for
@var{self}, we can test this with @function{ucl_vector_range_is_valid}.
@end deftypefun


@deftypefun void ucl_vector_iterator_range_backward (const ucl_vector_t @var{self}, ucl_range_t @var{range}, ucl_iterator_t @var{iterator})
Initialise a backward iteration over the inclusive range of elements
selected by @var{range}.  @var{range} must be a valid range for
@var{self}, we can test this with @function{ucl_vector_range_is_valid}.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node vector memory
@subsection Allocating and freeing memory


@noindent
The allocation policy for a vector container is ruled by the arguments
handed to the initialisation functions (@ref{vector creation}).  The
rules are:

@itemize @bullet
@item
an initial number of slots is selected and an array of such size is
allocated;

@item
a number of slots to be kept free at the beginning of the array is
selected, so elements can be moved there when inserting new slots;

@item
the function @function{ucl_vector_enlarge} enlarges the array when one
of the two conditions are true:

@itemize -
@item
the array is full;

@item
a specific number of free slots is requested and there are not enough in
the array;
@end itemize

@item
a ``step up'' number is selected: when the array is reallocated to be
enlarged, the new size is the minimum multiple of this number greater
than the number of elements in the container (in units of slot size):

@example
rest = old_size % step_up
new_size = old_size + (rest)? rest : step_up
@end example

@item
a ``step down'' number is selected: when @function{ucl_vector_restrict}
has to determine if the array has to be reallocated for restriction, the
operation is performed if there are at least that number of free slots;
the new size is computed with the following formula (in units of slot
size):

@example
rest = old_size % step_up
new_size = old_size - step_down
new_size += (rest)? rest : step_up
@end example

@noindent
example:

@example
old_size  = 20
step_up   = 4
step_down = 10

rest     = 20 %  4 =  0
new_size = 20 - 10 = 10
new_size = 10 +  4 = 14
@end example

@noindent
notice that if @code{step_up > step_down} it can result that
@code{new_size >= old_size}, example:

@example
old_size  = 10
step_up   = 4
step_down = 2

rest     = 10 % 4 = 2
new_size = 10 - 2 = 8
new_size =  8 + 2 = 10
@end example

@noindent
another example:

@example
old_size  = 11
step_up   = 4
step_down = 2

rest     = 11 % 4 = 3
new_size = 11 - 2 = 9
new_size =  9 + 3 = 12
@end example

@noindent
that is why @function{ucl_vector_constructor} sets @code{step_down} to a
value greater than @code{step_up}.
@end itemize


By default the @ucl{} allocator is used (@ref{memory functions}), but it
is possible to register a vector--specific allocator.


@c ------------------------------------------------------------

@subsubsection Enlarging


@deftypefun void ucl_vector_enlarge (ucl_vector_t @var{self})
To be used to make sure that at least one free slot exists.

Check if there are free slots in the allocated memory: if there are,
nothing happens; else the array is reallocated and enlarged according to
the reallocation rules.

An error reallocating memory does not corrupt the vector.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_will_enlarge (ucl_vector_t @var{self})
Return true if the next call to @function{ucl_vector_enlarge} will
reallocate the vector.
@end deftypefun


@deftypefun size_t ucl_vector_enlarged_size (ucl_vector_t @var{self})
Return the number of allocated slots after a reallocation for
enlarging.  This function returns a meaningful value only when
@function{ucl_vector_will_enlarge} returns true.
@end deftypefun


@deftypefun void ucl_vector_enlarge_for_slots (ucl_vector_t @var{self}, size_t @var{required_free_slots})
To be used to make sure that there is room for at least the selected
number of free slots.

Check if there are at least @var{required_free_slots} free slots in the
allocated memory: if there are, nothing happens; else the array is
reallocated and enlarged to get enough room.

An error reallocating memory does not corrupt the vector.
@end deftypefun


@deftypefun void ucl_vector_enlarge_for_range (ucl_vector_t @var{self}, ucl_range_t @var{range})
Make sure that there is enough memory to hold the inclusive range of
indexes described by @var{range}.  This works despite @var{range} being:
already a valid range of indexes, completely beyond the upper index
limits, across the current upper index limit.
@end deftypefun


@c ------------------------------------------------------------

@subsubsection Restricting


@deftypefun void ucl_vector_restrict (ucl_vector_t @var{self})
Check if there are enough free slots in the allocated memory so that
it's correct to restrict the array: if there aren't, nothing happens;
else the array is reallocated and restricted according to the
reallocation rules.

An error reallocating memory does not corrupt the vector.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_will_restrict (ucl_vector_t @var{self})
Return true if the next call to @function{ucl_vector_restrict} will
reallocate the vector.
@end deftypefun


@deftypefun size_t ucl_vector_restricted_size (ucl_vector_t @var{self})
Return the number of allocated slots after a reallocation for
restricting.  This function returns a meaningful value only when
@function{ucl_vector_will_restrict} returns true.
@end deftypefun


@subsubsection Miscellaneous functions


@deftypefun void ucl_vector_set_memory_to_zero (ucl_vector_t @var{self})
Set all the slots to zero.  This does not change the vector size: it is
not like extracting all the elements.
@end deftypefun


@deftypefun size_t ucl_vector_number_of_free_slots (ucl_vector_t @var{self})
Returns the number of allocated but currently unused slots.  It is the
number of elements that can be added without causing a memory
reallocation.
@end deftypefun


@deftypefun void ucl_vector_register_allocator (ucl_vector_t @var{self}, ucl_memory_allocator_t @var{allocator})
Register a new allocator.  If this function is not used: the default
allocator is set.

It is safe to call this function only between a call to
@function{ucl_vector_initialise} and a call to
@function{ucl_vector_constructor}.
@end deftypefun


@c ------------------------------------------------------------

@c page
@node vector as pqueue
@subsection Using a vector as a priority queue


@noindent
The vector structure provides all the functions required to implement a
priority queue.  This is a structure in which elements are associated
with keys: when an element is added and the structure is kept sorted
comparing its key with the keys of the elements already in the
container.

Let's say we have declared a structure like this:

@example
typedef struct pair_t @{
  key_t   key;
  val_t   val;
@} pair_t;
@end example

@noindent
and a @code{ucl_comparison_t} function+context to compare keys.

If any time a @code{pair_t} must be inserted in the vector we use the
@function{ucl_vector_insert_sort} function to determine the insertion
position, the elements will be kept sorted according to the key values
and comparison algorithm.

Then @function{ucl_vector_front} or @function{ucl_vector_back} can be
used to extract the element with lesser or greater key.


@c ------------------------------------------------------------

@c page
@node vector high
@subsection High level functions


@noindent
The functions described in this section are built upon the base ones;
some of them invoke the enlarge/restrict memory functions.


@menu
* vector high stack::           Stack and queue.
* vector high append::          Appending data to a vector.
* vector high insert::          Inserting into a vector.
* vector high erase::           Removing from a vector.
* vector high access::          Setters and getters.
* vector high compare::         Comparing vectors.
* vector high apply::           Applying functions.
@end menu

@c ------------------------------------------------------------

@c page
@node vector high stack
@subsubsection Stack and queue


@deftypefun {void *} ucl_vector_push_front (ucl_vector_t @var{self})
Add a slot to the front of the vector and return a pointer to it.

@strong{This function invokes @function{ucl_vector_enlarge}.}
@end deftypefun

@deftypefun {void *} ucl_vector_push_back (ucl_vector_t @var{self})
Add a slot to the tail of the vector and return a pointer to it.

@strong{This function invokes @function{ucl_vector_enlarge}.}
@end deftypefun


@deftypefun void ucl_vector_pop_front (ucl_vector_t @var{self})
If the vector is not empty: erase the first slot, else do nothing.

@strong{This function invokes @function{ucl_vector_restrict}.}
@end deftypefun

@deftypefun void ucl_vector_pop_back (ucl_vector_t @var{self})
If the vector is not empty: erase the last slot, else do nothing.

@strong{This function invokes @function{ucl_vector_restrict}.}
@end deftypefun

Notice that the ``top'' operations of the stack and queue are already
implemented by @function{ucl_vector_front} and
@function{ucl_vector_back}.

@c ------------------------------------------------------------

@c page
@node vector high append
@subsubsection Appending data to a vector


@noindent
In the following functions the @var{target} vector must be an already
initialised an constructed vector.


@deftypefun void ucl_vector_append_block (ucl_vector_t @var{target}, const ucl_block_t @var{block})
Append a block to the vector by copying data from @var{block} with
@function{memcpy}.  The size of the block must be an integer multiple of
the target vector slot dimension.

@strong{This function invokes @function{ucl_vector_enlarge_for_slots}.}
@end deftypefun


@deftypefun void ucl_vector_append (ucl_vector_t @var{target}, const ucl_vector_t @var{source})
Append all the elements of @var{source} to the end of @var{target} by
copying data with @function{memcpy}.  If @var{target} is empty: this
operation is equivalent to duplicating @var{source}.

@strong{This function invokes @function{ucl_vector_enlarge_for_slots}.}
@end deftypefun


@deftypefun void ucl_vector_append_range (ucl_vector_t @var{target}, const ucl_vector_t @var{source}, ucl_range_t @var{range})
Append the elements of @var{source} referenced by @var{range} to the end
of @var{target} by copying data with @function{memcpy}.

@strong{This function invokes @function{ucl_vector_enlarge_for_slots}.}
@end deftypefun


@deftypefun void ucl_vector_append_more (ucl_vector_t @var{target}, const ucl_vector_t @var{source}, @dots{})
Append elements from a set of vectors to the end of @var{target}.  The
@code{...} arguments are a list of @code{ucl_vector_t} values terminated
by a @null{}.

@strong{This function invokes @function{ucl_vector_enlarge_for_slots}.}

Example:

@example
ucl_vector_t    target, a, b, c, d;

...
ucl_vector_append_more(target, a, b, c, d, NULL);
@end example
@end deftypefun


@deftypefun void ucl_vector_append_more_from_array (ucl_vector_t @var{target}, const ucl_vector_array_t * @var{vectors})
Like @function{ucl_vector_append_more} but takes source vectors from an
array rather than from application parameters.
@end deftypefun


@c ------------------------------------------------------------

@c page
@node vector high insert
@subsubsection Inserting into a vector


@deftypefun void ucl_vector_insert_vector (ucl_vector_t @var{target}, ucl_index_t @var{offset}, ucl_vector_t @var{source})
Insert all the elements of @var{source} into @var{target} at
@var{offset}.

@var{offset} must be a valid value for
@function{ucl_vector_index_to_new_slot}.

@strong{This function invokes @function{ucl_vector_enlarge_for_slots}.}
@end deftypefun


@deftypefun void ucl_vector_insert_block (ucl_vector_t @var{target}, ucl_index_t @var{offset}, const ucl_block_t @var{block})
Insert the data referenced by @var{block} into @var{target} at
@var{offset}.

The size of @var{block} must be an integer multiple of the slot's
dimension of @var{target}.  @var{offset} must be a valid value for
@function{ucl_vector_index_to_new_slot}.

@strong{This function invokes @function{ucl_vector_enlarge_for_slots}.}
@end deftypefun


@deftypefun void ucl_vector_insert_range (ucl_vector_t @var{target}, ucl_index_t @var{offset}, const ucl_vector_t @var{source}, ucl_range_t @var{range});
Insert the data referenced by the inclusive @var{range} of indexes from
@var{source} into @var{target} at @var{offset}.

The size of @var{block} must be an integer multiple of the slot's
dimension of @var{target}.  @var{offset} must be a valid value for
@function{ucl_vector_index_to_new_slot}.

@strong{This function invokes @function{ucl_vector_enlarge_for_slots}.}
@end deftypefun



@c ------------------------------------------------------------

@c page
@node vector high erase
@subsubsection Removing from a vector


@deftypefun void ucl_vector_erase_range (ucl_vector_t @var{self}, ucl_range_t @var{range})
Erase all the elements in the selected range.

@strong{This function invokes @function{ucl_vector_restrict}.}
@end deftypefun

@c ------------------------------------------------------------

@c page
@node vector high access
@subsubsection Setters and getters


@deftypefun void ucl_vector_copy_range (ucl_vector_t @var{target}, ucl_index_t @var{position}, ucl_vector_t @var{source}, ucl_range_t @var{source_range})
Copy slots referenced by @var{source_range} in @var{source} to
@var{position} in @var{target}.  Data into @var{target} is overwritten.

@var{position} must be a valid index for @var{target}.
@var{source_range} must be valid for @var{source}.  There must be enough
slots after @var{position} in @var{target} to hold the whole range from
@var{source}.
@end deftypefun


@deftypefun void ucl_vector_set_block (ucl_vector_t @var{target}, ucl_index_t @var{position}, ucl_block_t @var{source})
Copy data from @var{source} into @var{target} at @var{position},
overwriting data.

@var{position} must be a valid index for @var{target} and enough slots
must exist after it to accept the whol @var{source} block.  The length of
@var{source} must be an integer multiple of the slot's dimension in
@var{target}.
@end deftypefun


@deftypefun void ucl_vector_get_block (ucl_block_t @var{target}, ucl_index_t @var{position}, ucl_vector_t @var{source})
Copy data from @var{source} at @var{position} into @var{target},
overwriting data.

@var{position} must be a valid index for @var{target} and there must be
enough slots in @var{target} to fill the block.  The length of
@var{source} must be an integer multiple of the slot's dimension in
@var{target}.
@end deftypefun


@c ------------------------------------------------------------

@c page
@node vector high compare
@subsubsection Comparing vectors


@deftypefun int ucl_vector_compare_range (ucl_vector_t @var{a}, ucl_range_t @var{range_a}, ucl_vector_t @var{b}, ucl_range_t @var{range_b})
Compare two ranges of elements in two vectors, element by element, using
the comparison function of @var{a}.  If the size of the ranges is not
equal: only a number of elements equal to the lesser size is
compared.  The comparison stops at the first pair of elements for which
the comparison function returns non--zero.

Works somewhat like @function{strcmp}.  Return:

@table @code
@item 0
if all the compared elements are equal;
@item +1
if, for the last compared pair, the element from @var{a} is greater than
the last element from @var{b};
@item -1
if, for the last compared pair, the element from @var{a} is
lesser than the last element from @var{b}.
@end table

@var{a} can be equal to @var{b}.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_equal_range (ucl_vector_t @var{a}, ucl_range_t @var{range_a}, ucl_vector_t @var{b}, ucl_range_t @var{range_b})
Wrapper for @function{ucl_vector_compare_range} that returns true if the
two ranges are equal.
@end deftypefun


@deftypefun int ucl_vector_compare (ucl_vector_t @var{a}, ucl_vector_t @var{b})
Wrapper for @function{ucl_vector_compare_range} that compares the whole vectors.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_equal (ucl_vector_t @var{a}, ucl_vector_t @var{b})
Wrapper for @function{ucl_vector_compare}: return true if the vectors
are equal.
@end deftypefun


@c ------------------------------------------------------------

@c page
@node vector high apply
@subsubsection Applying functions


@noindent
The functions described in this section allow us to apply a function, in
the form of a callback (@ref{typedefs callback}), to each element in a
vector or to each element in a range over a vector.  The ``for each''
kind leaves to the callback the responsibility to produce a result,
while the ``map'' kind produces a vector holding processed elements.


@deftypefun void ucl_vector_for_each (ucl_callback_t @var{cb}, ucl_vector_t @var{V})
Apply the callback @var{cb} to each element in the vector
@var{V}.  The callback function is invoked with a pointer to the
element's slot as custom value.

Example of callback that sums the values in a vector:

@example
void
callback (ucl_value_t state, ucl_value_t custom)
@{
  int * accumulator_p   = state.ptr;
  int * slot            = custom.ptr;

  *accumulator_p += *slot;
@}

ucl_vector_t    vector;
int             accumulator = 0;
ucl_callback_t  cb = @{
  .func = callback,
  .data = @{ .ptr = &accumulator @}
@};

ucl_vector_initialise(vector, sizeof(int));
ucl_vector_constructor(vector);
fill_with_values(vector);

ucl_vector_for_each(cb, vector);
@end example

@noindent
with this setup the operation is like a ``fold''.
@end deftypefun


@deftypefun void ucl_vector_for_each_in_range (ucl_callback_t @var{cb}, ucl_range_t @var{range}, ucl_vector_t @var{V})
Like @function{ucl_vector_for_each}, but apply the callback only to the
elements selected by the inclusive @var{range}.

Example of callback that sums the values in a vector's range:

@example
void
callback (ucl_value_t state, ucl_value_t custom)
@{
  int * accumulator_p   = state.ptr;
  int * slot            = custom.ptr;

  *accumulator_p += *slot;
@}

ucl_vector_t    vector;
int             accumulator = 0;
ucl_callback_t  cb = @{
  .func = callback,
  .data = @{ .ptr = &accumulator @}
@};
ucl_range_t     range;

ucl_vector_initialise(vector, sizeof(int));
ucl_vector_constructor(vector);
fill_with_values(vector);

ucl_range_set_min_max(range, 3, 8);
ucl_vector_for_each_in_range(cb, range, vector);
@end example
@end deftypefun


@deftypefun void ucl_vector_for_each_multiple (ucl_callback_t @var{cb}, ucl_vector_t @var{V}, @dots{})
Like @function{ucl_vector_for_each}, but apply the callback to an array
of pointers to slots from the vectors used as arguments.

This function must be invoked with a list of @code{ucl_vector_t}
arguments ended by a @null{}.

The callback function is invoked with a pointer to a
@code{ucl_array_of_pointers_t} structure as custom value:

@table @code
@item ucl_value_t data
the @code{unum} field is set to the index of the slot currently visited;

@item size_t number_of_slots
the number of slots which is equal to the number of vectors used as
arguments;

@item void ** slots
a pointer to an array of pointers to the slots.
@end table

The iteration stops when the end of the shortest vector is found.

Example:

@example
static void
callback (ucl_value_t state, ucl_value_t custom)
@{
  int *                         sums    = state.ptr;
  ucl_array_of_pointers_t *     slots   = custom.ptr;
  int **                        values  = (int **)slots->slots;

  for (size_t i=0; i<slots->number_of_slots; ++i)
    sums[slots->data.unum] += *values[i];
@}

ucl_vector_t   A, B, C;
int            sums[5] = @{ 0, 0, 0, 0, 0 @};
ucl_callback_t cb = @{
  .func = callback,
  .data = @{ .ptr = &sums @}
@};


ucl_vector_initialise(A, sizeof(int));
ucl_vector_initialise(B, sizeof(int));
ucl_vector_initialise(C, sizeof(int));
ucl_vector_constructor(A);
ucl_vector_constructor(B);
ucl_vector_constructor(C);
fill_with_values(A);
fill_with_values(B);
fill_with_values(C);

ucl_vector_for_each_multiple(cb, A, B, C, NULL);
@end example
@end deftypefun


@deftypefun void ucl_vector_for_each_multiple_from_array (ucl_callback_t @var{cb}, ucl_vector_array_t * @var{vectors})
Like @function{ucl_vector_for_each_multiple} but the vectors are given
in an array rather than a list of arguments.
@end deftypefun


@deftypefun void ucl_vector_map (ucl_vector_t @var{R}, ucl_callback_t @var{cb}, ucl_vector_t @var{V})
Apply the callback @var{cb} to each element in the vector @var{V} and
store the result in the vector @var{R}.  New slots are added to @var{R}
using @function{ucl_vector_push_back}.

The callback function is invoked with a pointer to a
@code{ucl_array_of_pointers_t} structure as custom value:

@table @code
@item ucl_value_t data
the @code{unum} field is set to the index of the slot currently visited;

@item size_t number_of_slots
the number of slots: always @code{2} for this function;

@item void ** slots
a pointer to an array of pointers to the slots; the first element
(@code{slots[0]}) references the result slot, while the second element
(@code{slots[1]}) references the operand slot.
@end table

Example of callback that negates the values:

@example
void
callback (ucl_value_t state UCL_UNUSED, ucl_value_t custom)
@{
  ucl_array_of_pointers_t * slots   = custom.ptr;
  int *                     result  = slots.slots[0];
  int *                     operand = slots.slots[1];
  
  *result = - *operand;
@}

ucl_vector_t    result, operand;
ucl_callback_t  cb = @{
  .func = callback,
  .data = @{ .ptr = NULL @}
@};

ucl_vector_initialise(result,  sizeof(int));
ucl_vector_initialise(operand, sizeof(int));
ucl_vector_constructor(result);
ucl_vector_constructor(operand);
fill_with_values(result);
fill_with_values(operand);

ucl_vector_map(result, cb, operand);
@end example
@end deftypefun


@deftypefun void ucl_vector_map_range (ucl_vector_t @var{R}, ucl_callback_t @var{cb}, ucl_range_t @var{range}, ucl_vector_t @var{V})
Like @function{ucl_vector_map}, but apply the callback only to the
elements selected by the inclusive @var{range}.
@end deftypefun


@deftypefun void ucl_vector_map_multiple (ucl_vector_t @var{R}, ucl_callback_t @var{cb}, ucl_vector_t @var{first}, ...)
Like @function{ucl_vector_map}, but apply the callback to an array of
pointers to slots from the vectors used as arguments.

The function must be invoked with a list of @code{ucl_vector_t}
arguments ended by @null{}.

The callback function is invoked with a pointer to a
@code{ucl_array_of_pointers_t} structure as custom value:

@table @code
@item ucl_value_t data
the @code{unum} field is set to the index of the slot currently visited;

@item size_t number_of_slots
the number of slots which is equal to 1 plus the number of vectors used
as arguments;

@item void ** slots
a pointer to an array of pointers to the slots; the first element
(@code{slots[0]}) references the result slots, while the following
elements (@code{slots[1]}, @code{slots[2]}, @dots{}) reference the
operands.
@end table

The iteration stops when the end of the shortest operand vector is
found.

Example of callback that computes the sum of vectors:

@example
static void
callback (ucl_value_t state UCL_UNUSED, ucl_value_t custom)
@{
  ucl_array_of_pointers_t *  slots  = custom.ptr;
  int **                     values = (int **)slots->slots;

  *values[0] = 0;
  for (size_t i=1; i<slots->number_of_slots; ++i)
    *values[0] += *values[i];
@}

ucl_vector_t    R, A, B, C;
ucl_callback_t  cb = @{
  .func = callback,
  .data = @{ .ptr = NULL @}
@};


ucl_vector_initialise(A, sizeof(int));
ucl_vector_initialise(B, sizeof(int));
ucl_vector_initialise(C, sizeof(int));
ucl_vector_constructor(A);
ucl_vector_constructor(B);
ucl_vector_constructor(C);
fill_with_values(A);
fill_with_values(B);
fill_with_values(C);

ucl_vector_initialise(R, sizeof(int));
ucl_vector_constructor(R);

ucl_vector_map_multiple(R, cb, A, B, C, NULL);
@end example
@end deftypefun


@deftypefun void ucl_vector_map_multiple_from_array (ucl_vector_t @var{R}, ucl_callback_t @var{cb}, ucl_vector_array_t * @var{vectors})
Like @function{ucl_vector_map_multiple} but the vectors are given in an
array rather than a list of arguments.
@end deftypefun



@c ------------------------------------------------------------

@c page
@node iterators
@chapter Container iteration


@noindent
Each container has its iteration constructors that must be invoked
explicitly, but the functions used to do the actual iterations and to
access the objects are accessed through a set of macros.


@section Type definitions


@deftp {Struct Typedef} ucl_iterator_struct_t
Base structure for all the iterators.
@end deftp

@deftp {One--Element Array Typedef} ucl_iterator_t
Array of one @code{ucl_iterator_struct_t}.
@end deftp


@section Functions


@deftypefun ucl_bool_t ucl_iterator_more (ucl_iterator_t @var{iterator})
Return true if there are more elements to iterate, false if the
iteration is over.
@end deftypefun


@deftypefun void ucl_iterator_next (ucl_iterator_t @var{iterator})
Advance the iteration.
@end deftypefun


@deftypefun {void *} ucl_iterator_ptr (ucl_iterator_t @var{iterator})
Return a pointer referencing the current value.  If the iteration is
already over: return @null{}.
@end deftypefun


@section Examples


@noindent
Example of iterator usage:

@example
ucl_value_t       val;
ucl_iterator_t    iterator;
ucl_map_link_t *  link_p;

...

for (ucl_map_iterator_inorder(this, iterator);
     ucl_iterator_more(iterator);
     ucl_iterator_next(iterator))
  @{
    link_p = ucl_iterator_ptr(iterator);
    val = ucl_map_getval(link_p);
  @}
@end example


@c page
@node generic
@chapter Generic functions


@section Package version number

@deftypefun {const char *} ucl_version (void)
Return a pointer to a string representing the version number.
@end deftypefun

@deftypefun {const char *} ucl_major_version (void)
Return a pointer to a string representing the major version number.
@end deftypefun

@deftypefun {const char *} ucl_minor_version (void)
Return a pointer to a string representing the minor version number.
@end deftypefun

@deftypefun {const char *} ucl_patch_version (void)
Return a pointer to a string representing the patch level version
number.
@end deftypefun


@section Interface version number


@deftypefun unsigned ucl_interface_major_version (void)
Return a number representing the library interface major version
number.
@end deftypefun

@deftypefun unsigned ucl_interface_minor_version (void)
Return a number representing the library interface minor version
number.
@end deftypefun


@section Values comparison


@noindent
The following functions match the @code{ucl_valcmp_fun_t} prototype.


@deftypefun int ucl_intcmp (ucl_value_t data, const ucl_value_t @var{a}, const ucl_value_t @var{b})
Compare the @code{num} fields of two values.  @var{data} must be @null{}.

Return: @code{0} if @var{a} equals @var{b}; @code{1} if @var{a} is
greater than @var{b}; @code{-1} if @var{a} is lesser than @var{b}.
@end deftypefun


@deftypefun int ucl_intcmp (ucl_value_t data, const ucl_value_t @var{a}, const ucl_value_t @var{b})
Compare the @code{unum} fields of two values.  @var{data} must be
@null{}.

Return: @code{0} if @var{a} equals @var{b}; @code{1} if @var{a} is
greater than @var{b}; @code{-1} if @var{a} is lesser than @var{b}.
@end deftypefun


@deftypefun int ucl_strcmp (ucl_value_t data, const ucl_value_t @var{a}, const ucl_value_t @var{b})
Wrapper for @function{strcmp}.  Compare the @code{str} fields of @var{a}
and @code{b}.  @var{data} must be @null{}.
@end deftypefun


@deftypefun int ucl_ptrintcmp (ucl_value_t data, const ucl_value_t @var{a}, const ucl_value_t @var{b})
Interpret the @code{ptr} fields of @var{a} and @var{b} as pointers of
type @code{int}: compare the two referenced numbers by invoking
@function{ucl_intcmp}.
@end deftypefun


@subsection Sorting


@deftypefun void ucl_quicksort (void * @var{array}, size_t @var{count}, size_t @var{size}, ucl_comparison_t @var{compar})
Like the standard @function{qsort}, but makes use of the comparison
function and context in @var{compar}.   @var{array} is an array of
@var{count} elements of size @var{size}.

This is indeed the @function{qsort} function from the @gnu{} C Library
version 2.4, modified to use @var{compar}.
@end deftypefun



@c ------------------------------------------------------------

@c page
@node stub
@chapter The stubs mechanism


@noindent
For an explanation of the stubs mechanism @ref{stub mechanism}.


@defmac UCL_ENABLE_STUB
Preprocessor symbol to be defined to include stubs library declarations
and definitions in the @ucl{} header file.
@end defmac


@deftypefun {const char *} ucl_init_stub_table (void)
Initialise the stub table; to be called when using the stub library,
before invoking any of the @ucl{} functions.

Loads the @ucl{} library using the @code{dl} mechanism.  If no error
returns @null{}, else returns the error string returned by
@function{dlerror}.
@end deftypefun


@deftypefun int ucl_final_stub_table (void)
Unloads the @ucl{} library using the @code{dl} mechanism.   If no error
returns 0, else returns the error code returned by @function{dlclose}.
@end deftypefun



@appendixsubsec How to use the @ucl{} stub library

@enumerate
@item
Write the the source code including the @file{ucl.h} header and invoking
functions as usual.

@item
In the initialisation phase of our code invoke the @ucl{} stub
initialisation function:

@example
const char * err = ucl_init_stub_table();
if (NULL != err) goto error;
@end example

the return value is the error message returned by @function{dlerror}.

@item
Compile our code with the symbol @code{UCL_ENABLE_STUB}:

@example
gcc ourcode.c -DUCL_ENABLE_STUB -c -o ourcode.o
@end example

@item
Link the code with the stub library and the @code{dl} library:

@example
gcc ourcode.o -ldl -lstubucl1.0
@end example
@end enumerate


@appendixsubsec How not to use the @ucl{} stubs library

@enumerate
@item
Write the the source code including the @file{ucl.h} header and invoking
functions as usual.

@item
Compile our code @strong{without} the symbol @code{UCL_ENABLE_STUB}:

@example
gcc ourcode.c -c -o ourcode.o
@end example

@item
Link the code with the shared library:

@example
gcc ourcode.o -lucl1.0
@end example
@end enumerate


@c page

@include libversion.texiinc
@include stubmechanism.texiinc

@c page
@node references
@appendix Bibliography and references


@noindent
Ellis Horowitz, Sartaj  Sahni and Susan Anderson--Freed.  @emph{Strutture
dati in C}.  McGraw--Hill, 1993.

@noindent
Bjarne Stroustroup.  @emph{C++}.  Addison-Wesley, 1997.


@c ------------------------------------------------------------

@c page

@include gpl.texiinc
@include fdl.texiinc

@c page
@node concept index
@appendix An entry for each concept
@printindex cp


@node function index
@appendix An entry for each function
@printindex fn
     

@node type index
@appendix An entry for each type. 
@printindex tp


@node variable index
@appendix An entry for each variable. 
@printindex vr


@contents
@bye


@c end of file
