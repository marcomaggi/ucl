\input texinfo.tex @c -*-texinfo-*-
@c %**start of header
@setfilename ucl.info
@settitle Useless Containers Library
@c %**end of header


@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@macro ucl{}
@acronym{UCL}
@end macro

@macro tcl{}
@acronym{TCL}
@end macro

@macro dfs{}
@acronym{DFS}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms

@macro ascii{}
@acronym{ASCII}
@end macro

@macro api{}
@acronym{API}
@end macro

@macro avl{}
@acronym{AVL}
@end macro

@c Remember that @url is already used by Texinfo.
@macro urla{}
@acronym{URL}
@end macro

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c C language macros.

@macro function{NAME}
@code{\NAME\()}
@end macro

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro cnull{}
@code{NULL}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Useless Containers Library

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @ucl{}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ucl

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2001-2010


@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a set of
containers that can hold the basic set of C language types and untyped
pointers.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}/}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front-Cover Texts, and no
Back-Cover Texts.  A copy of the license is included in the section
entitled ``GNU Free Documentation License''.
@end quotation
@end copying


@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifnottex
@dircategory Development
@direntry
* ucl: (ucl).                   Useless Containers Library.
@end direntry
@end ifnottex

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore


@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the library.
* memory::                      Memory allocation.
* typedefs::                    Data types you have to know.
* containers::                  The data structures.
* iterators::                   Container iteration.
* misc::                        Miscellaneous functions.

Appendices

* library version::             How to interpret the library version.
* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.
* concept index::               An entry for each concept.
* function index::              An entry for each function.
* type index::                  An entry for each type.
* variable index::              An entry for each variable.

@detailmenu
 --- The Detailed Node Listing ---

Overview of the library

* overview using::              Using the library.
* overview autoconf::           Using @gnu{} Autoconf to load @ucl{}.
* overview pkgconfig::          Using pkgconfig to load @ucl{}.
* overview error::              Error handling.
* overview size::               Structures size.
* overview const::              Constification.

Memory allocation

* memory typedefs::             Allocator data types.
* memory functions::            The default allocator.
* memory blocks::               Handling blocks of memory.
* memory ascii::                Handling ASCII strings.
* memory macros::               Miscellaneous macros.

Data types you have to know

* typedefs value::              Collected values and others.
* typedefs ranges::             Range selectors.
* typedefs compar::             Comparison functions.
* typedefs hash::               Hash functions.
* typedefs callback::           Callback functions.
* typedefs nodes::              Wrapping node structures.

The data structures

* btree::                       The binary tree structure.
* tree::                        The tree structure.
* circular::                    The circular list structure.
* graph::                       The graph structure.
* hash::                        The hash table structure.
* heap::                        The heap structure.
* list::                        The linked list structure.
* map::                         The map structure.
* vector::                      The vector structure.

The binary tree container

* btree typedefs::              Implementation and type definitions.
* btree examples::              Usage examples.
* btree creation::              Building btree hierarchies.
* btree inspection::            Accessing nodes.
* btree removing::              Removing elements.
* btree find::                  Finding values.
* btree swap::                  Swapping nodes.
* btree visitors::              Finding nodes.
* btree iteration::             Iterations in a btree hierarchy.
* btree bst::                   Routines for raw binary search trees.
* btree avl::                   Routines for @avl{} trees.

Iterations in a btree hierarchy

* btree inorder iteration::     Inorder iteration.
* btree preorder iteration::    Preorder iteration.
* btree postorder iteration::   Postorder iteration.
* btree breadth first::         Breadth first iteration.

The tree structure

* tree implementation::         How it's done.
* tree creation::               Creating a tree hierarchy.
* tree insertion::              Inserting nodes into a tree.
* tree testing::                Testing relationships between nodes.
* tree relatives::              Accessing or setting the relatives of
                                a node.
* tree removing::               Removing elements from a tree.
* tree iterators::              Traversing a tree.

The heap structure

* heap creation::             Creating and destroying heaps.
* heap insertion::            Adding elements to a heaps.
* heap deletion::             Removing elements from a heaps.
* heap ops::                  Various operations on a heaps.

The circular list

* circular creation::           Creating and destroying circulars.
* circular adding::             Adding elements to a circular.
* circular removing::           Removing elements from a circular.
* circular moving::             Moving the cursor.
* circular search::             Searching elements.
* circular ops::                Various operations on a circular.

The graph structure

* graph overview::              How it's done.
* graph types::                 Graph type definitions.
* graph insert::                Inserting links and nodes.
* graph extract::               Extracting links and nodes.
* graph merge::                 Merging links.
* graph value::                 Accessing values.
* graph link iter::             Link iterators.
* graph ops::                   Various operations on a graph.
* graph dfs::                   Depth first search.

Depth first search

* graph dfs example::           @dfs{} example.
* graph dfs types::             @dfs{} related type defintions.
* graph dfs api::               @dfs{} programming interface.

The hash table structure

* hash types::                  Hash table types definitions.
* hash implementation::         How it's done.
* hash creation::               Creating and destroying hash tables.
* hash insertion::              Adding elements to a hash table.
* hash deletion::               Removing elements from a hash table.
* hash ops::                    Various operations on a hash table.
* hash resizing::               Resizing a hash table.
* hash iterator::               Visiting elements in the table.
* hash functions::              Provided hash function.

The linked list structure

* list overview::               How it is done.
* list cons::                   Constructing lists.
* list visit::                  Visiting a list.
* list deletion::               Removing elements from a list.
* list ops::                    Various operations on a list.
* list iteration::              Iteration over a list.

The map structure

* map intro::                   Introduction to operations and
                                implementation.
* map types::                   Type definitions for map.
* map creation::                Creating and destroying maps.
* map insertion::               Adding elements to a map.
* map deletion::                Removing elements from a map.
* map ops::                     Various operations on a map.
* map iterators::               Iteration over a map.
* map set::                     Composing map iterators.

The vector structure

* vector implementation::       How it's done.
* vector typedefs::             Type definitions
* vector creation::             Creating and destroying vectors.
* vector indexes::              Converting indexes to pointers.
* vector adding::               Adding elements to a vector.
* vector removing::             Removing elements from a vector.
* vector ops::                  Various operations on a vector.
* vector find::                 Finding elements.
* vector iteration::            Iteration over a vector.
* vector memory::               Allocating and freeing memory.
* vector as pqueue::            Using a vector as a priority queue.
* vector high::                 High level functions.

Converting indexes to pointers

* vector indexes i2p::          Index to pointer conversion.
* vector indexes p2i::          Pointer to index conversion.
* vector indexes validation::   Validating indexes.
* vector indexes range::        Range functions.
* vector indexes block::        Range/block conversion.

Allocating and freeing memory

* vector memory intro::         Introduction to vector memory handling.
* vector memory enlarge::       Enlarging allocated memory.
* vector memory restrict::      Restricting allocated memory.
* vector memory misc::          Miscellaneous memory functions.

High level functions

* vector high stack::           Stack and queue.
* vector high append::          Appending data to a vector.
* vector high insert::          Inserting into a vector.
* vector high erase::           Removing from a vector.
* vector high access::          Setters and getters.
* vector high compare::         Comparing vectors.
* vector high apply::           Applying functions.

Miscellaneous functions

* misc version::                Version functions.
* misc compar::                 Comparison functions.
* misc sort::                   Sorting functions.

@end detailmenu
@end menu

@end ifnottex


@c page
@node overview
@chapter Overview of the library


This container library may be thought of as ``low level''.  Methods are
provided to handle collected data, but no container can be used without
wrapping it in a module whose functions ``know'' how to deal with the
type of collected data.

The containers have to be used as ``leaves'' in the graph of
dependencies of a whole application; they provide a service: collecting
data.  For example: if we need to store a data structure in a linked
list, we don't have to think that the structure ``is a'' list link, but
rather that, temporarily, the structure is ``referenced by'' a list
link.

We give to the container the responsibility to hold a reference to a
structure and we will come back later to take it out.

All the function and data type names are prefixed with @code{ucl_}.
There is no error reporting system: it is our responsibility to validate
function's arguments using the appropriate @ucl{} functions.  With the
single exception of the vector module: @ucl{} does no memory allocation.

The library is developed and tested under the Linux+@gnu{} system and
officially it supports only the @gnu{} infrastructure: requires the
@gnu{} C library and compiles fine with the @gnu{} C compiler
(@code{-std=c99 -pedantic} switches).

@menu
* overview using::              Using the library.
* overview autoconf::           Using @gnu{} Autoconf to load @ucl{}.
* overview pkgconfig::          Using pkgconfig to load @ucl{}.
* overview error::              Error handling.
* overview size::               Structures size.
* overview const::              Constification.
@end menu

@c ------------------------------------------------------------

@set using_package_name         @value{PACKAGE}
@set using_package              @value{PACKAGE_NICKNAME}
@set using_PACKAGE              UCL
@set using_config_script        @value{PACKAGE_NICKNAME}-config
@set using_xversion             1.0a1
@set using_version              1.0.0
@set using_iface_version        1.2
@set using_autoconf_macro       USELESS_CONTAINERS_LIBRARY

@include overview-using.texiinc

@c page
@node overview error
@section Error handling


The design of methods tries to be the one that maximises the number of
functions that cannot fail.  This sometimes leads to ``strange'' or
``dangerous'' methods: functions that will cause the application to
crash if an argument is incorrect.  But, in these cases, the library
provides a function to test the argument separately: to assert the
precondition.

For example: if a vector index is out of range, we have to make sure not
to hand it to an insertion/extraction method; we have to test it first
and make use of it only if the test result is good.

@c page
@node overview size
@section Structures size


Under the tests directory of the source tree there is a small program
that links to the library and prints the size of the @ucl{} data
structures.  On a @code{i686-pc-linux-gnu} the output is:

@example
Size of common data types:

char            1 :)
void *          4
int             4
short int       2
long int        4
long long       8
float           4
double          8
long double     12
size_t          4
ptrdiff_t       4

Limits:

short int (SHRT_MIN, SHRT_MAX)  -32768 32767
integer (INT_MIN, INT_MAX)      -2147483648 2147483647
unsigned short int (USHRT_MAX)  65535
unsigned (UINT_MAX)             4294967295

Size of UCL structures:

ucl_value_t     4
ucl_circular_t  16
ucl_hash_t      68
ucl_iterator_t  20
ucl_list_t      20
ucl_map_t       20
ucl_vector_t    48

Size of UCL link structures:

ucl_btree_node_t        12
ucl_hash_entry_t        16
ucl_list_link_t         16
ucl_map_link_t          24
ucl_tree_node_t         12
ucl_graph_node_t        28
ucl_graph_link_t        28
@end example

@c page
@node overview const
@section Constification


This library has the need to write functions, conceptually, like this
one:

@example
void data_type_t *
the_function (data_type_t * p)
@{
  return p;
@}
@end example

@noindent
that is: functions that do not modify the arguments, but whose return
value must be modifiable.  To write them like this:

@example
void data_type_t *
the_function (const data_type_t * p)
@{
  return p;
@}
@end example

@noindent
would be useful because:

@enumerate
@item
it makes clear to the user that the data referenced by @code{p} is not
modified;
@item
causes the compiler to raise an error if we attempt to modify the data;
@end enumerate

@noindent
but a warning is issued because the @code{return} statement discards the
@code{const} qualifier.

The adopted solution is to avoid the @code{-Wcast-qual} flag of the
@gnu{} C compiler, which is responsible to issue a warning if we discard
a qualifier with a cast; so the following implementation does not raise
warnings:

@example
void data_type_t *
the_function (const data_type_t * p)
@{
  return (data_type_t *)p;
@}
@end example

It is not beautiful.  But the ugliness is only in the @ucl{} code, the
user does not see it.

@c page
@node memory
@chapter Memory allocation


@ucl{} tries to avoid as much as possible the responsibility to allocate
and release memory.  Dynamic structures based on trees or linked lists
do not call any memory allocation function: the responsibility to
allocate @ucl{} data structures is delegated to the user's code.

This makes the library a little more complex to use, but it also makes
the code simpler by reducing the error cases that have to be dealt with.
Also, user's code can implement a custom allocator and feed memory
blocks to @ucl{}'s functions.  This behaviour can be leveraged to
improve performance, because the @ucl{} makes use of a lot of little
data structures.

When needed: the library makes use of a default allocator that reverts
to the standard @function{malloc}, @function{realloc} and
@function{free} functions.

@menu
* memory typedefs::             Allocator data types.
* memory functions::            The default allocator.
* memory blocks::               Handling blocks of memory.
* memory ascii::                Handling ASCII strings.
* memory macros::               Miscellaneous macros.
@end menu

@c page
@node memory typedefs
@section Data types


The following @api{} has two main purposes:

@enumerate
@item
to implement the classic alloc, realloc and free operations;

@item
to define an allocator data structure that is small enough to be used
directly as function argument (that is: passed by value).
@end enumerate


@deftp {Struct Typedef} ucl_memory_allocator_t
Type of the memory allocator.  We may build structures of this type to
select a memory allocation policy.  Fields description follows.

@table @code
@item void * data
Pointer to an allocator data structure holding the state of the
allocator; it is used as first argument to the allocator function, it
can be @cnull{}.

@item ucl_memory_alloc_fun_t * alloc
Pointer to a function used to allocate/reallocate/free a memory block.
@end table
@end deftp


@deftypefn {Function Prototype} void ucl_memory_alloc_fun_t (void * @var{data}, void * @var{pp}, size_t @var{dim})
Allocate, reallocate or free memory blocks.

@table @var
@item data
The value of the @code{data} field in the allocator data structure.

@item pp
Internally cast to @code{void **}, it is a pointer to the variable that
holds the pointer to handle.

@item dim
The dimension of the memory block.  It is expressed in bytes for the
@ucl{} functions.
@end table

The protocol:

@itemize
@item
if @var{dim} is zero:

@itemize
@item
if @code{*@var{pp}} is @cnull{}: nothing happens,
@item
else @code{*@var{pp}} is not @cnull{}: the referenced memory is
freed;
@end itemize

@item
else @var{dim} is positive:

@itemize
@item
if @code{*@var{pp}} is @cnull{}: a new block of memory is allocated
and a pointer to it stored in @code{*@var{pp}};

@item
else @code{*@var{pp}} is not @cnull{}: the block of memory referenced
by @code{*@var{pp}} is reallocated and a pointer to the new block is
stored in @code{*@var{pp}}.
@end itemize
@end itemize

This function must work like @function{malloc}, @function{realloc} and
@function{free} with the fundamental difference that: in case of error
it must not return.  What it does instead of returning is not the
business of @ucl{}; the default allocator will terminate the process
with an invocation to @function{exit} with code @code{EXIT_FAILURE}.
The @ucl{} guarantees that an error allocating memory will not corrupt
any container (so the @code{alloc} function can @cfunc{longjump} to
somewhere in case of error).
@end deftypefn


Example of new memory block allocation:

@example
ucl_memory_allocator_t allocator;
void * p = NULL;

allocator.alloc(allocator.data, &p, 4096);
@end example

@noindent
example of memory block reallocation:

@example
ucl_memory_allocator_t allocator;
void * p = ...;

allocator.alloc(allocator.data, &p, 4096);
@end example

@noindent
example of memory release:

@example
ucl_memory_allocator_t allocator;
void * p = ...;

allocator.alloc(allocator.data, &p, 0);
@end example

@c page
@node memory functions
@section Public interface


@defvar const ucl_memory_allocator_t ucl_memory_allocator
Predefined memory allocator.  Selects @cfunc{ucl_memory_alloc} as
allocation function.
@end defvar


@deftypefun void ucl_memory_alloc (void * @var{data}, void * @var{q}, size_t @var{dim})
Allocate, reallocate or free a block of memory using the standard
@cfunc{calloc}, @cfunc{realloc} and @cfunc{free} functions.  @var{data}
is ignored: it is perfectly correct to invoke this function with
@var{data} set to @cnull{}.

This function can be used as @code{alloc} function in a
@code{ucl_memory_allocator_t}.

The implementation is:

@example
void
ucl_memory_alloc (void * dummy, void * qq, size_t dim)
@{
  void **       pp = qq;
  void *        p;
  if (0 == dim) @{
    if (NULL != *pp) @{
      free(*pp);
      *pp = NULL;
    @}
  @} else @{
    p = (NULL == *pp)? calloc(1, dim) : realloc(*pp, dim);
    if (NULL == p) @{
      perror(strerror(errno));
      exit(EXIT_FAILURE);
    @}
    *pp = p;
  @}
@}
@end example
@end deftypefun


@deftypefun {void *} ucl_malloc (ucl_memory_allocator_t @var{allocator}, size_t @var{dim})
@deftypefunx {void *} ucl_realloc (ucl_memory_allocator_t @var{allocator}, void * @var{p}, size_t @var{dim})
@deftypefunx void ucl_free (ucl_memory_allocator_t @var{allocator}, void * @var{p})
These functions implement the classic alloc, realloc and free operations
using the selected allocator.
@end deftypefun


@c page
@node memory blocks
@section Memory blocks


This module offers a set of functions to handle memory blocks; its
purpose is to provide a small data structure (@code{ucl_block_t}) which
can be used directly as argument to function and return value from
function, instead of the couple: pointer to memory block, block length
in bytes.  All the functions are defined in the header @file{ucl.h} and
declared as @code{__inline__}.


@deftp {Struct Typedef} ucl_block_t
The type of memory block; fields description follows:

@table @code
@item size_t len
The number of bytes in the block; can be zero.

@item uint8_t * ptr
Pointer to the memory block or @cnull{}.
@end table

To initialise a block to empty state do this:

@example
ucl_block_t     B = @{ .ptr = NULL, .len = 0 @};
@end example

@noindent
or this:

@example
ucl_block_t     B;
ucl_block_reset(&B);
@end example
@end deftp

@c ------------------------------------------------------------

@subsubheading Memory allocation


@deftypefun ucl_block_t ucl_block_alloc (ucl_memory_allocator_t @var{allocator}, size_t @var{dim})
@deftypefunx ucl_block_t ucl_block_realloc (ucl_memory_allocator_t @var{allocator}, ucl_block_t @var{block}, size_t @var{new_dim})
Allocate or reallocate a memory block using the @var{allocator} and
return the resulting block.
@end deftypefun


@deftypefun void ucl_block_free (ucl_memory_allocator_t @var{allocator}, ucl_block_t @var{block})
If the @code{ptr} field of @var{block} is not @cnull{}: free the
referenced memory block using @var{allocator}.
@end deftypefun


@subsubheading Setting

@deftypefun void ucl_block_set (ucl_block_t * @var{block}, void * @var{ptr}, size_t @var{len})
Set the fields of the block structure.
@end deftypefun


@deftypefun void ucl_block_reset (ucl_block_t * @var{block})
Reset to zero all the fields of the block.
@end deftypefun


@subsubheading Inspection


@deftypefun bool ucl_block_is_null (ucl_block_t @var{block})
Return true if the @code{ptr} field of @var{block} is @cnull{}.
@end deftypefun


@subsubheading Memory operations


@deftypefun void ucl_block_clean_memory (ucl_block_t @var{block})
Reset to zero all the bytes in the memory block.
@end deftypefun


@subsubheading Block operations


@deftypefun void ucl_block_shift_x (ucl_block_t * @var{block}, ssize_t @var{offset}, size_t @var{dim})
Shift the memory reference in @var{block} by @var{offset} slots each of
@var{dim} bytes.  @var{offset} can be zero, positive or negative.
@end deftypefun


@deftypefun ucl_block_t ucl_block_shift (ucl_block_t @var{block}, ssize_t @var{offset}, size_t @var{dim})
Like @cfunc{ucl_block_shift_x}, but produce a new block.
@end deftypefun


@deftypefun ucl_block_t ucl_block_difference (ucl_block_t @var{a}, ucl_block_t @var{b})
This function assumes that @var{b} is contiguous to or included in
@var{a}; return a new block @var{c} referencing the first portion of
@var{a} not in @var{b}.

@example
          @var{c}.len             @var{b}.len
  |.........................|.................|

@var{c}.ptr                     @var{b}.ptr
  v                         v
  |-------------------------|---------------------|
  ^
@var{a}.ptr

  |...............................................|
                       @var{a}.len

@end example
@end deftypefun

@c page
@node memory ascii
@section Handling ASCII strings


This module offers a set of functions to handle @ascii{} coded, zero
terminated strings; its purpose is to provide a small data structure
(@code{ucl_ascii_t}) which can be used directly as argument to function
and return value from function, instead of the couple: pointer to memory
block, block length in bytes.  All the functions are defined in the
header @file{ucl.h} and declared as @code{__inline__}.


@deftp {Struct Typedef} ucl_ascii_t
The type of zero--terminated @ascii{} strings; fields description
follows:

@table @code
@item size_t len
The number of characters in the block; can be zero; it does @strong{not}
include the terminating null character.

@item char * ptr
Pointer to the memory block or @cnull{}; the last @code{char} must be
zero.
@end table

To initialise an ascii to empty state do this:

@example
ucl_ascii_t     A = @{ .ptr = NULL, .len = 0 @};
@end example

@noindent
or this:

@example
ucl_ascii_t     A;
ucl_ascii_reset(&A);
@end example

@noindent
or this:

@example
ucl_ascii_t     A = ucl_ascii_empty;
@end example
@end deftp


@deftp {Struct Typedef} ucl_ascii_list_t
Holds an array of @code{char *}.  Fields:

@table @code
@item size_t len
the number of strings;
@item char ** ptr
the array of pointers.
@end table
@end deftp


@deftypevar {const ucl_ascii_t} ucl_ascii_empty
Represent an empty string.  It is a statically allocated structure,
referencing a zero--terminated empty string.
@end deftypevar


@deftypefun void ucl_ascii_set (ucl_ascii_t * @var{ascii}, void * @var{ptr}, size_t @var{len})
Initialise the fields of a structure.
@end deftypefun


@deftypefun void ucl_ascii_reset (ucl_ascii_t * @var{ascii})
Reset to zero the fields.
@end deftypefun


@deftypefun ucl_ascii_t ucl_ascii_const (char * @var{string})
Build and return a structure initialised with @var{string}.  The length
is determined with the standard @function{strlen} function.
@end deftypefun


@deftypefun bool ucl_ascii_is_null (ucl_ascii_t @var{ascii})
Return true if the pointer field is set to @cnull{}.
@end deftypefun


@deftypefun ucl_bool_t ucl_ascii_is_terminated (ucl_ascii_t @var{ascii})
Return true if the string referenced by @var{ascii} is zero--terminated.
@end deftypefun


@deftypefun void ucl_ascii_clean_memory (ucl_ascii_t @var{ascii})
Reset the block of memory to zero bytes.
@end deftypefun


@deftypefun void ucl_ascii_terminate (ucl_ascii_t @var{ascii})
Make sure that the string referenced by @var{ascii} is zero--terminated.
@end deftypefun


@deftypefun ucl_block_t ucl_block_from_ascii (ucl_ascii_t @var{ascii})
Return a block initialised with the fields of an @ascii{} block.
@end deftypefun

@deftypefun ucl_ascii_t ucl_ascii_from_block (ucl_block_t @var{block})
Return an @ascii{} block initialised with the fields of a block.
@end deftypefun


@deftypefun ucl_ascii_t ucl_ascii_alloc (ucl_memory_allocator_t @var{allocator}, size_t @var{dim})
@deftypefunx ucl_ascii_t ucl_ascii_realloc (ucl_memory_allocator_t @var{allocator}, ucl_ascii_t @var{ascii}, size_t @var{new_dim})
Allocate or reallocate an @ascii{} block using @var{allocator};
@var{dim} and @var{new_dim} are the number of characters to be stored in
the block, with the @strong{exclusion} of the terminating zero.
@end deftypefun


@deftypefun void ucl_ascii_free (ucl_memory_allocator_t @var{allocator}, ucl_ascii_t @var{ascii})
If the @code{ptr} field of @var{ascii} is not @cnull{}: free the
referenced memory block using @var{allocator}.
@end deftypefun


@c page
@node memory macros
@section Miscellaneous macros


@subsection Structures


@defmac ucl_struct_clean (@var{struct_p}, @var{type})
@defmacx ucl_struct_reset (@var{struct_p}, @var{type})
Reset to zero, using @function{memset}, the structure of @var{type}
pointed to by @var{struct_p}.
@end defmac


@defmac ucl_struct_alloc (ucl_memory_allocator_t @var{allocator}, void * @var{p}, @var{type})
Allocate a new structure of @var{type} using @var{allocator} and store a
pointer to it in @var{p}.  Example:

@example
typedef struct a_t @{
  int      i;
@} a_t;

a_t * p;

ucl_struct_alloc(allocator, p, a_t);
@end example
@end defmac

@c page
@node typedefs
@chapter Data types you have to know


The types of container structures and links/nodes are described in the
sections dedicated to containers.  Here common data types are described.

@menu
* typedefs value::              Collected values and others.
* typedefs ranges::             Range selectors.
* typedefs compar::             Comparison functions.
* typedefs hash::               Hash functions.
* typedefs callback::           Callback functions.
* typedefs nodes::              Wrapping node structures.
@end menu

@c page
@node typedefs value
@section Collected values and others


@deftp {Union Typedef} ucl_value_t
The data type of objects that can be stored in the containers; it's a
@code{union} with the following members:

@table @code
@item char t_char
@itemx unsigned char t_unsigned_char
@itemx int t_int
@itemx unsigned int t_unsigned_int
@itemx long t_long
@itemx unsigned long t_unsigned_long
@itemx int8_t t_int8
@itemx uint8_t t_uint8
@itemx int16_t t_int16
@itemx uint16_t t_uint16
@itemx int32_t t_int32
@itemx uint32_t t_uint32
One field for each built in C language type.

@itemx size_t t_size
@itemx ssize_t t_ssize
@itemx intptr_t t_intptr
@itemx uintptr_t t_uintptr
Fields for miscellaneous types.

@item void * ptr
@itemx void * pointer
@itemx uint8_t * bytes
@itemx char * chars
Fields for miscellaneous pointer types.
@end table
@end deftp


@deftypevar {const ucl_value_t} ucl_value_null
Constant value representing the null @code{ucl_value_t}; its fields are
set to zero.
@end deftypevar


@deftp {Alias Typedef} ucl_bool_t
Alias for @code{_Bool}, which is defined by the C99 standard.  The
standard defines also the @code{true} and @code{false} values (in the
@file{stdbool.h} header).
@end deftp


@deftp {Alias Typedef} ucl_index_t
Alias for @code{size_t}.
@end deftp


@deftp {Struct Typedef} ucl_array_of_pointers_t
Array of pointers.  Public fields:

@table @code
@item void ** slots
pointer to an array of pointers: @code{void *}; this type implies no
assumption upon the origin of the array memory, it can be statically or
dynamically allocated, or it can be on the stack;

@item size_t number_of_slots
the number of elements in @code{slots};

@item ucl_value_t data;
custom value that can be used to store a context associated to the
array; this field is useful when we need to hand a pointer to an array
to some function like a callback.
@end table
@end deftp

@c ------------------------------------------------------------

@subsubheading Temporary linked lists

Let's say that we want to preallocate a set of structures to be used
with the @ucl{}, for example: @code{ucl_list_link_t}, the structure
representing a node in the @ucl{}'s doubly linked list.  We allocate them
with code like:

@example
#define NUMBER_OF_PREALLOCATED_STRUCTS          4096
ucl_memory_allocator    allocator;
ucl_list_link_t *       link_p;

for (size_t i=0; i<NUMBER_OF_PREALLOCATED_STRUCTS; ++i) @{
  link_p = NULL;
  allocator.alloc(allocator.data, &link_p, sizeof(ucl_list_link_t));
  /* here we have to put the links somewhere */
@}
@end example

@noindent
it can be convenient to put the links in a linked list and extract them
at usage time.  We do not want to use the @code{ucl_list_t} container,
because it is overkill for this application, so we can use the following
special type.


@deftp {Struct Typedef} ucl_link_t
A structure with a single field, @code{ucl_link_t * next_p}, to be used
to collect structures in a linked list.
@end deftp


With it the preallocation code looks like this:

@example
#define NUMBER_OF_PREALLOCATED_STRUCTS          4096
ucl_memory_allocator    allocator;
ucl_link_t *            link_list_p = NULL;


@{
  ucl_link_t *          link_p;


  for (size_t i=0; i<NUMBER_OF_PREALLOCATED_STRUCTS; ++i)
    @{
      link_p = NULL;
      allocator.alloc(allocator.data, &link_p, sizeof(ucl_list_link_t));
      if (link_list_p)
        @{
          link_p->next_p = link_list_p;
          link_list_p    = link_p;
        @}
      else
        @{
          link_list_p = link_p;
          link_list_p->next_p = NULL; /* just to be sure */
        @}
    @}
@}
@end example

@noindent
to extract the links we do:

@example
ucl_link_t *            link_p;
ucl_link_t *            link_list_p;
ucl_list_link_t *       list_link_p;

...

if (link_list_p)
  @{
    link_p = link_list_p;
    link_list_p = link_p->next_p;
    list_link_p = (ucl_list_link_t *)link_p;
    /* here we can use 'list_link_p' */
  @}
else
  @{
    /* no more preallocated links */
  @}
@end example

@noindent
and to put them back:

@example
ucl_link_t *            link_p;
ucl_link_t *            link_list_p;

...

if (link_list_p)
  @{
    link_p->next_p = link_list_p;
    link_list_p    = link_p;
  @}
else
  @{
    link_list_p = link_p;
    link_list_p->next_p = NULL;
  @}
@end example

With better memory allocation:

@example
#define NUMBER_OF_PREALLOCATED_STRUCTS          4096
#define SIZE_OF_PREALLOCATED_MEMORY             \
  (NUMBER_OF_PREALLOCATED_STRUCTS * sizeof(ucl_list_link_t))

ucl_memory_allocator    allocator;
void *                  preallocated_links = NULL;
ucl_link_t *            link_list_p;


/* let's assume that this allocator initialises the
   block to zero bytes */
allocator.alloc(allocator.data, &preallocated_links,
                SIZE_OF_PREALLOCATED_MEMORY);

@{
  ucl_link_t *          link_p;


  link_p = link_list_p = preallocated_links;
  for (size_t i=0; i<NUMBER_OF_PREALLOCATED_STRUCTS-1; ++i)
    @{
      link_p->next_p = link_p + sizeof(ucl_list_link_t);
      link_p = link_p->next_p;
    @}
@}
@end example

@c page
@node typedefs ranges
@section Range selectors


@center @strong{RANGES ARE INCLUSIVE}

@noindent
All these macros accept as @var{range} arguments the name of a range
structure, @strong{not} the name of a pointer to the structure.  Range
stuff is written in macros, not @code{__inline__} functions, so that
they work with all the type structures defined below.


@deftp {Struct Typedef} ucl_range_t
Data type used to describe a range of elements in a sequence, by
selecting the indexes.  The fields are of type @code{size_t}.
@end deftp


@deftp {Struct Typedef} ucl_char_range_t
@deftpx {Struct Typedef} ucl_unsigned_char_range_t
@deftpx {Struct Typedef} ucl_int_range_t
@deftpx {Struct Typedef} ucl_unsigned_range_t
@deftpx {Struct Typedef} ucl_long_range_t
@deftpx {Struct Typedef} ucl_unsigned_long_range_t
@deftpx {Struct Typedef} ucl_size_t_range_t
@deftpx {Struct Typedef} ucl_float_range_t
@deftpx {Struct Typedef} ucl_double_range_t
@deftpx {Struct Typedef} ucl_byte_pointer_range_t
@deftpx {Struct Typedef} ucl_pointer_range_t
Ranges of values.
@end deftp


@defmac ucl_range_set_min_max (@var{range}, @var{min}, @var{max})
Initialise the min and max fields.
@end defmac

@defmac ucl_range_set_min_size (@var{range}, @var{min}, @var{size})
Initialise the min and sets the max to: @code{@var{min}+@var{size}-1}.
@end defmac

@defmac ucl_range_set_max_size (@var{range}, @var{max}, @var{size})
Initialise the max and sets the min to: @code{@var{max}-@var{size}+1}.
@end defmac

@defmac ucl_range_set_size_on_min (@var{range},  @var{size})
Set the max to: @code{@var{min}+@var{size}-1}.
@end defmac

@defmac ucl_range_set_size_on_max (@var{range},  @var{size})
Set the min to: @code{@var{max}-@var{size}+1}.
@end defmac

@defmac ucl_range_size (@var{range})
Evaluate to the size of the range.
@end defmac

@defmac ucl_range_is_empty (@var{range})
Evaluate to true if @var{range} is empty.
@end defmac

@defmac ucl_range_min (@var{range})
Evaluate to the min.
@end defmac

@defmac ucl_range_max (@var{range})
Evaluate to the max.
@end defmac

@defmac ucl_range_value_is_in (@var{range}, @var{value})
Evaluate to true if the value is inside the range.
@end defmac

@defmac ucl_range_value_is_out (@var{range}, @var{value})
Evaluate to true if the value is outside the range.
@end defmac

@defmac ucl_range_equal (@var{range_a}, @var{range_b})
Evaluate to true if the ranges are equal.
@end defmac

@c page
@node typedefs compar
@section Comparison functions


@deftp {Struct Typedef} ucl_comparison_t
Structure holding a policy for values comparison.  Fields:

@table @code
@item ucl_value_t data
context to be used as first argument to the function;

@item ucl_comparison_fun_t * func
pointer to the function that compares two values of type
@code{ucl_value_t}.
@end table
@end deftp


@deftypefn {Function Typedef} int ucl_comparison_fun_t (ucl_value_t @var{data}, ucl_value_t @var{a}, ucl_value_t @var{b})
The type of functions used to compare values.  Functions of this type
are used by the associative containers.

The behaviour of the function must be the one of the standard function
@function{strcmp}: return @code{-1} if @code{a<b}, return @code{0} if
@code{a==b}, return @code{1} if @code{a>b}.

The function has the responsibility to provide the comparison policy: to
select a field in the @code{ucl_value_t} unions and establish when a
value is formally greater than the other.
@end deftypefn


Example:

@example
ucl_comparison_fun_t    intcmp;
ucl_comparison_t        compar = @{
  .data = NULL, .func = intcmp
@};
ucl_value_t             a = ...;
ucl_value_t             b = ...;
int                     result;

result = compar.func(compar.data, a, b);
@end example

@c page
@node typedefs hash
@section Hash functions


@deftp {Struct Typedef} ucl_hash_t
Structure holding the hash function and its context.  Fields:

@table @code
@item ucl_value_t data
a context to be used as first argument to the function;

@item ucl_hash_fun_t * func
pointer to the function that computes the hash value.
@end table
@end deftp


@deftypefn {Function Typedef} ucl_index_t ucl_hash_fun_t (ucl_value_t @var{data}, ucl_value_t @var{key})
Type of hash functions used by the hash table.  The return value must be
the ``position'' of the key in a vector.  @ref{hash} for details.
@end deftypefn

@c page
@node typedefs callback
@section Callback functions


@deftp {Struct Typedef} ucl_callback_t
Holds a function pointer and a context value.  Public fields:

@table @code
@item ucl_callback_fun_t * func
pointer to the callback function;
@item ucl_value_t data
the context value.
@end table

To initialise a @code{ucl_callback_t} structure we can do:

@example
ucl_callback_t cb = @{
  .func = pointer_to_function,
  .data = @{ .ptr = pointer_to_data @}
@};
@end example

@noindent
to initialise to no--function and no--data:

@example
ucl_callback_t cb = ucl_callback_null;
@end example

Example of callback invocation:

@example
ucl_callback_t  cb = ...;
int             a  = 123;
int             b  = 456;

ucl_callback_apply(cb, a, b);
@end example
@end deftp


@deftypevar {const ucl_callback_t} ucl_callback_null
Statically allocated structure representing a null callback.
@end deftypevar


@deftypefn {Function Prototype} ucl_value_t ucl_callback_fun_t (ucl_value_t @var{context}, va_list @var{ap})
Callback function.  @var{context} is the value stored in the callback
structure, representing the callback context.  @var{ap} is the list of
arguments: it is responsibility of the function to know how to interpret
them.
@end deftypefn


@deftypefn {Inline Function} ucl_bool_t ucl_callback_is_present (ucl_callback_t @var{cb})
Return true if the @code{func} field of @var{cb} is not @cnull{}.
@end deftypefn


@deftypefun ucl_value_t ucl_callback_apply (ucl_callback_t @var{cb}, ...)
If @function{ucl_callback_is_present} applied to @var{cb} evaluates to
true: invoke the callback function using the callback context as first
argument and a @code{va_list} as second argument; the @code{va_list}
will hold references to the arguments to this function.  Return the
return value of the callback function.

If the callback function is not present nothing happens and the return
value is a @code{ucl_value_t} with all the bytes set to zero.
@end deftypefun


@deftypefun ucl_value_t ucl_callback_eval_thunk (ucl_callback_t @var{cb})
Like @function{ucl_callback_invoke} but the @code{va_list} argument is
replaced by @cnull{}.  Return the return value of the callback function.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Custom callback application


The @ucl{} does not support any error reporting mechanism; this means
that @function{ucl_callback_apply} does not expect the callback to fail.
To avoid problems all the @ucl{} modules that need to apply a callback
to arguments, do so by invoking a customisable function and are written
in such a way that if the callback raises an exception nothing bad
happens.  The following @api{} handles this.


@deftypefn {Function Prototype} ucl_value_t ucl_callback_apply_fun_t (ucl_callback_t @var{callback}, ...)
The prototype of functions that apply a callback to a list of arguments.
@function{ucl_callback_apply} has this prototype.
@end deftypefn


@deftypefun void ucl_callback_set_application_function (ucl_callback_apply_fun_t * @var{f})
Register in @ucl{} a new function for the application of callbacks to
arguments; it will be used by all the @ucl{} functions that invoke a
callback.  The default application function is
@function{ucl_callback_apply}.
@end deftypefun

@c page
@node typedefs nodes
@section Wrapping node structures


@deftypefn {Function Prototype} ucl_value_t ucl_node_getkey_fun_t (ucl_value_t @var{context}, void * @var{node})
Type of function which, applied to a pointer to node, returns the key
(or a reference to the key) associated to the node.
@end deftypefn


@deftp {Struct Typedef} ucl_node_getkey_t
Structure holding the method used to extract the key from a node.  It
has the following fields:

@table @code
@item ucl_value_t data
Custom data value.

@item ucl_node_getkey_fun_t * func
Pointer to the function used to extract the key.
@end table
@end deftp


The following is a usage example:

@example
typedef struct link_tag_t @{
  ucl_node_tag_t        node;
  ucl_value_t           key;
@} link_tag_t;

typedef link_tag_t *        link_t;

static ucl_value_t
link_key (ucl_value_t context UCL_UNUSED, void * L_)
@{
  link_t    L = L_;
  return L->key;
@}

static const ucl_node_getkey_t getkey = @{
  .data = @{ .pointer = NULL @},
  .func = link_key
@};
@end example

@noindent
we can use the key extractor directly like this:

@example
link_t          L;
ucl_value_t     K;

K = getkey.func(getkey.data, L);
@end example

@c page
@node containers
@chapter The data structures


@menu
* btree::                       The binary tree structure.
* tree::                        The tree structure.
* circular::                    The circular list structure.
* graph::                       The graph structure.
* hash::                        The hash table structure.
* heap::                        The heap structure.
* list::                        The linked list structure.
* map::                         The map structure.
* vector::                      The vector structure.
@end menu

@c page
@node btree
@section The binary tree container


@cindex Binary tree container


@menu
* btree typedefs::              Implementation and type definitions.
* btree examples::              Usage examples.
* btree creation::              Building btree hierarchies.
* btree inspection::            Accessing nodes.
* btree removing::              Removing elements.
* btree find::                  Finding values.
* btree swap::                  Swapping nodes.
* btree visitors::              Finding nodes.
* btree iteration::             Iterations in a btree hierarchy.
* btree bst::                   Routines for raw binary search trees.
* btree avl::                   Routines for @avl{} trees.
@end menu

@c page
@node btree typedefs
@subsection Implementation and type definitions


This section presents an implementation of binary tree; the container is
a chain of structures:

@example
  ------  bro   ------
 | node |----->| node |
 |   1  |<-----|   2  |
  ------  dad   ------
   | ^
son| |dad
   v |
  ------
 | node |
 |   3  |
  ------
@end example

@noindent
each node data structure is a collection of pointers and of metadata
fields whose usage is reserved by @ucl{}; there's no data field.


@deftp {Struct Typedef} ucl_node_tag_t
@deftpx {Pointer Typedef} ucl_node_t
The data type of the node structure and of the pointer to the node
structure; nodes must be allocated and freed by client code.  Public
fields:

@table @code
@item ucl_node_t dad
pointer to the parent of this node; @cnull{} if this node has no parent;

@item ucl_node_t son
pointer to the son of this node; @cnull{} if this node has no son;

@item ucl_node_t bro
pointer to the bro of this node; @cnull{} if this node has no bro.
@end table
@end deftp


@defmac UCL_NODE_SIZE
The size in bytes of the structure @code{ucl_node_tag_t}.
@end defmac

@c page
@node btree examples
@subsection Usage examples


Let's say we want to organise a set of characters in a binary tree; we
define the tree node type and allocation functions like these:

@example
typedef struct node_tag_t @{
  ucl_node_tag_t  node;
  char            c;
@} node_tag_t;

typedef node_tag_t *    node_t;

ucl_memory_allocator_t  A = @{
  .data  = NULL,
  .alloc = ucl_memory_alloc
@};

node_t
node_make (char c)
@{
  node_t        p = NULL;

  A.alloc(A.data, &p, sizeof(node_tag_t));
  p->c = c;
  return p;
@}
void
node_final (node_t p)
@{
  A.alloc(A.data, &p, 0);
@}
__inline__ void
node_clean (node_t p)
@{
  ucl_struct_clean(p, node_tag_t);
@}
@end example

@noindent
and we remember that the built in @ucl{} allocation function
(@cfunc{ucl_memory_alloc}) sets to zero all the bytes of newly allocated
blocks.

We define the getter/setter functions in ``generic'' form, like these:

@example
__inline__ void
node_set (node_t p, void * data)
@{
  p->c = *((char *)data);
@}
__inline__ void *
node_get (node_t p)
@{
  return &(p->c);
@}
@end example

Now if we want the following hierarchy:

@example
       ---  bro  ---
      | a |---->| c |
       ---       ---
        |         |
    son v     son v
       ---       ---
      | b |     | d |
       ---       ---
@end example

@noindent
we do it like this, taking advantage of the fact that the binary tree
functions accept @code{void *} values as arguments:

@example
node_t  a, b, c, d;

a = node_make('a');
b = node_make('b');
c = node_make('c');
d = node_make('d');

ucl_btree_dadson(a, b);
ucl_btree_dadbro(a, c);
ucl_btree_dadson(c, d);
@end example

@noindent
the following expressions are true:

@example
NULL == ucl_btree_getdad(a)
a    == ucl_btree_getdad(b)
a    == ucl_btree_getdad(c)
c    == ucl_btree_getdad(d)

c    == ucl_btree_getbro(a)
NULL == ucl_btree_getbro(b)
NULL == ucl_btree_getbro(c)
NULL == ucl_btree_getbro(d)

b    == ucl_btree_getson(a)
NULL == ucl_btree_getson(b)
d    == ucl_btree_getson(c)
NULL == ucl_btree_getson(d)
@end example

@c page
@node btree creation
@subsection Building btrees hierarchies


The correct way of building binary trees is to allocate node structures
with a function that cleans them up, like @function{calloc}, then use
the following functions to initialise the fields.  If a structure is
recycled, we must reset its fields to zero first.

All the following functions accept @code{void *} values as arguments:
internally these pointers are cast to @code{ucl_node_t}.

@c ------------------------------------------------------------

@subsubheading Single link setters


@deftypefn {Inline Function} void ucl_btree_set_dad (void * @var{self}, void * @var{dad})
Select a new parent node for @var{self}.
@end deftypefn


@deftypefn {Inline Function} void ucl_btree_set_bro (void * @var{self}, void * @var{bro})
Select a new brother node for @var{self}.
@end deftypefn


@deftypefn {Inline Function} void ucl_btree_set_son (void * @var{self}, void * @var{son})
Select a new child node for @var{self}.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Double link setters


@deftypefn {Inline Function} void ucl_btree_set_dadson (void * @var{dad}, void * @var{son})
Link @var{dad} and @var{son} to be the parent and the son respectively.
@end deftypefn


@deftypefn {Inline Function} void ucl_btree_set_dadbro (void * @var{dad}, void * @var{bro})
Link @var{dad} and @var{bro} to be the parent and the bro respectively.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Triple link setters


@deftypefn {Inline Function} void ucl_btree_set_dadsonbro (void * @var{dad}, void * @var{son}, void * @var{bro})
Link @var{dad}, @var{son} and @var{bro} to be the parent, the son and
the bro respectively.
@end deftypefn

@c page
@node btree inspection
@subsection Accessing nodes


All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefn {Inline Function} {void *} ucl_btree_ref_dad (void * @var{self})
Return a pointer to the parent of @var{self} or @cnull{} if the node
has no parent.
@end deftypefn


@deftypefn {Inline Function} {void *} ucl_btree_ref_bro (void * @var{self})
Return a pointer to the brother of @var{self} or @cnull{} if the node has
no brother.
@end deftypefn


@deftypefn {Inline Function} {void *} ucl_btree_ref_son (void * @var{self})
Return a pointer to the son of @var{self} or @cnull{} if the node has no
son.
@end deftypefn


@deftypefn {Inline Function} {void *} ucl_btree_data (void * @var{self})
Assuming that the first field of the memory block referenced by
@var{self} is a structure of type @code{ucl_node_tag_t}, return a
pointer to the first byte after that structure.  The returned pointer
references the first byte of the data area of the tree node.
@end deftypefn


@deftypefn {Inline Function} ucl_bool_t ucl_btree_is_leaf (void * @var{self})
Return true if the node is a leaf (no brother and no son).
@end deftypefn


@deftypefn {Inline Function} ucl_bool_t ucl_btree_is_root (void * @var{self})
Return true if the node is the root of a binary tree: it has no dad.
@end deftypefn


@deftypefun int ucl_btree_depth (void * @var{N})
Function with recursive implementation which computes the depth of the
tree having @var{N} as root, @var{N} included.
@end deftypefun

@c page
@node btree removing
@subsection Removing elements


It's a matter of setting pointers to @cnull{}; care must be taken not to
loose references to subtrees.

All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefn {Inline Function} {void *} ucl_btree_detach_son (void * @var{self})
Detach the son of @var{self} and return a pointer to it.  The two nodes
hold references to each other no more.
@end deftypefn


@deftypefn {Inline Function} {void *} ucl_btree_detach_bro (void * @var{self})
Detach the bro of @var{self} and return a pointer to it.  The two nodes
hold references to each other no more.
@end deftypefn


@deftypefn {Inline Function} {void *} ucl_btree_detach_dad (void * @var{self})
Detach the dad of @var{self} and return a pointer to it.  The two nodes
hold references to each other no more.
@end deftypefn


@deftypefun void ucl_btree_clean (void * @var{self})
Set to zero all the bytes in the node structure.
@end deftypefun

@c page
@node btree find
@subsection Finding values


The purpose of a binary tree is to organise values in a hierarchy; the
functions described in this section can be used to find values.

The following function accepts @code{void *} values as arguments and
return a @code{void *} value; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefun {void *} ucl_btree_find_value (void * @var{root}, ucl_value_t @var{value}, ucl_comparison_t @var{compar})
Interpret @var{root} as a pointer to the root node of a btree (whose dad
is @cnull{}) and find a node equal to @var{value} according to the
comparison closure.  @var{compar} is invoked like this:

@example
ucl_node_t  N = ...;
ucl_value_t D = @{ .pointer = N @};

@var{compar}.func(@var{compar}.data, @var{value}, D);
@end example

@noindent
where @code{N} is the current node in the search; if the return value
is:

@table @asis
@item zero
the node is returned;
@item negative
the search goes on in the son subtree;
@item positive
the search goes on in the bro subtree;
@end table

@noindent
if @var{value} is not found, the return value is @cnull{}.
@end deftypefun

@c page
@node btree swap
@subsection Swapping nodes


The following function accepts @code{void *} values as arguments and
return a @code{void *} value; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefun void ucl_btree_swap_out (void * @var{A}, void * @var{B})
Given two pointers to nodes, interpret @var{A} as pointer to a node in a
tree and @var{B} as pointer to a node @strong{out of any tree}; store
the links and meta value of @var{A} into @var{B}, then resets the links
and meta value of @var{A}.
@end deftypefun


@deftypefun void ucl_btree_swap (void * @var{A}, void * @var{B})
Given two pointers to nodes, swap the links and the meta value in the
node structures.  Take care of the fact that @var{A} and @var{B} may
reference each other.
@end deftypefun

@c page
@node btree visitors
@subsection Finding nodes


All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefun {void *} ucl_btree_find_leftmost (void * @var{self})
Find the leftmost node in the subtree of the supplied node.  To do this,
we traverse the tree choosing always the son of the current node.

Example:

@example
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
starting from @code{5} the selected node is @code{1}, starting from
@code{10} the selected node is @code{6}.

Return a pointer to the leftmost node in the @var{self} sub--hierarchy
or to @var{self} itself if it has no son.
@end deftypefun


@deftypefun {void *} ucl_btree_find_rightmost (void * @var{self})
Find the rightmost node in the subtree of the supplied node.  To do this,
we traverse the tree choosing always the brother of the current node.

Example:

@example
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
starting from @code{5} the selected node is @code{12}, starting from
@code{7} the selected node is @code{9}.

Return a pointer to the rightmost node in the @var{self} sub--hierarchy
or to @var{self} itself if it has no brother.
@end deftypefun


@deftypefun {void *} ucl_btree_find_deepest_son (void * @var{self})
Find the deepest leftmost son in a subtree.  This is different from
@function{ucl_btree_find_leftmost}.

Example:

@example
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
starting from @code{5} the selected node is @code{2}, starting from
@code{10} the selected node is @code{6}.

Return a pointer to the deepest son in the @var{self} sub--hierarchy, or
@var{self} itself if it has no son.
@end deftypefun


@deftypefun {void *} ucl_btree_find_deepest_bro (void * @var{self})
Find the deepest rightmost bro in a subtree.  This is different from
@function{ucl_btree_find_rightmost}.

Example:

@example
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
starting from @code{5} the selected node is @code{11}, starting from
@code{1} the selected node is @code{4}.

Return a pointer to the deepest bro in the @var{self} sub--hierarchy, or
@var{self} itself if it has no son.
@end deftypefun


@deftypefun {void *} ucl_btree_find_root (void * @var{node})
Step up the hierarchy, dad by dad, and return a pointer to a node that
has @cnull{} as dad.
@end deftypefun

@c page
@node btree iteration
@subsection Iterations in a btree hierarchy


@menu
* btree inorder iteration::     Inorder iteration.
* btree preorder iteration::    Preorder iteration.
* btree postorder iteration::   Postorder iteration.
* btree breadth first::         Breadth first iteration.
@end menu

@c page
@node btree inorder iteration
@subsubsection Inorder iteration


Forward inorder iteration: visit all the nodes from the leftmost to the
rightmost.  Backward inorder iteration: visit all the nodes from the
rightmost to the leftmost.  Example: given the tree:

@example
5-------10----12
|        |     |
1--3--4  7--9 11
   |     |  |
   2     6  8
@end example

@noindent
the inorder iteration is:

@example
forward:   1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12
backward: 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1
@end example

All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefn {Inline Function} {void *} ucl_btree_first_inorder (void * @var{root})
@deftypefnx {Inline Function} {void *} ucl_btree_first_inorder_backward (void * @var{root})
Given a pointer to the root node of a tree, return the first node of an
inorder iteration.  For the forward iteration: it is the leftmost node;
for the backward iteration: it is the rightmost node.
@end deftypefn


@deftypefun {void *} ucl_btree_step_inorder (void * @var{current})
@deftypefunx {void *} ucl_btree_step_inorder_backward (void * @var{current})
Advance an inorder iteration.  Given a pointer to a node in a tree:
perform a single step and return a pointer to the next node, or @cnull{}
if the iteration is over.
@end deftypefun


@deftypefun void ucl_btree_iterator_inorder (ucl_iterator_t @var{iter}, void * @var{root})
@deftypefunx void ucl_btree_iterator_inorder_backward (ucl_iterator_t @var{iter}, void * @var{root})
Initialise a whole tree iterator; @var{root} must be the root node of a
btree.
@end deftypefun


@deftypefun void ucl_btree_subtree_iterator_inorder (ucl_iterator_t @var{iter}, void * @var{node})
@deftypefunx void ucl_btree_subtree_iterator_inorder_backward (ucl_iterator_t @var{iter}, void * @var{node})
Initialise a subtree iterator; @var{node} must be the a node of a btree,
and will be used as root node of the subtree.
@end deftypefun


@deftypefun void ucl_btree_range_iterator_inorder (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
@deftypefunx void ucl_btree_range_iterator_inorder_backward (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
Initialise a range iterator over the range of nodes selected by
@var{range} (remember that ranges are inclusive); the minimum field of
@var{range} is interpreted as the starting node of the iteration, while
the maximum field of @var{range} is interpreted as the ending node of
the iteration.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Examples of forward iteration


To perform a complete forward inorder iteration, we have to start from
the leftmost node (@code{0} in the picture above), already visited, and
begin from there.  Example:

@example
ucl_node_t   cur = get_the_top_node();

for (cur = ucl_btree_find_leftmost(cur);
     cur;
     cur = ucl_btree_step_inorder(cur));
  @{
    do_something_with(cur);
  @}
@end example

To restrict the iteration to a subtree of a tree or to a range of nodes
in a tree, we have to select the first and last nodes and check when the
iterator reaches the last.

Example of subtree restriction: does an inorder iteration from the top
of a subtree to the rightmost node in the subtree:

@example
ucl_node_t        cur, end;

cur = get_a_node(...);
end = ucl_btree_find_rightmost(cur);

for (cur = ucl_btree_find_leftmost(cur);
     cur != end;
     cur = ucl_btree_step_inorder(cur))
  @{
    do_something_with(cur);
  @}

/* Here "cur == end" and we visit it. */
do_something_with(cur);
@end example

@noindent
@code{cur} can't be @cnull{} because @code{end} is in the subtree of the
top node; this code will work even when @code{cur == end} at the
beginning.

Example of range restriction: does an iteration starting from a node
(not the leftmost) to the rightmost one:

@example
ucl_node_t        root, cur, end;

root	= get_a_node();
end	= ucl_btree_find_rightmost(root);

for (cur = select_first(root, ...);
     cur != end;
     cur = ucl_btree_step_inorder(cur))
  @{
    do_something_with(cur);
  @}
@end example

@noindent
@code{cur} can't be @cnull{} because we selected the first and last nodes
in a subtree; this code will work even when @code{root == cur == end} at
the beginning.

@c ------------------------------------------------------------

@subsubheading Examples of backward iteration

To perform a complete backward iteration, we have to start from the
rightmost node (@code{12} in the picture above), already visited, and
begin from there.  Example:

@example
ucl_node_t   cur = get_the_top_node();

for (cur = ucl_btree_find_rightmost(cur);
     cur;
     cur = ucl_btree_step_inorder_backward(cur))
  @{
    do_something_with(cur);
  @}
@end example

To restrict the iteration to a subtree of a tree or to a range of nodes
in a tree, we have to select the first and last nodes and check when the
iterator reaches the last.

Example of subtree restriction: does an iteration from the rightmost to
the leftmost nodes in a subtree:

@example
ucl_node_t        cur, end;

cur = get_a_node(...);
end = ucl_btree_find_leftmost(cur);

for (cur = ucl_btree_find_rightmost(cur);
     cur != end;
     cur = ucl_btree_step_inorder_backward(cur))
  @{
    do_something_with(cur);
  @}

/* Here "cur == end" and we visit it. */
do_something_with(cur);
@end example

@noindent
@code{cur} can't be @cnull{} because @code{end} is in the subtree of the
top node; this code will work even when @code{cur == end} at the
beginning.

Example of range restriction:

@example
ucl_node_t        root, cur, end;

root	= get_a_node();
end	= ucl_btree_find_leftmost(root);

for (cur = select_first(root, ...);
     cur != end;
     cur = ucl_btree_step_inorder_backward(cur))
  @{
    do_something_with(cur);
  @}

/* Here "cur == end" and we visit it. */
do_something_with(cur);
@end example

@noindent
@code{cur} can't be @cnull{} since we selected the first and last nodes
in a subtree; this code will work even when @code{root == cur == end} a
the beginning.

@c page
@node btree preorder iteration
@subsubsection Preorder iteration


Preorder iteration: visit the current node then the son then the
brother.  Example:

@example
5-------10----12
|        |     |
1--3--4  7--9 11
   |     |  |
   2     6  8
@end example

@noindent
the preorder iteration is:

@example
forward:    5,  1,  3,  2,  4, 10,  7,  6,  9,  8, 12, 11
backward:   5, 10, 12, 11,  7,  9,  8,  6,  1,  3,  4,  2
@end example

@noindent
the forward iteration is a ``worm that always turns right'', while the
backward iteration is a ``worm that always turns left''.

All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefn {Inline Function} {void *} ucl_btree_first_preorder (void * @var{root})
@deftypefnx {Inline Function} {void *} ucl_btree_first_preorder_backward (void * @var{root})
Given a pointer to the root node of a tree, return the first node of a
preorder iteration.  For both the forward and backward iterations: it is
the root node itself.
@end deftypefn


@deftypefun {void *} ucl_btree_step_preorder (void * @var{current})
@deftypefunx {void *} ucl_btree_step_preorder_backward (void * @var{current})
Advance a preorder iteration.  Given a node in a btree: perform a single
step and return a pointer to the next node, or @cnull{} if the iteration
is over.
@end deftypefun


@deftypefun void ucl_btree_iterator_preorder (ucl_iterator_t @var{iter}, void * @var{root})
@deftypefunx void ucl_btree_iterator_preorder_backward (ucl_iterator_t @var{iter}, void * @var{root})
Initialise a whole tree iterator; @var{root} must be the root node of a
btree.
@end deftypefun


@deftypefun void ucl_btree_subtree_iterator_preorder (ucl_iterator_t @var{iter}, void * @var{node})
@deftypefunx void ucl_btree_subtree_iterator_preorder_backward (ucl_iterator_t @var{iter}, void * @var{node})
Initialise a subtree iterator; @var{node} must be the a node of a btree,
and will be used as root node of the subtree.
@end deftypefun


@deftypefun void ucl_btree_range_iterator_preorder (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
@deftypefunx void ucl_btree_range_iterator_preorder_backward (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
Initialise a range iterator over the range of nodes selected by
@var{range} (remember that ranges are inclusive); the minimum field of
@var{range} is interpreted as the starting node of the iteration, while
the maximum field of @var{range} is interpreted as the ending node of
the iteration.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Examples of forward iteration

To perform a complete iteration, we have to start from the top node of
the tree (@code{5} in the picture above), already visited, and begin
from there.  Example:

@example
ucl_node_t        cur;

for (cur = select_the_top_node();
     cur;
     cur = ucl_btree_step_pre(cur))
  @{
    do_something_with(cur);
  @}
@end example

@noindent
this works because the top node of a btree has a @cnull{} value in the
dad pointer field.

To restrict the iteration to a subtree of a tree: we cannot loop until
the function returns @cnull{}, because the top node of a subtree has a
non--@cnull{} value in the dad pointer field.  With reference to the
picture above: we select the top node (number 10) and we visit it; then
we step to the next (number 7) and visit it; then we enter the loop
until the iterator reaches the top node (number 10 again).

Example:

@example
ucl_node_t        cur, end;

end = cur = get_a_node();

do_something_with(cur);
for (cur = ucl_btree_step_preorder(cur);
     cur != end;
     cur = ucl_btree_step_preorder(cur))
  @{
    do_something_with(cur);
  @}
@end example

@c page
@node btree postorder iteration
@subsubsection Postorder iteration


Postorder iteration: visit the son, then the brother, then the parent
node.  Example:

@example
5-------10----12
|        |     |
1--3--4  7--9 11
   |     |  |
   2     6  8
@end example

@noindent
the postorder iteration is:

@example
forward:    2,  4,  3,  1,  6,  8,  9,  7, 11, 12, 10,  5
backward:  11, 12,  8,  9,  6,  7, 10,  4,  2,  3,  1,  5
@end example

All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefn {Inline Function} {void *} ucl_btree_first_postorder (void * @var{root})
@deftypefnx {Inline Function} {void *} ucl_btree_first_postorder_backward (void * @var{root})
Given a pointer to the root node of a tree, return the first node of a
postorder iteration.  For the forward iteration: it is the deepest son
found by @function{ucl_btree_find_deepest_son}; for the backward
iteration: it is the deepest bro found by
@function{ucl_btree_find_deepest_bro}.
@end deftypefn


@deftypefun {void *} ucl_btree_step_postorder (void * @var{current})
@deftypefunx {void *} ucl_btree_step_postorder_backward (void * @var{current})
Advance a forward postorder iteration.  Given a node in a btree: perform
a single step and return a pointer to the next node, or @cnull{} if the
iteration is over.
@end deftypefun


@deftypefun void ucl_btree_iterator_postorder (ucl_iterator_t @var{iter}, void * @var{root})
@deftypefunx void ucl_btree_iterator_postorder_backward (ucl_iterator_t @var{iter}, void * @var{root})
Initialise a whole tree iterator; @var{root} must be the root node of a
btree.
@end deftypefun


@deftypefun void ucl_btree_subtree_iterator_postorder (ucl_iterator_t @var{iter}, void * @var{node})
@deftypefunx void ucl_btree_subtree_iterator_postorder_backward (ucl_iterator_t @var{iter}, void * @var{node})
Initialise a subtree iterator; @var{node} must be the a node of a btree,
and will be used as root node of the subtree.
@end deftypefun


@deftypefun void ucl_btree_range_iterator_postorder (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
@deftypefunx void ucl_btree_range_iterator_postorder_backward (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
Initialise a range iterator over the range of nodes selected by
@var{range} (remember that ranges are inclusive); the minimum field of
@var{range} is interpreted as the starting node of the iteration, while
the maximum field of @var{range} is interpreted as the ending node of
the iteration.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Examples of forward iteration

To perform a complete iteration, we have to select the deepest leftmost
son in the tree (@code{2} in the example) and begin from there.  Example:

@example
ucl_node_t        cur;

cur = get_a_node();
for (cur = ucl_btree_find_deepest_son(cur);
     cur != NULL;
     cur = ucl_btree_step_postorder(cur));
  @{
    do_something_with(cur);
  @}
@end example

To restrict the iteration to a subtree of a tree, we have to check when
the iterator reaches the top node.  Example:

To restrict the iteration to a subtree of a tree: we cannot loop until
the function returns @cnull{}, because the top node of a subtree has a
non--@cnull{} value in the parent pointer field.  With reference to the
tree in the picture above: we select the top node (number 10); then we
move to the deepest son (number 6) and we visit it; then we enter the
loop until the iterator reaches the top node (number 10 again).

Example:

@example
ucl_node_t        cur, end;

cur = end = get_a_node();

for (cur = ucl_btree_find_deepest_son(cur);
     cur != end;
     cur = ucl_btree_step_postorder(cur));
  @{
    do_something_with(cur);
  @}

/* Here "cur == end" and we visit it. */
do_something_with(cur);
@end example

@noindent
@code{cur} can't be null in the loop.

@c page
@node btree breadth first
@subsubsection Breadth first iteration


Breadth first iteration: visit the tree level by level.  Example:

@example
5-------10----12
|        |     |
1--3--4  7--9 11
   |     |  |
   2     6  8
@end example

@noindent
the order of the forward iteration is: 5, 1, 10, 3, 7, 12, 2, 4, 6, 9,
11, 8.  To do it we need a moving cursor that always ``turns right''
keeping the count of the level.  The order of the backward iteration is:
5, 10, 1, 12, 7, 3, 11, 9, 6, 4, 2, 8.

All the following functions accept @code{void *} values as arguments and
return @code{void *} values; internally these pointers are cast to
@code{ucl_node_t}.


@deftypefn {Inline Function} {void *} ucl_btree_first_levelorder (void * @var{root})
@deftypefnx {Inline Function} {void *} ucl_btree_first_levelorder_backward (void * @var{root})
Given a pointer to the root node of a tree, return the first node of a
levelorder iteration.  For both the forward and backward iterations: it
is the root node itself.
@end deftypefn


@deftypefun {void *} ucl_btree_step_levelorder (void * @var{self})
@deftypefunx {void *} ucl_btree_step_levelorder_backward (void * @var{self})
Advance a breadth first iteration.  Given a node in the three: perform a
single step and return a pointer to the next node, or @cnull{} if the
iteration is over.
@end deftypefun


@deftypefun void ucl_btree_iterator_levelorder (ucl_iterator_t @var{iter}, void * @var{root})
@deftypefunx void ucl_btree_iterator_levelorder_backward (ucl_iterator_t @var{iter}, void * @var{root})
Initialise a whole tree iterator; @var{root} must be the root node of a
btree.
@end deftypefun


@ignore
@deftypefun void ucl_btree_subtree_iterator_levelorder (ucl_iterator_t @var{iter}, void * @var{node})
@deftypefunx void ucl_btree_subtree_iterator_levelorder_backward (ucl_iterator_t @var{iter}, void * @var{node})
Initialise a subtree iterator; @var{node} must be the a node of a btree,
and will be used as root node of the subtree.
@end deftypefun


@deftypefun void ucl_btree_range_iterator_levelorder (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
@deftypefunx void ucl_btree_range_iterator_levelorder_backward (ucl_iterator_t @var{iter}, ucl_pointer_range_t @var{range})
Initialise a range iterator over the range of nodes selected by
@var{range} (remember that ranges are inclusive); the minimum field of
@var{range} is interpreted as the starting node of the iteration, while
the maximum field of @var{range} is interpreted as the ending node of
the iteration.
@end deftypefun
@end ignore

@c ------------------------------------------------------------

@subsubheading Examples of forward iteration

To perform a complete iteration, we just call the function until it
returns @cnull{}.  Example:

@example
ucl_node_t cur;

for (cur = get_the_top_node();
     cur != NULL;
     cur = ucl_btree_step_levelorder(cur));
  @{
    do_something_with(cur);
  @}
@end example

@c ------------------------------------------------------------

@subsubheading Examples of backward iteration

To perform a complete iteration, we just call the function until it
returns @cnull{}.  Example:

@example
ucl_node_t cur;

for (cur = get_the_top_node();
     cur != NULL;
     cur = ucl_btree_step_levelorder_backward(cur));
  @{
    do_something_with(cur);
  @}
@end example

@c page
@node btree bst
@subsection Routines for raw binary search trees


The following routines can be used in the implementation of raw binary
search trees (@acronym{BST}); they are included in @ucl{} only for
completeness, because we should use balanced trees not raw ones.

All the following functions accept @code{void *} values as arguments and
return values; internally these pointers are cast to @code{ucl_node_t}.


@deftypefun void ucl_bst_insert (void * @var{top}, void * @var{new}, ucl_comparison_t @var{keycmp}, ucl_node_getkey_t @var{getkey})
Insert the node referenced by @var{new} in the binary search tree whose
root is referenced by @var{top}; use @var{keycmp} to compare keys and
@var{getkey} to extract a key from its node.
@end deftypefun


@deftypefun {void *} ucl_bst_find (void * @var{top}, ucl_value_t @var{K}, ucl_comparison_t @var{keycmp}, ucl_node_getkey_t @var{getkey})
Find the node having key referenced by @var{K} in the binary search tree
having root referenced by @var{top}; use @var{keycmp} to compare keys
and @var{getkey} to extract a key from its node.  Return a pointer to
the first found node, or @cnull{} if none was found.
@end deftypefun


@deftypefun {void *} ucl_bst_delete (void * @var{root}, void * @var{cur})
Remove the node referenced by @var{cur} from the binary search tree
whose root is @var{root}.  Return the root node after the deletion,
which may be @var{root} or not.
@end deftypefun

@c page
@node btree avl
@subsection Routines for @avl{} trees


The following routines are used in the implementation of the @avl{}
binary search tree; they are not meant to be used directly.  @ref{map}
for the @ucl{} implementation of @avl{} search trees.

All the following functions accept @code{void *} values as arguments and
return values; internally these pointers are cast to @code{ucl_node_t}.

The @code{meta} field of the @code{ucl_node_tag_t} structure is used to
store an @dfn{@avl{} status} integer which is: @math{-1} when the son
subtree is higher than the bro subtree; @math{+1} when the bro subtree
is higher than the son subtree; @math{0} when the son subtree and the
bro subtree have equal depth.  In a balanced @avl{} tree the difference
in depth between a son subtree and a bro subtree is always at most
@math{1}; so we can say that the @avl{} status is the bro's subtree
depth minus the son's subtree depth, such difference is called
@dfn{balance factor}.


@deftypefun {void *} ucl_btree_avl_rot_left (void * @var{cur})
Perform a @dfn{clockwise rotation} (or @dfn{son rotation} or @dfn{left
rotation}) which balances a son deeper subtree:

@example
   cur      son
  /     =>    \
son            cur
@end example

@noindent
return a pointer to the node that has replaced @var{cur} in the tree,
which is always the son of @var{cur}.

This function must be called only when @samp{cur} has balance factor
@math{-2} and @samp{son} has balance factor @math{-1} or @math{0}; these
are the useful cases and also the cases for which computing the @avl{}
statuses after the rotation is not costly.

Example with @var{cur} being @samp{11} and having son being son deeper
(balance factors in parentheses):

@example
     (top)                   (top)
       |                       |
      11(-2)                   9(0)
     /  \                 -----+-----
 9(-1)   12              7          11(0)
   / \             =>   / \        /  \
  7   10               6   8     10    12
 / \
6   8
@end example

Example with @var{cur} being @math{12} and having son being equal depth
(balance factors in parentheses):

@example
     (top)                      (top)
       |                          |
      12(-2)                      9(+1)
     /  \                    -----+-----
   9(0)  13                 7          12(-1)
   / \              =>     / \         /  \
  7   10                  6   8      10    13
 / \    \                              \
6   8    11                             11
@end example
@end deftypefun


@deftypefun {void *} ucl_btree_avl_rot_right (void * @var{cur})
Perform a @dfn{counterclockwise rotation} (or @dfn{right rotation} or
@dfn{bro rotation}) which balances a right--right--higher subtree:

@example
cur            bro
   \    =>    /
   bro      cur
@end example

@noindent
return a pointer to the node that has replaced @var{cur} in the tree,
which is always the bro of @var{cur}.

This function must be called only when @samp{cur} has balance factor
@math{+2} and its bro has balance factor @math{+1} or @math{0}; these
are the useful cases and also the cases for which computing the @avl{}
statuses after the rotation is not costly.

Example with @var{cur} being @samp{7} and having bro being bro deeper
(balance factors in parentheses):

@example
(top)                              (top)
  |                                  |
  7(+2)                              9(0)
 / \                            -----+-----
6   9(+1)         =>           7(0)        11
   / \                        / \         /  \
  8   11                     6   8      10    12
     /  \
   10    12
@end example

Example with @var{cur} being @samp{6} and having bro being equal depth
(balance factors in parentheses):

@example
(top)                              (top)
  |                                  |
  6(+2)                              9(-1)
 / \                            -----+-----
5   9(0)          =>           6(+1)       11
   / \                        / \         /  \
  8   11                     5=  8      10    12
 /   /  \                       /
7  10    12                    7
@end example
@end deftypefun


@deftypefun {void *} ucl_btree_avl_rot_left_right (void * @var{cur})
Perform a @dfn{left/right rotation} (or @dfn{son/bro rotation}) which
balances a left--right--higher subtree:

@example
   cur           son_bro
  /              /     \
son        =>  son     cur
   \
  son_bro
@end example

@noindent
it can be seen as the sequence of a counterclockwise rotation for
@samp{son} and a clockwise rotation for @samp{cur}:

@example
   cur              cur        son_bro
  /                /           /     \
son        =>    son     =>  son     cur
   \            /
  son_bro     son_bro
@end example

@noindent
return a pointer to the node that has replaced @var{cur} in the
tree, which is always the bro of the son of @var{cur}.

This function must be called only when @samp{cur} has balance factor
@math{-2} and @samp{son} has balance factor @math{+1}.

Example:

@example
         (top)                            (top)
           |                                |
          10 (old_cur)                      8 (new_cur)
         /  \                     ----------+----------
  (son) 5    13            (son) 5          (old_cur) 10
       / \              =>      / \                  /  \
      3   8 (new_cur)          3   7                9    13
         / \                     (deep_son)  (deep_bro)
        7   9
(deep_son) (deep_bro)
@end example
@end deftypefun


@deftypefun {void *} ucl_btree_avl_rot_right_left (void * @var{cur})
Perform a @dfn{right/left rotation} (or @dfn{bro/son rotation}) which
balances a right--left--higher subtree:

@example
cur            bro_son
   \            /   \
   bro    =>  cur   bro
  /
 bro_son
@end example

@noindent
it can be seen as the sequence of a clockwise rotation for @samp{bro}
and a counterclockwise rotation for @samp{cur}:

@example
cur           cur                  bro_son
   \             \                  /   \
   bro    =>    bro_son       =>  cur   bro
  /                \
 bro_son            bro
@end example

@noindent
return a pointer to the node that has replaced @var{cur} in the tree,
which is always the bro of the bro of @var{cur}.

This function must be called only when @samp{cur} has balance factor
@math{+2} and @samp{son} has balance factor @math{-1}.

Example:

@example
          (top)                           (top)
            |                               |
  (old_cur) 9(+2)                          11 (0) (new_cur)
           / \                    ----------+---------
          8   13(-1) (bro)       9(0) (old_cur)       13(0) (bro)
             /  \         =>    / \                  /  \
 (new_cur) 11    14            8   10              12    14
          /  \                   (deep_son)  (deep_bro)
        10    12
(deep_son)    (deep_bro)
@end example
@end deftypefun


@deftypefun int ucl_btree_avl_depth (void * @var{N})
Return the depth of the tree of which @var{N} is the root; if @var{N} is
@cnull{} the return value is zero.  For this function to return the
correct result: the tree must have nodes with correct status.
@end deftypefun


@deftypefun int ucl_btree_avl_factor (void * @var{N})
Return the balance factor of @var{N}: the depth of the bro subtree minus
the depth of the son subtree.  If @var{N} is @cnull{} the return value
is zero.
@end deftypefun


@deftypefun ucl_bool_t ucl_btree_avl_is_balanced (void * @var{N})
Return true if the tree of which @var{N} is the root is balanced; if
@var{N} is @cnull{} the return value is true.  This function only checks
that the left and right subtrees of each node have depth at most
different by @math{1}, it does @strong{not} validate the @avl{} status
of the nodes.
@end deftypefun


@deftypefun ucl_bool_t ucl_btree_avl_is_correct (void * @var{N})
Return true if the tree of which @var{N} is the root is balanced and all
the statuses are correct; if @var{N} is @cnull{} the return value is
true.  This function checks that the left and right subtrees of each
node have depth at most different by @math{1}, and also verifies that
the @avl{} status of each node is coherent with the difference between
depths.
@end deftypefun

@c page
@node tree
@section The tree structure


@menu
* tree implementation::         How it's done.
* tree creation::               Creating a tree hierarchy.
* tree insertion::              Inserting nodes into a tree.
* tree testing::                Testing relationships between nodes.
* tree relatives::              Accessing or setting the relatives of
                                a node.
* tree removing::               Removing elements from a tree.
* tree iterators::              Traversing a tree.
@end menu

@c page
@node tree implementation
@subsection How it's done


The implementation is a binary tree with nodes of type
@code{ucl_node_t}; the only difference between the btree and the tree is
the interpretation of the bro nodes.  This means that all the functions
in the btree module can be used on a tree, and the tree module adds
functions to establish the interpretation policy.

In the following picture: the nodes @code{B}, @code{C}, @code{D} and
@code{E} are all ``children'' of the node @code{A}; the node @code{A} is
the father of the nodes @code{B}, @code{C}, @code{D} and @code{E}.  So
in a tree a node can have and indefinite number of children.

@example
   -----
  |  A  |
   -----
    ^ |son
 dad| v
   -----  bro   -----  bro   -----  bro   -----  bro
  |  B  |----->|  C  |----->|  D  |----->|  E  |----->NULL
   ----- <----- ----- <----- ----- <----- -----
    ^ |   dad    ^ |   dad          dad
 dad| vson    dad| vson
   -----        -----
  |  F  |      |  G  |
   -----        -----
@end example

Pointers condition meaning:

@table @code
@item node.dad == NULL
the node is the root node of a tree;

@item node.bro == NULL
the node has no brothers, so it's the last brother between the children
of its father;

@item node.son == NULL
the node has no children;

@item A.dad == B && B.son == A
A is the first between the children of node B;

@item A.dad == B && B.bro == A
A and B are brothers, and children of the same parent node.
@end table

@c page
@node tree creation
@subsection Creating a tree hierarchy


The node structures must be allocated by the client code and all the
bytes set to zero before usage.  The btree functions can be used
directly, but @ucl{} provides aliases for them when they must be used
for a tree.

All the following functions accept @code{void *} values as arguments:
internally these pointers are cast @code{ucl_node_t}.

@c ------------------------------------------------------------

@subsubheading Single link setters


@deftypefun void ucl_tree_set_next (void * @var{node}, void * @var{next})
Mutate @var{node} so that @var{next} becomes the new right brother of
@var{node}.  The old reference to the right brother of @var{node} is
lost.
@end deftypefun


@deftypefun void ucl_tree_set_prev (void * @var{node}, void * @var{prev})
Mutate @var{node} so that @var{prev} becomes the new left brother of
@var{node}.  The old reference to the left brother of @var{node} is
lost.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Double link setters


@deftypefun void ucl_tree_set_dadson (void * @var{dad}, void * @var{son})
Mutate @var{prev} and @var{next} so that the two become left and right
brothers.  The old references to the left and right brothers are lost.
@end deftypefun


@deftypefun void ucl_tree_set_prevnext (void * @var{prev}, void * @var{next})
Mutate @var{prev} and @var{next} so that the two become left and right
brothers.  The old references to the left and right brothers are lost.
@end deftypefun

@c page
@node tree insertion
@subsection Inserting nodes into a tree


The following functions are used to insert subtrees in a tree.  None of
the nodes in the target tree are detached.  The links in the new subtrees
that are not interested by the relations in these functions, are left
untouched.

All the following functions accept @code{void *} values as arguments:
internally these pointers are cast @code{ucl_node_t}.


@deftypefun void ucl_tree_insert_dad (void * @var{node}, void * @var{dad})
Inserts a new dad for a node.  The dad node becomes the father of the
node and the first son of the old dad (if any).

@example
 ---       ---
| A |     | A |
 ---       ---
  |         |
 ---       ---
|nod| ->  |dad|
 ---       ---
            |
           ---
          |nod|
           ---
@end example
@end deftypefun


Example of dad insertion:

@example
ucl_tree_insert_dad( 1, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   A--C
|  |            |         |
5  6            B         1--2--3--4
                          |  |
                          5  6
@end example

@noindent
the @code{D} and @code{B} nodes are detached and will be lost if we
don't keep a reference to them.


@deftypefun void ucl_tree_insert_son (void * @var{node}, void * @var{son})
Insert a new child for a node.  The node referenced by @var{son} becomes
the last between the children of the node referenced by @var{node}.

@example
 ---         ---
|nod|       |nod|
 ---         ---
  |     ->    |
 ---         ---     ---
| A |       | A |-->|son|
 ---         ---     ---
@end example
@end deftypefun


Example of son insertion:

@example
ucl_tree_insert_son( 0, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   1--2--3--4--A--C
|  |            |         |  |        |
5  6            B         5  6        B
@end example

@noindent
the node @code{D} is detached and will be lost if we don't keep a
reference to it.


@deftypefun void ucl_tree_insert_prev (void * @var{node}, void * @var{bro})
Insert a new brother for a node.  The node referenced by @var{bro}
becomes the left brother of the node referenced by @var{node}.

@example
 ---    ---          ---    ---    ---
| A |--|nod|   ->   | A |--|bro|--|nod|
 ---    ---          ---    ---    ---
@end example
@end deftypefun


Example of prev node insertion:

@example
ucl_tree_insert_prev( 2, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   1--A--2--3--4
|  |            |         |  |  |
5  6            B         5  B  6
@end example

@noindent
the @code{D} and @code{C} nodes are detached and will be lost if we
don't keep a reference to them.


@deftypefun void ucl_tree_insert_next (void * @var{node}, void * @var{bro})
Insert a new brother for a node.  The node referenced by @var{bro}
becomes the right brother of the node referenced by @var{node}.

@example
 ---    ---          ---    ---    ---
|nod|--| A |   ->   |nod|--|bro|--| A |
 ---    ---          ---    ---    ---
@end example
@end deftypefun


Example of next brother insertion:

@example
ucl_tree_insert_next( 2, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   1--2--A--3--4
|  |            |         |  |
5  6            B         5  6
@end example

@noindent
the @code{D}, @code{B} and @code{C} nodes are detached and will be lost
if we don't keep a reference to them.

@c page
@node tree testing
@subsection Testing relationships between nodes


All the following functions accept @code{void *} values as arguments:
internally these pointers are cast to @code{ucl_node_t}.


@deftypefun ucl_bool_t ucl_tree_is_dad (void * @var{dad}, void * @var{cld_p})
Return true if the node referenced by @var{dad} is the father of the
node referenced by @var{cld_p}, otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_is_bro (void * @var{node}, void * @var{bro})
Return true if the node referenced by @var{node} is a brother of the
node referenced by @var{bro}, otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_has_dad (void * @var{self})
Return true if the node referenced by @var{self} has a parent,
otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_has_prev (void * @var{self})
Return true if the node referenced by @var{self} has a brother to the
left, otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_has_next (void * @var{self})
Return true if the node referenced by @var{self} has a brother to the
right, otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_has_son (void * @var{self})
Return true if the node referenced by @var{self} has a son, otherwise
return false.
@end deftypefun

@c page
@node tree relatives
@subsection Accessing or setting the relatives of a node


All the following functions accept @code{void *} values as arguments:
internally these pointers are cast to @code{ucl_node_t}.


@deftypefun {void *} ucl_tree_ref_dad (void * @var{self})
Return a pointer to the father of the node referenced by @var{self}; if
the node has no parent: return @cnull{}.
@end deftypefun


@deftypefun {void *} ucl_tree_ref_prev (void * @var{self})
Return a pointer to the left brother of the node referenced by
@var{self}; if the node has no left brother: return @cnull{}.
@end deftypefun


@deftypefun {void *} ucl_tree_ref_next (void * @var{self})
Return a pointer to the right brother of the node referenced by
@var{self}; if the node has no right brother: return @cnull{}.
@end deftypefun


@deftypefun {void *} ucl_tree_ref_son (void * @var{self})
Return a pointer to the son of the node referenced by @var{self}; if the
node has no child: return @cnull{}.
@end deftypefun


@deftypefun {void *} ucl_tree_ref_first (void * @var{self})
Return a pointer to the first between the brothers of the node
referenced by @var{self}; it can be a pointer to @var{self} itself, if
@var{self} is the first.
@end deftypefun


@deftypefun {void *} ucl_tree_ref_last (void * @var{self})
Return a pointer to the last between the brothers of the node
referenced by @var{self}; it can be a pointer to @var{self} itself, if
@var{self} is the last.
@end deftypefun

@c page
@node tree removing
@subsection Removing elements from a tree


These functions will extract a node from a tree, returning a pointer to
the extracted node.  All the following functions accept @code{void *}
values as arguments and return @code{void *} values: internally these
pointers are cast to @code{ucl_node_t}.


@deftypefun {void *} ucl_tree_extract_dad (void * @var{node})
Extract the dad of the node referenced by @var{node} from the tree.
The referenced node and all its brothers are inserted in place of the
extracted dad.

Returns a pointer to the extracted node, or @cnull{} if the selected
node has no dad.  All the pointers in the extracted node structure are
reset to @cnull{}.

@example
 ---    ---    ---       ---    ---    ---    ---
| A |--|dad|--| B |     | A |--|nod|--| C |--| B |
 ---    ---    ---       ---    ---    ---    ---
         |          ->
        ---    ---              ---
       |nod|--| C |            |dad|
        ---    ---              ---
@end example
@end deftypefun


@deftypefun {void *} ucl_tree_extract_son (void * @var{node})
Extract the son of the node referenced by @var{node} from the tree.
The son of the selected node is extracted from the hierarchy.  All of its
children become children of the selected node.

Return a pointer to the extracted node or @cnull{} if the selected node
has no son.  All the pointers in the extracted node structure are reset
to @cnull{}.

@example
 ---               ---
|nod|             |nod|
 ---               ---
  |                 |
 ---    ---        ---    ---    ---
|son|--| C |  ->  | A |--| B |--| C |
 ---    ---        ---    ---    ---
  |
 ---    ---            ---
| A |--| B |          |son|
 ---    ---            ---
@end example
@end deftypefun


@deftypefun {void *} ucl_tree_extract_prev (void * @var{node})
Extract the left brother of the node referenced by @var{node}.  The
left brother of the selected node is extracted from the hierarchy.  Its
children become left brothers of the selected node.

Return a pointer to the extracted node, or @cnull{} if the selected node
has no left brother.   All the pointers in the extracted node structure
are reset to @cnull{}.

@example
 ---               ---
| A |             | A |
 ---               ---
  |                 |
 ---    ---        ---    ---
|prv|--|nod|  ->  | B |--|nod|
 ---    ---        ---    ---
  |
 ---                   ---
| B |                 |prv|
 ---                   ---
@end example
@end deftypefun


@deftypefun {void *} ucl_tree_extract_next (void * @var{node})
Extract the right brother of the node referenced by @var{node}.   The
right brother of the selected node is extracted from the hierarchy.  Its
children become right brothers of the selected node.

Return a pointer to the extracted node, or @cnull{} if the selected node
has no right brother.   All the pointers in the extracted node structure
are reset to @cnull{}.

@example
 ---    ---    ---       ---    ---    ---
|nod|--|nxt|--| A |     |nod|--| B |--| A |
 ---    ---    ---       ---    ---    ---
         |           ->
        ---                 ---
       | B |               |nxt|
        ---                 ---
@end example
@end deftypefun

@c page
@node tree iterators
@subsection Traversing a tree


For the tree iterators, the return value of @function{ucl_iterator_ptr}
is a pointer to the current node.  All the following functions accept
@code{void *} values as arguments: internally these pointers are cast to
@code{ucl_node_t}.


@deftypefun void ucl_tree_iterator_inorder (void * @var{node}, ucl_iterator_t @var{iter})
Initialises an in--order iteration.
@end deftypefun


@deftypefun void ucl_tree_iterator_preorder (void * @var{node}, ucl_iterator_t @var{iter})
Initialises a pre--order iteration.
@end deftypefun


@deftypefun void ucl_tree_iterator_postorder (void * @var{node}, ucl_iterator_t @var{iter})
Initialises a post--order iteration.
@end deftypefun

@c page
@node heap
@section The heap structure


@cindex Heap container


The heap container allows us to collect a bunch of values and extract
them sorted, from the lesser to the greater according to a custom
comparison function.

The heap is implemented as a binary tree, with nodes of type
@code{ucl_node_t}.  It is possible to use the heap to implement the heap
sorting algorithm for the @ucl{} containers that make use of
@code{ucl_node_t} nodes.


@deftp {Struct Typedef} ucl_heap_tag_t
@deftpx {One Element Array Typedef} ucl_heap_t
The base structure of the heap container.  The base structure stores the
context associated to a heap such as the comparison function for the
nodes.
@end deftp


@menu
* heap creation::             Creating and destroying heaps.
* heap insertion::            Adding elements to a heaps.
* heap deletion::             Removing elements from a heaps.
* heap ops::                  Various operations on a heaps.
@end menu

@c page
@node heap creation
@subsection Creating and destroying heap


@deftypefun void ucl_heap_initialise (ucl_heap_t @var{H}, ucl_comparison_t @var{compar})
The base structure of a heap container must be allocated by the client
code and initialised with this function.  The comparison function will
get as arguments pointers to the heap nodes (@code{ucl_node_t}) in the
@code{pointer} field of the @code{ucl_value_t} union; it is its
responsibility to know how to extract the values from there.
@end deftypefun


When a heap must be destroyed: all its nodes must be extracted and
released with the appropriate function; example of heap destruction:

@example
ucl_memory_allocator_t  A;
ucl_heap_t              H;
ucl_node_t              N;

while (ucl_heap_size(H))
  @{
    N = ucl_heap_extract(H);
    A.alloc(A.data, &N, 0);
  @}
@end example

As example of comparison function definition:

@example
typedef struct @{
  ucl_node_tag_t  node;
  int             value;
@} node_tag_t;

typedef node_tag_t *    node_t;

const ucl_comparison_t compare_nodes = @{
  .data = @{ .t_unsigned_long = 0 @},
  .func = compare_nodes_fun
@};

int
compare_nodes_fun (ucl_value_t D UCL_UNUSED,
                   const ucl_value_t a, const ucl_value_t b)
@{
  node_t        A = a.pointer;
  node_t        B = b.pointer;
  return ((A->value == B->value)?
     0 : ((A->value > B->value)? 1 : -1));
@}
@end example

@c page
@node heap insertion
@subsection Adding elements to a heap


@deftypefun void ucl_heap_insert (ucl_heap_t @var{H}, void * @var{node})
Insert a new node in the heap.  @var{node} is internally cast to
@code{ucl_node_t}.
@end deftypefun


Example of node insertion:

@example
typedef struct @{
  ucl_node_tag_t  node;
  int             value;
@} node_tag_t;

typedef node_tag_t *    node_t;

ucl_memory_allocator_t  A;
ucl_heap_t              H;
node_t                  N = NULL;

A.alloc(A.data, &N, sizeof(node_tag_t));
N->value = 123;
ucl_heap_insert(H, N);
@end example

@c page
@node heap deletion
@subsection Removing elements from a heap


@deftypefun {void *} ucl_heap_extract (ucl_heap_t @var{H})
Extract a node from the heap; return a pointer to it, or @cnull{} if the
heap is empty.  The extracted node is the one with the smallest value;
the returned value can be safely cast to @code{ucl_node_t}.
@end deftypefun


Example of node extraction:

@example
typedef struct @{
  ucl_node_tag_t  node;
  int             value;
@} node_tag_t;

typedef node_tag_t *    node_t;

ucl_memory_allocator_t  A;
ucl_heap_t              H;
node_t                  N;

N = ucl_heap_extract(H);
A.alloc(A.data, &N, 0);
@end example


@c page
@node heap ops
@subsection Various operations on a heap


@deftypefn {Inline Function} size_t ucl_heap_size (const ucl_heap_t @var{H})
Return a value of type @code{size_t} representing the number of nodes in
the heap.
@end deftypefn


@deftypefun void ucl_heap_merge (ucl_heap_t @var{H}, ucl_heap_t @var{other})
Merge two heaps: nodes from @var{other} are extracted and inserted into
@var{H}.  When the function returns @var{other} is empty.
@end deftypefun

@c page
@node circular
@section The circular list


@cindex Circular list


The circular container provides a circular doubly linked list; it is
implemented as a chain of @code{ucl_node_t} structures; a pointer to the
@emph{current} position is stored in a base structure.  The current
position marker can be moved forward and backward as a cursor.

@quotation
The handling of list links is derived from the handling of elements in
the @acronym{TCL} (Tool Command Language) hash table by John Ousterhout
and others (@url{http://www.tcl.tk} for more about @acronym{TCL}).
@end quotation


@deftp {Struct Typedef} ucl_circular_tag_t
@deftpx {One Element Array} ucl_circular_t
Base structure of the container.  It must be allocated by the user's
code.
@end deftp


@menu
* circular creation::           Creating and destroying circulars.
* circular adding::             Adding elements to a circular.
* circular removing::           Removing elements from a circular.
* circular moving::             Moving the cursor.
* circular search::             Searching elements.
* circular ops::                Various operations on a circular.
@end menu

@c page
@node circular creation
@subsection Creating and destroying circulars


@deftypefun void ucl_circular_constructor (ucl_circular_t @var{self})
Initialise an already allocated structure.  Set all the fields of
@var{self} so that the structure represents an empty circular list.
@end deftypefun


@deftypefun void ucl_circular_destructor (ucl_circular_t @var{self})
Destroys the structure.  Set all the fields of @var{self} so that the
structure represents an empty circular list.  Before calling this
function the user's code has to make sure that all the links are
extracted from the list.
@end deftypefun


To extract all the links from a circular list, we can do:

@example
ucl_circular_t  circ;
ucl_node_t      link;
ucl_value_t     val;

while (ucl_circular_size(circ))
  @{
    link = ucl_circular_extract(circ);
    /* insert here the code to destroy the value */
    /* insert here the code to free the link memory */
  @}
@end example

@noindent
if the value needs no destructor and we are using a memory allocator as
implemented by @ucl{}, we can do:

@example
ucl_memory_allocator_t  A;
ucl_circular_t  circ;
ucl_node_t      link;

while (ucl_circular_size(circ))
  @{
    link = ucl_circular_extract(circ);
    A.alloc(A.data, &link, 0);
  @}
@end example

@c page
@node circular adding
@subsection Adding elements to a circular


@deftypefun void ucl_circular_insert (ucl_circular_t @var{self}, ucl_node_t @var{link_p})
Insert an element at the current position.  To do this the user's code
has to allocate a new circular link structure, store the value into it
and hand a pointer to the node to this function.

The old current link becomes the next link.
@end deftypefun


Example of link insertion (the link has no value):

@example
ucl_memory_allocator_t  A;
ucl_circular_t  circ;
ucl_node_t      link = NULL;

A.alloc(A.data, &link, sizeof(ucl_node_tag_t));
ucl_circular_insert(circ, link);
@end example

@c page
@node circular removing
@subsection Removing elements from a circular


@deftypefun ucl_node_t ucl_circular_extract (ucl_circular_t @var{self})
Extract the current link and return a pointer to it, or @cnull{} if the
list is empty.  The new current element is the next in the forward
direction.
@end deftypefun


Example of link deletion and memory release:

@example
ucl_memory_allocator_t  A;
ucl_circular_t  circ;
ucl_node_t      link;

link = ucl_circular_extract(circ);
if (NULL != link)
  A.alloc(A.data, &link, 0);
@end example

@c page
@node circular moving
@subsection Moving the cursor


@deftypefun void ucl_circular_forward (ucl_circular_t @var{self}, int @var{times})
Move forwards the current position, @var{times} is the forward offset:
it can be a positive or negative integer.  If the container is empty, or
the offset is zero, nothing happens.
@end deftypefun


@deftypefun void ucl_circular_backward (ucl_circular_t @var{self}, int @var{times})
A wrapper for @function{ucl_circular_forward}: move backwards the
current position, @var{times} is the backward offset.  If the container
is empty, or the offset is zero, nothing happens.
@end deftypefun

@c page
@node circular search
@subsection Searching elements


@deftypefun void ucl_circular_set_compar (ucl_circular_t @var{this}, ucl_comparison_t @var{compar})
Register the function to be used to compare elements.
@end deftypefun


@deftypefun ucl_node_t ucl_circular_find (ucl_circular_t @var{self}, ucl_value_t @var{val})
Move the current position to the first forward element whose value is
equal to @var{val}; return a pointer to the link, or @cnull{} if the
value was not found.

While performing the search, the selected comparison function is invoked
with @var{val} as second argument and a pointer to the current link as
third argument:

@example
ucl_comparison_t compar = @var{self}.compar;
ucl_node_t   link  = ...;
ucl_value_t  inner = @{ .pointer = link @};

compar.func(compar.data, @var{val}, inner);
@end example
@end deftypefun

@c page
@node circular ops
@subsection Various operations on a circular


@deftypefun size_t ucl_circular_size (ucl_circular_t @var{self})
Return the number of elements in the container.
@end deftypefun


@deftypefun ucl_node_t ucl_circular_current (ucl_circular_t @var{self})
Return a pointer to the current link, or @cnull{} if the container is
empty.
@end deftypefun

@c page
@node graph
@section The graph structure


A @ucl{} graph is a network of (not so) little data structures; the
elements of the graph are nodes and links.

@menu
* graph overview::              How it's done.
* graph types::                 Graph type definitions.
* graph insert::                Inserting links and nodes.
* graph extract::               Extracting links and nodes.
* graph merge::                 Merging links.
* graph value::                 Accessing values.
* graph link iter::             Link iterators.
* graph ops::                   Various operations on a graph.
* graph dfs::                   Depth first search.
@end menu

@c page
@node graph overview
@subsection How it's done


@ucl{} does not enforce the use of a container to collect graph node
structures: it is responsibility of the user to put nodes somewhere.
For convenience: the node structure has a ``next node'' field that
allows us to put nodes into a simply linked list, but it is not
mandatory to use it.

Each node references two doubly linked lists of links: one for outgoing
links and one for incoming links.

@example
                 ------
    NULL  ------| node |-----  NULL
      ^  |       ------      |  ^
      |  v                   v  |
 -----------               ------------
| in link 0 |             | out link 0 |
 -----------               ------------
     |^                         |^
     v|                         v|
 -----------               ------------
| in link 1 |             | out link 1 |
 -----------               ------------
     |^                         |^
     v|                         v|
 -----------               ------------
| in link 2 |             | out link 2 |
 -----------               ------------
     |                          |
     v                          v
   NULL                        NULL
@end example

Each link has references of both the source and destination nodes and is
part of two doubly linked lists: one of outgoing links of the source
node, one of incoming links of the destination node.

@example
    ------------------          -----------------
   | prev output link |        | prev input link |
    ------------------          -----------------
                   |^            ^|
                   ||            ||
                   | ---      --- |
                    --- |    | ---
                       ||    ||
                       v|    |v
 -------------       ------------       -----------
| source node |<----|    link    |---->| dest node |
 -------------       ------------       -----------
                       |^    ^|
                       ||    ||
                    --- |    | ---
                   | ---      --- |
                   ||            ||
                   v|            |v
    ------------------          -----------------
   | next output link |        | next input link |
    ------------------          -----------------
@end example

@c page
@node graph types
@subsection Graph type definitions


Both node and link structures should be allocated using an equivalent of
@function{calloc}, or reset to zero before being inserted in a graph.


@deftp {Struct Typedef} ucl_graph_node_tag_t
@deftpx {Pointer Typedef} ucl_graph_node_t
Structure type and pointer to structure type for nodes.  They should be
treated as opaque even if it is not.
@end deftp


@deftp {Struct Typedef} ucl_graph_link_tag_t
@deftpx {Pointer Typedef} ucl_graph_link_t
Structure type and pointer to structure type for links.  They should be
treated as opaque even if it is not.
@end deftp

@c page
@node graph insert
@subsection Inserting links and nodes


@deftypefun void ucl_graph_link (@var{src_node}, @var{link}, @var{dst_node})
Insert a link between two nodes.  The source and destination node
structures cannot be exchanged: the link is directed.  Arguments:

@table @code
@item ucl_graph_node_t @var{src_node}
pointer to the source node structure;

@item ucl_graph_link_t @var{link}
pointer to the link structure;

@item ucl_graph_node_t @var{dst_node}
pointer to the destination node structure.
@end table

Usage example:

@example
ucl_memory_allocator_t  A;
ucl_graph_node_t        src = NULL, dst = NULL;
ucl_graph_link_t        lnk = NULL;

A.alloc(A.data, &src, sizeof(ucl_graph_node_tag_t));
A.alloc(A.data, &dst, sizeof(ucl_graph_node_tag_t));
A.alloc(A.data, &lnk, sizeof(ucl_graph_link_tag_t));

ucl_graph_link(src, lnk, dst);
@end example
@end deftypefun


@deftypefun ucl_bool_t ucl_graph_nodes_are_linked (ucl_graph_node_t @var{src}, ucl_graph_node_t @var{dst})
Return true if there is a link between @var{src} and @var{dst}, with
source @var{src} and destination @var{dst}.
@end deftypefun


@deftypefun ucl_bool_t ucl_graph_nodes_doubly_linked (ucl_graph_node_t @var{A}, ucl_graph_node_t @var{B})
Return true if there are two links between @var{A} and @var{B}, one from
@var{A} to @var{B} and one from @var{B} to @var{A}.
@end deftypefun


@deftypefun ucl_bool_t ucl_graph_nodes_are_connected (ucl_graph_node_t @var{A}, ucl_graph_node_t @var{B})
Return true if there is a link between @var{A} and @var{B}, no matter
the direction.
@end deftypefun

@c page
@node graph extract
@subsection Extracting links and nodes


@deftypefun void ucl_graph_unlink (ucl_graph_link_t @var{L})
Remove a link from the graph.  After this function has been called, it
is safe to free the memory of the link.
@end deftypefun

To erase a node from a graph we have to remove all the links between it
and the other nodes.  To do it in the case of structures allocated with
a @ucl{} memory allocator:

@example
ucl_memory_allocator_t  A;
ucl_graph_node_t        N;
ucl_graph_link_t        L;

for (L = ucl_graph_output_link(N); L;
     L = ucl_graph_output_link(N))
  @{
    ucl_graph_unlink(L);
    A.alloc(A.data, &L, 0);
  @}

for (L = ucl_graph_input_link(N); L;
     L = ucl_graph_input_link(N))
  @{
    ucl_graph_unlink(L);
    A.alloc(A.data, &L, 0);
  @}

A.alloc(A.data, &N, 0);
@end example


@defmac UCL_GRAPH_FIRST_INPUT_LINK_LOOP (@var{node}, @var{link})
@defmacx UCL_GRAPH_FIRST_OUTPUT_LINK_LOOP (@var{node}, @var{link})
Loop over the first input or output link until it is @cnull{}.  These
macros do the same loops described above; with them the extraction code
looks like this:

@example
ucl_memory_allocator_t  A;
ucl_graph_node_t        N;
ucl_graph_link_t        L;

UCL_GRAPH_FIRST_INPUT_LINK_LOOP(N, L) @{
  ucl_graph_unlink(L);
  A.alloc(A.data, &L, 0);
@}

UCL_GRAPH_FIRST_OUTPUT_LINK_LOOP(N, L) @{
  ucl_graph_unlink(L);
  A.alloc(A.data, &L, 0);
@}

A.alloc(A.data, &N, 0);
@end example
@end defmac


@deftypefun void ucl_graph_erase_node_destroy_links (ucl_graph_node_t @var{node}, ucl_callback_t @var{destructor})
Erase a node from a graph finalising all the links; the erasure code
looks like this:

@example
ucl_graph_node_t        N;
ucl_callback_t          destructor;

ucl_graph_erase_node_destroy_links(N, destructor);
A.alloc(A.data, &N, 0);
@end example

@noindent
and we can implement:

@example
ucl_value_t
destructor_fun (ucl_value_t dummy, ucl_graph_link_t L)
@{
  A.alloc(A.data, &L, 0);
@}
ucl_callback_t destructor = @{
  .data = ucl_value_null,
  .func = destructor_fun
@};
@end example

The node structure itself is not finalised: its link fields are set to
@cnull{}, the value field is left untouched, the structure memory is
not freed.
@end deftypefun

@c page
@node graph merge
@subsection Merging links


Merging means to replace two links with one that represents the whole
path; before merging the scenario is:

@example
 --------     ---------     --------     ----------     ------
| source |<--| in link |-->| middle |<--| out link |-->| dest |
|  node  |    ---------    |  node  |    ----------    | node |
 --------                   --------                    ------
@end example

@noindent
merging can be done upon the input or the output link; after merging
upon the input link:

@example
 --------     ---------     ------
| source |<--| in link |-->| dest |
|  node  |    ---------    | node |
 --------                   ------
@end example

@noindent
after merging upon the output link:

@example
 --------     ----------     ------
| source |<--| out link |-->| dest |
|  node  |    ----------    | node |
 --------                    ------
@end example


@deftypefun void ucl_graph_merge_upon_input_link (ucl_graph_link_t @var{in}, ucl_graph_link_t @var{out})
@deftypefunx void ucl_graph_merge_upon_output_link (ucl_graph_link_t @var{in}, ucl_graph_link_t @var{out})
Merge two links; @var{in} references the link incoming to the middle
node; @var{out} references the link outgoing from the middle node.

Merging is meaningful if @var{in} and @var{out} are connected to the
same node, but these functions do not check for this.

The middle node is excluded from the path: if other links connect the
node to the graph nothing needs to be done, but if merging the links
removes the last links between the node and the graph: the node must be
finalised.
@end deftypefun

@c page
@node graph value
@subsection Accessing values


@deftypefun void ucl_graph_node_set_value (ucl_graph_node_t * @var{p}, ucl_value_t @var{newval})
@deftypefunx void ucl_graph_link_set_value (ucl_graph_link_t * @var{p}, ucl_value_t @var{newval})
Store a new value in the structure.
@end deftypefun


@deftypefun ucl_value_t ucl_graph_node_get_value (ucl_graph_node_t * @var{p})
@deftypefunx ucl_value_t ucl_graph_link_get_value (ucl_graph_link_t * @var{p})
Return the current value in the structure.
@end deftypefun


@deftypefun void ucl_graph_node_set_mark (ucl_graph_node_t * @var{p}, ucl_value_t @var{mark})
@deftypefunx ucl_value_t ucl_graph_node_get_mark (ucl_graph_link_t * @var{p})
Set/get the mark value, a field of @code{ucl_value_t} type.
@end deftypefun

@c page
@node graph link iter
@subsection Link iterators


@defmac UCL_GRAPH_OUTPUT_LINKS_LOOP (@var{node}, @var{link})
@defmacx UCL_GRAPH_INPUT_LINKS_LOOP (@var{node}, @var{link})
Iterate over the outgoing or ingoing links of @var{node} using
@var{link} as iterator in a @code{for ()} loop.

Example of iteration over outgoing links:

@example
ucl_graph_node_t        N;
ucl_graph_link_t        L;

UCL_GRAPH_OUTPUT_LINKS_LOOP(N, L) @{
  do_something_with(L);
@}
@end example

@noindent
example of iteration over incoming links:

@example
ucl_graph_node_t        N;
ucl_graph_link_t        L;

UCL_GRAPH_INPUT_LINKS_LOOP(N, L) @{
  do_something_with(L);
@}
@end example
@end defmac

@c ------------------------------------------------------------

@subsubheading Finding first and last links


@deftypefun ucl_graph_link_t ucl_graph_input_link (ucl_graph_node_t @var{N})
@deftypefunx ucl_graph_link_t ucl_graph_output_link (ucl_graph_node_t @var{N})
Return a pointer to the first incoming or outgoing link of @var{N}.
@end deftypefun


@deftypefun ucl_graph_link_t ucl_graph_last_output_link (ucl_graph_link_t @var{L})
@deftypefunx ucl_graph_link_t ucl_graph_last_input_link (ucl_graph_link_t @var{L})
Traverse toward the end the list of incoming or outgoing links, starting
at @var{L}.  Return the last link.
@end deftypefun


@deftypefun ucl_graph_link_t ucl_graph_first_output_link (ucl_graph_link_t @var{L})
@deftypefunx ucl_graph_link_t ucl_graph_first_input_link (ucl_graph_link_t @var{L})
Traverse toward the beginning the list of incoming or outgoing links,
starting at @var{L}.  Return the first link.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Finding previous and next links


@deftypefun ucl_graph_link_t ucl_graph_prev_input_link (ucl_graph_link_t @var{L})
@deftypefunx ucl_graph_link_t ucl_graph_prev_output_link (ucl_graph_link_t @var{L})
Return a pointer to the previous link in the chain.  The return value is
@cnull{} if @var{L} is the first link.
@end deftypefun


@deftypefun ucl_graph_link_t ucl_graph_next_input_link (ucl_graph_link_t @var{L})
@deftypefunx ucl_graph_link_t ucl_graph_next_output_link (ucl_graph_link_t @var{L})
Return a pointer to the next link in the chain.  The return value is
@cnull{} if @var{L} is the last link.
@end deftypefun

@c page
@node graph ops
@subsection Various operations on a graph


@deftypefun size_t ucl_graph_number_of_input_links (ucl_graph_node_t @var{N})
@deftypefunx size_t ucl_graph_number_of_output_links (ucl_graph_node_t @var{N})
Return the number of incoming or outgoing links.
@end deftypefun

@c page
@node graph dfs
@subsection Depth first search


Depth first search (@dfs{}) is an iteration over the nodes of a graph
that starts from a selected node and visits a node only once; the result
of the iteration is a string of nodes.  The iteration is analogous to the
preorder iteration in trees (the worm that always turns right in the
labyrinth).

The iteration may not touch all the nodes:

@itemize
@item
if the graph is not connected: the @dfs{} does not touch all the nodes;

@item
if the @dfs{} follows the direction of the links and there are nodes
with outgoing links only: the @dfs{} does not touch all the nodes.
@end itemize

@ucl{} implements two types of @dfs{}: one that honors the direction of
the links; one that does not.

@menu
* graph dfs example::           @dfs{} example.
* graph dfs types::             @dfs{} related type defintions.
* graph dfs api::               @dfs{} programming interface.
@end menu

@c page
@node graph dfs example
@subsubsection @dfs{} example


Given the following connected graph:

@example
 -- A ---> B ---> C
|   |      |
|   |       ------
|   |             |
|   |             v
|    ----> D <--- E
|          ^
v          |
F ---------
@end example

@noindent
we see that we can partition the nodes in two sets:

@example
one = @{ A, F @}  two = @{ B, C, E, D @}
@end example

@noindent
there are no links going from partition @code{two} to partition
@code{one}; the directed @dfs{} starting at node @code{B} is:

@example
B, C, E, D
@end example

@noindent
nodes in partition @code{one} are not touched; while the undirected
@dfs{} starting at node @code{B} is:

@example
B, C, E, D, F, A
@end example

@noindent
all the nodes are touched.

We note that:

@enumerate
@item
if the number of nodes touched by the directed @dfs{} equals the number
of nodes in the graph: the graph is connected;

@item
the iteration goes ``deep'' inside a graph and then steps back in search
of new ramifications;

@item
if every time the iterator does a step we increment a counter: by saving
the values of counter when entering a node and leaving a node, we can
infer properties of the graph.
@end enumerate

@c page
@node graph dfs types
@subsubsection @dfs{} related type defintions


The @dfs{} is implemented as a recursive process that puts touched nodes
on a stack.  The stack is the result of the iteration.  A @dfs{} is not
reentrant because nodes are marked by setting a field in
@code{ucl_graph_node_t} structures: while a @dfs{} is performed the
graph must be locked for mutual exclusion.

Also, do not modify a graph while a @dfs{} is running: the result is
undefined.


@deftp {Struct Typedef} ucl_graph_dfs_tag_t
@deftpx {One Element Array} ucl_graph_dfs_t
Hold the result of a @dfs{}, both directed and not.  This structure must
be handled as opaque.
@end deftp


@deftp {Struct Typedef} ucl_graph_dfs_item_t
Represent a node touched by the iteration.  Public fields:

@table @code
@item ucl_graph_node_t node
pointer to the node;

@item size_t in_counter
the value of the counter when the node was entered;

@item size_t out_counter
the value of the counter when the node was left.
@end table

The initial value of the counters is zero; the root node of the @dfs{}
is recognisable because it has @code{in_counter = 0}.
@end deftp

@c page
@node graph dfs api
@subsubsection @dfs{} programming interface


@deftypefun void ucl_graph_dfs_initialise_handle (ucl_graph_dfs_t @var{S})
Initialise an already allocated search handle.
@end deftypefun


@deftypefun void ucl_graph_dfs_finalise_handle (ucl_graph_dfs_t @var{S})
Finalise a search handle.  All the memory is released.  A @dfs{} must
@strong{always} be finalised with a call to this function.
@end deftypefun


@deftypefun void ucl_graph_dfs_directed (ucl_graph_dfs_t @var{S}, ucl_graph_node_t @var{root})
Perform a directed @dfs{} over a graph starting from @code{root}; store
the result into @var{S}.
@end deftypefun


@deftypefun void ucl_graph_dfs (ucl_graph_dfs_t @var{S}, ucl_graph_node_t @var{root})
Perform a non--directed @dfs{} over a graph starting from @code{root};
store the result into @var{S}.
@end deftypefun


Example:

@example
ucl_graph_dfs_t         S;
ucl_vector_t            visited_nodes;

ucl_graph_initialise_dfs_handle(S, visited_nodes);
@{
  ucl_iterator_t          I;
  ucl_graph_node_t *      root;

  ucl_graph_dfs_directed(S, root);
  for (ucl_vector_iterator_forward(visited_nodes, I);
       ucl_iterator_more(I); ucl_iterator_next(I))
    @{
      ucl_graph_dfs_item_t *  item;

      item = ucl_iterator_ptr(I);
      do_something_with(item);
    @}
@}
ucl_graph_dfs_finalise_handle(S);
@end example

@c page
@node hash
@section The hash table structure


@cindex Hash table container

A hash table is a structure that maps keys to values in a way that
allows the search operation to be performed with constant time for all
the keys.

@quotation
The hash was inspired by the book on C++ by Bjarne Stroustrup and the
hash structure in the @tcl{} (Tool Command Language) source code, by
John Ousterhout and others (@url{http://www.tcl.tk/} for more about
@tcl{}).  However, no code comes from @tcl{}.
@end quotation

@menu
* hash types::                  Hash table types definitions.
* hash implementation::         How it's done.
* hash creation::               Creating and destroying hash tables.
* hash insertion::              Adding elements to a hash table.
* hash deletion::               Removing elements from a hash table.
* hash ops::                    Various operations on a hash table.
* hash resizing::               Resizing a hash table.
* hash iterator::               Visiting elements in the table.
* hash functions::              Provided hash function.
@end menu

@c page
@node hash types
@subsection Hash table types definitions


@deftp {Struct Typedef} ucl_hash_table_tag_t
@deftpx {One Element Array} ucl_hash_table_t
The base structure.  The vector of buckets is available as the field
@code{ucl_vector_t buckets}.
@end deftp


The @ucl{} hash container collects entries of type
@code{ucl_node_tag_t}, which hold no custom data; we have to at least
associate a key to each node, doing something like this:

@example
typedef struct entry_tag_t @{
  ucl_node_tag_t        node;
  ucl_value_t           key;
@} entry_tag_t;

typedef entry_tag_t *        entry_t;

static ucl_value_t
entry_key (ucl_value_t context UCL_UNUSED, void * L_)
@{
  entry_t    L = L_;
  return L->key;
@}

static const ucl_node_getkey_t getkey = @{
  .data = @{ .pointer = NULL @},
  .func = entry_key
@};
@end example

@noindent
and then use @code{getkey} as last argument to
@cfunc{ucl_hash_initialise}; we can use the key extractor directly like
this:

@example
entry_t         L;
ucl_value_t     K;

K = getkey.func(getkey.data, L);
@end example

@c page
@node hash implementation
@subsection How it's done


A @ucl{} vector of pointers is allocated by the constructor; each
pointer, called ``bucket'' in this document, can be @cnull{} (empty
bucket) or referencing an entry structure.  Entry structures are chained
in a linked list.

@example
            buckets

             ----         -----     -----
            |  o-+------>|entry|-->|entry|
            |----|        -----     -----
empty  .....|NULL|
buckets  .  |----|        -----
         .  |  o-+------>|entry|
         .  |----|        -----    -----
         .  |  o-+--------------->|entry|
         .  |----|                 -----
          ..|NULL|
             ----
@end example

The @ucl{} way of managing a vector is to allocate a block of memory,
with hysteresis, and consider a sub--block of it as ``in use'', that is:
as holding the collected data.  When the hash table is constructed all
the slots are marked as used, even when the bucket is set to
@cnull{}.  Reallocations can cause some of the slots to be unused, but if
we never reallocate the vector all the memory is used to hold buckets.

@c ------------------------------------------------------------

@subsubheading Elements insertion and deletion

When inserting a new entry in the table, the hash function converts the
keys to integers in the range @code{[0, number_of_buckets)}, selecting a
bucket; then the bucket is examined:

@itemize
@item
if it's @cnull{}, it's set to the entry pointer:

@example
before the insertion           after the insertion

   ----                           ----
  |    |                         |    |
   ----     -----                 ----     -----
  |NULL|   |entry|               |  o-+-->|entry|
   ----     -----                 ----     -----
  |    |                         |    |
   ----                           ----
@end example

@item
if it's not @cnull{}, the referenced entry is appended to the new entry
and the bucket is set to a pointer to the new entry:

@example
           ---
 ---   ...|new|               ---
|   | .    ---               |   |
 ---  v  ---     ---          ---     ---     ---     ---
| o-+-->|en1|-->|en2|   ->   | o-+-->|new|-->|en1|-->|en2|
 ---     ---     ---          ---     ---     ---     ---
|   |                        |   |
 ---                          ---
@end example
@end itemize

It's obvious how the extraction operation works.

If the keys are such that the hash function distributes entries
uniformly over all the buckets, the time spent to find an entry is (more
or less) constant.

@c ------------------------------------------------------------

@subsubsection Resizing

Enlarging or restricting the hash table means enlarging or restricting
the vector of buckets.  This happens with rules similar, but not equal,
to the ones for the @code{ucl_vector_t} structure; the differences are:

@itemize
@item
when enlarging all the allocated slots are marked as used, so each
allocated slot becomes a bucket;

@item
when restricting the number of used slots is artificially reduced by the
amount of slots selected with the ``step down'' parameter of the @ucl{}
vector;

@item
when restricting the number of used slots cannot become smaller than the
amount selected by the preprocessor symbol @code{UCL_HASH_MINIMUM_SIZE},
which defaults to @code{13}.
@end itemize

Enlarging and restricting changes the number of buckets, so it requires
a rehashing of all the entries in the table: this is expensive.

@c page
@node hash creation
@subsection Creating and destroying hash tables


The construction of a hash table is split in two steps, to allow custom
configuration of the vector of buckets.  A simple construction, using
the default values, for a table using strings as keys goes like this:

@example
ucl_vector_config_t C;
ucl_vector_t        V;
ucl_hash_table_t    H;

ucl_vector_initialise_config_hash(C);
ucl_vector_alloc(V, C);
ucl_hash_initialise(H, V, ucl_compare_string, ucl_hash_string,
                    ucl_node_getkey_t getkey);
@end example

@noindent
when finalising a hash table we have to release the @ucl{} vector
explicitly, but only after having extracted and released all the table
entries; when using a @ucl{} memory allocator, it goes like this:

@example
ucl_memory_allocator_t  A;
ucl_vector_t            V;
ucl_hash_table_t        H;
entry_t                 E;

while ((E = ucl_hash_first(H)))
  @{
    ucl_hash_extract(H, E);
    A.alloc(A.data, &E, 0);
  @}
ucl_vector_free(V);
@end example

@noindent
the hash table structure does not need finalisation.


@deftypefun void ucl_hash_initialise (ucl_hash_t @var{self}, ucl_vector_t @var{buckets}, ucl_comparison_t @var{compar}, ucl_hash_t @var{hash}, ucl_node_getkey_t @var{getkey})
Initialise the hash table referenced by @var{self}.  The @ucl{} vector
of buckets, already initialised, becomes part of the hash table state.

@var{compar} is the function+context used to compare keys.

@var{hash} is the function+context used to compute the hash value of
keys; @ref{typedefs hash} for details.

@var{getkey} is the function+context used to extract the key from an
entry structures; @ref{typedefs nodes} for details.
@end deftypefun

@c page
@node hash insertion
@subsection Adding elements to a hash table


@deftypefun void ucl_hash_insert (ucl_hash_table_t @var{H}, void * @var{E})
Insert a new entry in the table.  The entry structure must be allocated
and filled with key and value by the user's code; the pointer @var{E} is
internally cast to @code{ucl_node_t}.

Inserting an entry with a key that already exists in the table will
work, but future invocations of @cfunc{ucl_hash_find} will return one or
the other: nobody knows which one.  To avoid collision of keys, we have
to check the existence of a key with @cfunc{ucl_hash_find} before
attempting to insert a new entry.

Example:

@example
ucl_memory_allocator_t  A;
ucl_hash_table_t        H;
entry_t                 E;
ucl_value_t             K;

K = ...
E = ucl_hash_find(H, K);
if (NULL == E)
  @{
    A.alloc(A.data, &E, sizeof(entry_t));
    E->key = K;
    ucl_hash_insert(H, E);
  @}
@end example
@end deftypefun

@c page
@node hash deletion
@subsection Removing elements from a hash table


@deftypefun void ucl_hash_extract (ucl_hash_table_t @var{H}, void * @var{E})
Extract an entry from the table.  @var{E}, a pointer to the entry to be
removed, must be the return value of a previous invocation to
@cfunc{ucl_hash_find}; the pointer @var{E} is internally cast to
@code{ucl_node_t}.  The entry structure is not destroyed nor freed, just
extracted.

Example:

@example
ucl_memory_allocator_t  A;
ucl_hash_t              H;
entry_t                 E;
ucl_value_t             K;

E = ucl_hash_find(H, K);
if (NULL != E)
  @{
    ucl_hash_extract(H, E);
    A.alloc(A.data, &E, 0);
  @}
@end example
@end deftypefun

@c page
@node hash ops
@subsection Various operations on a hash table


@deftypefun {void *} ucl_hash_find (const ucl_hash_table_t @var{H}, const ucl_value_t @var{K})
Search in the table an entry associated with the selected key.  Return a
pointer to the entry or @cnull{} if the key was not found; the returned
pointer can be safely cast to @code{ucl_node_t}.
@end deftypefun


@deftypefun {void *} ucl_hash_first (const ucl_hash_table_t @var{H})
Return a pointer to the first entry in the table: the first link in the
list of the first non--@cnull{} bucket.  If the table is empty: return
@cnull{}; the returned pointer can be safely cast to
@code{ucl_node_t}.
@end deftypefun


@deftypefun size_t ucl_hash_size (const ucl_hash_table_t @var{H})
Return a value representing the number of entries in the table.
@end deftypefun


@deftypefun size_t ucl_hash_number_of_buckets (const ucl_hash_table_t @var{H})
Return the number of buckets.
@end deftypefun


@deftypefun size_t ucl_hash_number_of_used_buckets (const ucl_hash_table_t @var{H})
Return the number of used buckets.
@end deftypefun


@deftypefun size_t ucl_hash_bucket_chain_length (const ucl_hash_table_t @var{this}, ucl_index_t @var{position})
Return the number of entries in the chain refereces by bucket at
@var{position}.  @var{position} must be a valid bucket index: a
non--negative integer in the range @code{[0,
ucl_hash_number_of_buckets(@var{this}))}.
@end deftypefun


@deftypefun double ucl_hash_average_search_distance (const ucl_hash_table_t @var{this})
Return the average number of entries per bucket.
@end deftypefun

@c page
@node hash resizing
@subsection Resizing a hash table


At present the hash table is not enlarged automatically.  The decision
is delegated to the user's code.


@deftypefun void ucl_hash_enlarge (ucl_hash_table_t @var{H})
Enlarge the table using the underlying @ucl{} vector module.  This is an
expensive operation because it requires rehashing all the entries.  If
an error occurs reallocating the vector: the table is not corrupted.
@end deftypefun


@deftypefun void ucl_hash_restrict (ucl_hash_table_t @var{H})
Restrict the table using the underlying @ucl{} vector module.  This is
an expensive operation because it requires rehashing all the entries.
If an error occurs reallocating the vector: the table is not corrupted.
@end deftypefun

@c page
@node hash iterator
@subsection Visiting elements in the table


@deftypefun void ucl_hash_iterator (const ucl_hash_table_t @var{H}, ucl_iterator_t @var{I})
Initialise the table iterator.  The iterator pointer references the
entries in the table.  The order in which the entries are visited is
unknown.

Example:

@example
ucl_hash_table_t  H;
ucl_iterator_t    I;
entry_t           E;

for (ucl_hash_iterator(H, I);
     ucl_iterator_more(I);
     ucl_iterator_next(I))
  @{
    E = ucl_iterator_ptr(I);
  @}
@end example
@end deftypefun

@c page
@node hash functions
@subsection Provided hash function


@deftypevar ucl_hash_t ucl_hash_string
Function and context required to hash strings.  The function is
@cfunc{ucl_hash_string_fun}.
@end deftypevar


@deftypefun size_t ucl_hash_string_fun (ucl_value_t @var{unused}, const ucl_value_t @var{K})
Return an unsigned integer representing the hash value for the string in
@var{K}; the @code{chars} member of @var{K} must be a pointer to a
@cnull{}--terminated string of characters, @ref{typedefs value} for
details.

The hashing algorithm comes from a C++ book by Bjarne Stroustrup
(@ref{references}).
@end deftypefun

@c page
@node list
@section The linked list structure


The @ucl{} list is a way of chaining @code{ucl_node_tag_t} structures in
a doubly linked list; all the functions from the @code{btree} and
@code{tree} modules can be used upon lists.

@menu
* list overview::               How it is done.
* list cons::                   Constructing lists.
* list visit::                  Visiting a list.
* list deletion::               Removing elements from a list.
* list ops::                    Various operations on a list.
* list iteration::              Iteration over a list.
@end menu

@c page
@node list overview
@subsection How it is done


A @ucl{} list is a chain of @code{ucl_node_tag_t} structures in which
the @code{bro} and @code{dad} fields are involved:

@example
           ----  bro   ----  bro   ----  bro
NULL <----| N1 |----->| N2 |----->| N3 |----> NULL
      dad  ---- <----  ---- <----  ----
                 dad         dad
@end example

@noindent
it is equivalent to a level of brothers in the @ucl{} tree module; the
@code{son} field can be set to @cnull{}, or used to reference a nested
list, or used to reference some other value.  The brother of a node is
called @dfn{cdr}, the son of a node is called @dfn{car}.

@quotation
@strong{NOTE} We use the terms @emph{car} and @emph{cdr} to refer to the
son and bro of a node, but notice that their meaning in the context of
the @ucl{} is different from their meaning in the context of Lisp
languages.
@end quotation

Going @emph{forwards} in a list chain means to follow the @code{bro}
pointers; going @emph{backwards} in a list chain means to follow the
@code{dad} pointers.

@c page
@node list cons
@subsection Constructing lists


Structures of type @code{ucl_node_tag_t} must be allocated and released
by the user code.  The fields of a node structure must be set to
@cnull{} when they are not used as reference for another node.

All the following functions return and accept as arguments @code{void *}
values; they are internally cast to @code{ucl_node_t}.


@deftypefun void ucl_list_set_car (void * @var{N}, void * @var{M})
If @var{N} is non--@cnull{}: set @var{M} as @code{son} of @var{N}; if
@var{M} is non--@cnull{}: set @var{N} as @code{dad} of @var{M}.
@ref{btree typedefs} for the meaning of this.
@end deftypefun


@deftypefun void ucl_list_set_cdr (void * @var{N}, void * @var{P})
If @var{N} is non--@cnull{}: set @var{M} as @code{bro} of @var{N}; if
@var{M} is non--@cnull{}: set @var{N} as @code{dad} of @var{M}.
@ref{btree typedefs} for the meaning of this.
@end deftypefun


For example, to build the hierarchy:

@example
 -----    -----    -------
| one |--| two |--| three |-- NULL
 -----    -----    -------
@end example

@noindent
using the @ucl{} memory allocator:

@example
ucl_memory_allocator_t  A;
ucl_node_t              one, two, three;

one   = ucl_malloc(ucl_memory_allocator, UCL_NODE_SIZE);
two   = ucl_malloc(ucl_memory_allocator, UCL_NODE_SIZE);
three = ucl_malloc(ucl_memory_allocator, UCL_NODE_SIZE);

ucl_list_set_cdr(one, two);
ucl_list_set_cdr(two, three);
@end example

@noindent
remember that the @ucl{} default allocator sets to zero every newly
allocated block, so the fields in the allocated nodes are automatically
set to @cnull{}.

@c page
@node list visit
@subsection Visiting a list


All the following functions return and accept as arguments @code{void *}
values; they are internally cast to @code{ucl_node_t}.  @ref{btree
typedefs} for the meaning of the fields of @code{ucl_node_tag_t}.


@deftypefun {void *} ucl_list_car (void * @var{N})
Return the @code{son} of @var{N}.
@end deftypefun


@deftypefun {void *} ucl_list_cdr (void * @var{N})
Return the @code{bro} of @var{N}.
@end deftypefun


@deftypefun {void *} ucl_list_prev (void * @var{N})
Return the @code{dad} of @var{N}.
@end deftypefun


@deftypefun {void *} ucl_list_first (void * @var{N})
Return the first element of the list.
@end deftypefun


@deftypefun {void *} ucl_list_last (void * @var{N})
Return the last element of the list.
@end deftypefun


@deftypefun {void *} ucl_list_ref (void * @var{N}, ucl_index_t @var{position})
Assuming @var{N} references the first node in a list: return a pointer
to the link at @var{position} (zero based), or @cnull{} if the index is
out of range.
@end deftypefun


When using the following operations, it is impossible to distinguish
between a @cnull{} representing a legitimate return value and a @cnull{}
representing a return from an invalid operation; we have to take care of
applying these operations only when they are legitimate.


@deftypefun {void *} ucl_list_caar (void * @var{N})
Apply twice the car operator.  Return @cnull{} if the operation is
invalid.
@end deftypefun


@deftypefun {void *} ucl_list_cadr (void * @var{N})
Apply the cdr operator, then the car operator.  Return @cnull{} if the
operation is invalid.
@end deftypefun


@deftypefun {void *} ucl_list_cdar (void * @var{N})
Apply the car operator, then the cdr operator.  Return @cnull{} if the
operation is invalid.
@end deftypefun


@deftypefun {void *} ucl_list_cddr (void * @var{N})
Apply twice the cdr operator.  Return @cnull{} if the operation is
invalid.
@end deftypefun


@deftypefun {void *} ucl_list_caaar (void * @var{N})
Apply the car operator three times.  Return @cnull{} if the operation is
invalid.
@end deftypefun


@deftypefun {void *} ucl_list_caadr (void * @var{N})
Apply the cdr operator, then the car operator twice.  Return @cnull{} if
the operation is invalid.
@end deftypefun


@deftypefun {void *} ucl_list_cadar (void * @var{N})
Apply the car operator, then the cdr operator, then the car operator.
Return @cnull{} if the operation is invalid.
@end deftypefun


@deftypefun {void *} ucl_list_caddr (void * @var{N})
Apply the cdr operator twice, then the car operator.  Return @cnull{} if
the operation is invalid.
@end deftypefun


@deftypefun {void *} ucl_list_cdaar (void * @var{N})
Apply the car operator twice, then the cdr operator.  Return @cnull{} if
the operation is invalid.
@end deftypefun


@deftypefun {void *} ucl_list_cdadr (void * @var{N})
Apply the cdr operator, then the car operator, then the cdr operator.
Return @cnull{} if the operation is invalid.
@end deftypefun


@deftypefun {void *} ucl_list_cddar (void * @var{N})
Apply the car operator, then the cdr operator twice.  Return @cnull{} if
the operation is invalid.
@end deftypefun


@deftypefun {void *} ucl_list_cdddr (void * @var{N})
Apply the cdr operator three times.  Return @cnull{} if the operation is
invalid.
@end deftypefun

@c page
@node list deletion
@subsection Removing elements from a list


All the following functions return and accept as arguments @code{void *}
values; they are internally cast to @code{ucl_node_t}.  @ref{btree
typedefs} for the meaning of the fields of @code{ucl_node_tag_t}.


@deftypefun {void *} ucl_list_remove (void * @var{N})
Remove @var{N} from its chain; return @var{N} itself.
@end deftypefun


@deftypefun {void *} ucl_list_popfront (void * @var{N}, void ** @var{new_first})
Remove an element at the beginning of the list of which @var{N} is an
element.  Return a pointer to the removed element; store in
@var{new_first} a pointer to the new first element of the list.
@end deftypefun


@deftypefun {void *} ucl_list_popback (void * @var{N})
Remove an element at the end of the list of which @var{N} is an element.
@end deftypefun

@c page
@node list ops
@subsection Various operations on a list


All the following functions return and accept as arguments @code{void *}
values; they are internally cast to @code{ucl_node_t}.  @ref{btree
typedefs} for the meaning of the fields of @code{ucl_node_tag_t}.


@deftypefun size_t ucl_list_length (void * @var{N})
Return the count of elements in the list from @var{N} towards the end.
@end deftypefun


@deftypefun void ucl_list_for_each (ucl_callback_t @var{cb}, void * @var{N})
Apply the callback to @var{N} and all its brothers up to the end of the
list.
@end deftypefun


@deftypefun void ucl_list_map (void * @var{P}, ucl_callback_t @var{cb}, void * @var{Q})
Apply the callback to @var{P} and @var{Q}, and all their brothers up to
the end of the @var{P} list.  @var{Q} is meant to be the source value
and @var{P} the destination value.
@end deftypefun


@deftypefun {void *} ucl_list_reverse (void * @var{N})
Assuming @var{N} is the first element of a list: reverse the list and
return it new first element.
@end deftypefun

@c page
@node list iteration
@subsection Iteration over a list


Example of forward iteration:

@example
ucl_node_t        N;

while (N) @{
  /* do something with N */
  N = ucl_list_cdr(N);
@}
@end example

@noindent
example of backward iteration:

@example
ucl_node_t        N;

while (N) @{
  /* do something with N */
  N = ucl_list_prev(N);
@}
@end example

@c page
@node map
@section The map structure

@cindex Map container

The map container structure can be used to implement an associative
array; it's implemented as an @acronym{AVL} tree.

@quotation
The map/multimap idea was inspired by the book on C++ by Bjarne
Stroustrup and by the STL C++ (Standard Template Library) by Stepanov
and Lee.

The handling of nodes is influenced by the handling of elements in the
@acronym{TCL} (Tool Command Language) hash table by John Ousterhout and
others (@url{http://www.tcl.tk/} for more about @acronym{TCL}).
@end quotation

@menu
* map intro::                   Introduction to operations and
                                implementation.
* map types::                   Type definitions for map.
* map creation::                Creating and destroying maps.
* map insertion::               Adding elements to a map.
* map deletion::                Removing elements from a map.
* map ops::                     Various operations on a map.
* map iterators::               Iteration over a map.
* map set::                     Composing map iterators.
@end menu

@c page
@node map intro
@subsection Introduction to operations and implementation


Maps are often used as associative arrays, that is: as collections of
key/value pairs.  The operations we want to do on a map are:

@itemize
@item
add a key/value pair (or just a key) to a collection, if the element
already exists replace the old value with the new one or add a new
key/value pair;

@item
find a key/value pair with a specified key;

@item
remove all key/value pairs with a selected key, or the one with a
selected value among the ones having the same key;

@item
traverse the collection of key/value pairs from the lesser key to the
greater;

@item
traverse the collection of key/value pairs from the greater key to the
lesser.
@end itemize

Clearly there are two sub--types of map container: the one that allows
multiple values to be associated to the same key, and the one that does
not.  We call the first a @dfn{multimap} and the second a @dfn{simple
map}.

@c page
@node map types
@subsection Type definitions for map


@deftp {Struct Typedef} ucl_map_tag_t
@deftpx {Single Element Array Typedef} ucl_map_t
Base structure for the container.  It must be allocated by the user's
code.
@end deftp


The @ucl{} map container collects nodes of type @code{ucl_node_tag_t},
which hold no custom data; we have to at least associate a key to each
node, doing something like this:

@example
typedef struct link_tag_t @{
  ucl_node_tag_t        node;
  ucl_value_t           key;
@} link_tag_t;

typedef link_tag_t *        link_t;

static ucl_value_t
link_key (ucl_value_t context UCL_UNUSED, void * L_)
@{
  link_t    L = L_;
  return L->key;
@}

static const ucl_node_getkey_t getkey = @{
  .data = @{ .pointer = NULL @},
  .func = link_key
@};
@end example

@noindent
and then use @code{getkey} as last argument to
@cfunc{ucl_map_initialise}; we can use the key extractor directly like
this:

@example
link_t          L;
ucl_value_t     K;

K = getkey.func(getkey.data, L);
@end example

@c page
@node map creation
@subsection Creating and destroying maps


@deftypefun void ucl_map_initialise (ucl_map_t @var{M}, unsigned int @var{flags}, ucl_comparison_t @var{keycmp}, ucl_node_getkey_t @var{getkey})
Initialise an already allocated map structure.  @var{M} must be a
pointer to an already allocated map structure; pointer to the already
allocated map structure; @var{flags} configures the map behaviour;
@var{keycmp} is the function+context used to compare keys; @var{getkey}
is the function+context used to extract the key from nodes.

Map configuration @var{flags} can be zero of an ORed combination of:

@table @code
@item UCL_ALLOW_MULTIPLE_OBJECTS
Allows more than one object to be associated to the same key, with this
the map behaves like a multimap.
@end table

The map structure needs no destructor, but before releasing its memory
block the user code has to extract all the nodes from the map.
@end deftypefun

@c page
@node map insertion
@subsection Adding elements to a map


The following functions accept @code{void *} as arguments and return
values; internally these pointers are cast to @code{ucl_node_t}.


@deftypefun ucl_bool_t ucl_map_insert (ucl_map_t @var{M}, void * @var{L})
Given an already allocated and constructed map link, insert it in the
map.

An invocation to this function always inserts @var{L} into @var{M} if
@var{M} is a multimap.  If @var{M} is a simple map: @var{L} is inserted
only if there is no link in @var{M} having key equal to the key of
@var{L}.

The return value is true if the link has been inserted, or false if the
link was not inserted.
@end deftypefun

@c page
@node map deletion
@subsection Removing elements from a map


The following functions accept @code{void *} as arguments and return
values; internally these pointers are cast to @code{ucl_node_t}.


@deftypefun void ucl_map_delete (ucl_map_t @var{M}, void * @var{L})
Remove the node @var{L} from the referenced map.  @var{L} must be the
return value of a previous invocation to @cfunc{ucl_map_find}.  This
function only removes the link from the map, it's our responsibility to
free the memory and resources associated to it.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Introduction to the deletion algorithm

This is a brief introduction to make it easier to understand the @ucl{}
source code.

To remove a node from an @avl{} search tree: first we push it down the
tree so that it becomes a leaf, then we detach it, finally we step up in
the tree updating the status of the parent nodes.

It is always possible to swap the node @math{N} of a binary search tree
with the rightmost element in its son's subtree, or the leftmost element
in its bro's subtree, keeping correct both the tree ordering and the
statuses of all the nodes but @math{N} itself; this is a desirable
operation because detaching a leaf is really easy.

We mark the status of a node with @samp{=} for equal depth, @samp{s} for
son deeper, @samp{b} for bro deeper.  For example, pushing down the node
@math{20} in the following tree:

@example
20s--30=        15s--30=
 |               |
10=--15=   =>   10=--20
 |               |
 5=              5=
@end example

@noindent
keeps correct ordering and statuses, with the exception of @math{20}; we
see that @math{15} gets the status that @math{20} had.

We can then detach @math{20}: the resulting tree is no more balanced and
the statuses are no more correct; we can fix them by stepping up the
tree.  Node @math{10} lost the bro so now it is son deeper:

@example
 15s--30=
  |
*10s
  |
  5=
@end example

@noindent
removing @math{20} has not changed the depth of the subtree of
@math{10}, so node @math{15} must not change its state.

@example
*15s--30=
  |
 10s
  |
  5=
@end example

A more complex example, removing @math{3} in the tree below by pushing
it down its bro subtree.  First we swap it with @math{4}, which is the
leftmost in the bro subtree:

@example
3b------7=--8b--9=      4b------7=--8b--9=
|       |               |       |
1=--2=  5=--6=      =>  1=--2=  5=--6=
|       |               |       |
0=      4=              0=      3
@end example

@noindent
then we detach it adjusting the status of its dad, notice that the
subtree of @math{5} has @strong{not} got shorter:

@example
4b------7=--8b--9=      4b------7=--8b--9=
|       |               |       |
1=--2=  5=--6=      =>  1=--2= *5b--6=
|                       |
0=      3               0=
@end example

@noindent
then we step up to node @math{7}, we do not need to adjust its status
because the subtree we come from has not got shorter:

@example
                                *
4b------7=--8b--9=      4b------7=--8b--9=
|       |               |       |
1=--2= *5b--6=      =>  1=--2=  5b--6=
|                       |
0=                      0=
@end example

@noindent
finally we step up to node @math{4}, we do not need to adjust its status
because the subtree we come from has not got shorter:

@example
*
4b------7=--8b--9=
|       |
1=--2=  5b--6=
|
0=
@end example

Now what if we remove @math{6}?  We adjust the status of @math{5} and
notice that its subtree has got shorter:

@example
4b------7=--8b--9=
|       |
1=--2= *5=
|
0=
@end example

@noindent
then we step up to node @math{7}; it was equal depth before and its
son's subtree has got shorter: its new status is bro deeper; the subtree
of @math{7} has @strong{not} got shorter because its previous status was
equal depth:

@example
        *
4b------7b--8b--9=
|       |
1=--2=  5=
|
0=
@end example

@noindent
finally we step up to node @math{4}, we do not need to adjust its status
because the subtree we come from has not got shorter.

Now let's remove node @math{9} and adjust the status of its dad; the
subtree of @math{8} has got shorter:

@example
            *
4b------7b--8=
|       |
1=--2=  5=
|
0=
@end example

@noindent
the we step up to node @math{7}: we come from its bro subtree, which has
got shorter, and its status is bro deeper; the new status of @math{7} is
equal depth; the subtree of @math{7} has got shorter, because it was bro
deeper before:

@example
        *
4b------7=--8=
|       |
1=--2=  5=
|
0=
@end example

@noindent
finally we step up to node @math{4}: its status is bro deeper and we
come from a bro subtree which has got shorter; the new status of
@math{4} is equal depth:

@example
*
4=------7=--8=
|       |
1=--2=  5=
|
0=
@end example

@c page
@node map ops
@subsection Various operations on a map


The following functions accept @code{void *} as arguments and return
values; internally these pointers are cast to @code{ucl_node_t}.


@deftypefun size_t ucl_map_count (const ucl_map_t @var{M}, const ucl_value_t @var{key})
Return the number of elements with @var{key}; this is always 0 or 1 for
simple maps.
@end deftypefun


@deftypefun {void *} ucl_map_find (const ucl_map_t @var{M}, const ucl_value_t @var{key});
Return a pointer to the (first found) element associated with @var{key}.
The return value is @cnull{} if such an element doesn't exist.

For a multimap, this function returns a pointer to the first element
with the selected key, so that the others can be found with repeated
invocations of @cfunc{ucl_map_next}.
@end deftypefun


@deftypefun ucl_bool_t ucl_map_find_node (const ucl_map_t @var{M}, void * @var{N})
Return true if @var{N} is the pointer to a node in @var{M}, return false
otherwise.
@end deftypefun


@deftypefun {void *} ucl_map_first (const ucl_map_t @var{M})
Return a pointer to the element with lesser key in the map, or @cnull{}
if the map is empty.
@end deftypefun


@deftypefun {void *} ucl_map_last (const ucl_map_t @var{M})
Return a pointer to the element with greater key in the map, or @cnull{}
if the map is empty.
@end deftypefun


@deftypefun {void *} ucl_map_next (const void * @var{L})
Return a pointer to the element adjacent to the one referenced by
@var{L} with greater key, or @cnull{} if @var{L} has the greater key in
the map.
@end deftypefun


@deftypefun {void *} ucl_map_prev (const void * @var{L})
Return a pointer to the element adjacent to the one referenced by
@var{L} with lesser key, or @cnull{} if @var{L} has the lesser key in
the map.
@end deftypefun


@deftypefun {void *} ucl_map_find_or_next (const ucl_map_t @var{M}, const ucl_value_t @var{key})
Given a key find the element in the map associated with it, or the
element with the lesser key greater than the selected one; if there are
multple links having key equal to @var{key}, select the rightmost one.
Return a pointer to the requested link or @cnull{} if all the keys in
the map are lesser than the selected one.
@end deftypefun


@deftypefun {void *} ucl_map_find_or_prev (const ucl_map_t @var{M}, const ucl_value_t @var{key})
Given a key find the element in the map associated with it, or the
element with the greater key lesser than the selected one; if there are
multple links having key equal to @var{key}, select the leftmost one.
Return a pointer to the requested link or @cnull{} if all the keys in
the map are greater than the selected one.
@end deftypefun


@deftypefun size_t ucl_map_size (const ucl_map_t @var{M})
Return the number of elements in the map.
@end deftypefun


@deftypefun void * ucl_map_root (const ucl_map_t @var{M})
Return a pointer to the current root node.
@end deftypefun


@deftypefun size_t ucl_map_depth (const ucl_map_t @var{M})
Return the depth of the tree.
@end deftypefun

@c page
@node map iterators
@subsection Iteration over a map


For the map, the iteration is over the map links:
@cfunc{ucl_iterator_ptr} returns a pointer to the current map link.  We
can use the @cfunc{ucl_map_getkey} and @cfunc{ucl_map_setkey} to acquire
the keys and values.


@deftypefun void ucl_map_iterator_inorder (const ucl_map_t @var{M}, ucl_iterator_t @var{I})
@deftypefunx void ucl_map_iterator_preorder (const ucl_map_t @var{M}, ucl_iterator_t @var{I})
@deftypefunx void ucl_map_iterator_postorder (const ucl_map_t @var{M}, ucl_iterator_t @var{I})
@deftypefunx void ucl_map_iterator_levelorder (const ucl_map_t @var{M}, ucl_iterator_t @var{I})
Initalise an inorder, preorder, postorder or breadth first iteration.
@ref{btree iteration}, for details.
@end deftypefun


@deftypefun void ucl_map_lower_bound (const ucl_map_t @var{M}, ucl_iterator_t @var{I}, ucl_value_t @var{key})
Initialise an iteration over the elements with the selected key,
starting with the first element.
@end deftypefun


@deftypefun void ucl_map_upper_bound (const ucl_map_t @var{M}, ucl_iterator_t @var{I}, ucl_value_t @var{key})
Initialise an iteration over the elements with the selected key,
starting with the last element.
@end deftypefun

@c page
@node map set
@subsection Composing map iterators

@cindex Set iterators

It's possible to compose map iterators to implement set operations: the
keys from a map are used as set elements, the values are not considered.
A set operation is implemented as an iterator that visits one by one the
result of the operation itself.

The key values must be of the same data type.  That means that the
compare function used by both the maps, must accept the same type of
values and return the same values when called with the same arguments.

For all the set iterators, the arguments are:

@table @code
@item ucl_iterator_t @var{it1}
pointer to an in--order iterator over set 1, already initialised;

@item ucl_iterator_t @var{it2}
pointer to an in--order iterator over set 2, already initialised;

@item ucl_iterator_t @var{iter}
pointer to the set iterator structure.
@end table

The input map iterators must be of in--order type: if the sequences are
visited from the lesser to the greater key, the minimum amount of key
comparison is performed.

If the sequences are not visited with the in--order iterator, the result
is not defined.

The set iterators are used in the same fashion of all the other
iterators in the @acronym{UCL} (@ref{iterators}).  The value retrieved
with @function{ucl_iterator_ptr} is the pointer to the referenced map
link.


@deftypefun void ucl_map_iterator_union (@var{it1}, @var{it2}, @var{iter})
Initialise the iteration over all the elements from both the
sequences.  Elements present in both sequences are included twice.
@end deftypefun


@deftypefun void ucl_map_iterator_intersection (@var{it1}, @var{it2}, @var{iter})
Initialise  the iteration  over all  the elements  present in  both the
sequences.  Elements included in only one sequence are discarded.
@end deftypefun


@deftypefun void ucl_map_iterator_complintersect (@var{it1}, @var{it2}, @var{iter})
Initialise the iteration over all the elements present in only one of
the two sequences.
@end deftypefun


@deftypefun void ucl_map_iterator_subtraction (@var{it1}, @var{it2}, @var{iter})
Initialise the iteration over all the elements from sequence 1 that are
not present in sequence 2.
@end deftypefun


Example:

@example
Sequence 1: 0 1 2 3 4 5 6
Sequence 2: 4 5 6 7 8 9
Union: 0 1 2 3 4 4 5 5 6 6 7 8 9
Intersection: 4 5 6
Complementary intersection: 0 1 2 3 7 8 9
Subtraction: 0 1 2 3
@end example

@c page
@node vector
@section The vector structure


@cindex Vector container


The vector container is an implementation of array, with hysteresis in
memory allocation.

@quotation
@strong{NOTE} This module was inspired by the book on C++ by Bjarne
Stroustrup and by the @acronym{STL} C++ (Standard Template Library).
@end quotation

@quotation
@strong{NOTE} In the following documentation, when describing valid
values for vector indexes, we denote a range of values with @code{[min,
max)}, where @code{[} means inclusive bound and @code{(} means exclusive
bound.
@end quotation

@menu
* vector implementation::       How it's done.
* vector typedefs::             Type definitions
* vector creation::             Creating and destroying vectors.
* vector indexes::              Converting indexes to pointers.
* vector adding::               Adding elements to a vector.
* vector removing::             Removing elements from a vector.
* vector ops::                  Various operations on a vector.
* vector find::                 Finding elements.
* vector iteration::            Iteration over a vector.
* vector memory::               Allocating and freeing memory.
* vector as pqueue::            Using a vector as a priority queue.
* vector high::                 High level functions.
@end menu

@c page
@node vector implementation
@subsection How it's done


This container is heavyweight: its complexity is overkill for simple
arrays with fixed size.

The vector structure can be allocated anywhere; the data area is always
dynamically allocated and it is described by four pointers of type
@code{uint8_t *}:

@example
first_allocated_slot    first_used_slot
last_allocated_slot     last_used_slot
@end example

A @dfn{slot} is a section of the allocated memory that can hold an
element; the dimension of the slots is configured at vector
initialisation time.  A @dfn{free slot} is a slot that does not contain
an element; free slots can be present at the beginning and end of the
allocated memory.  A @dfn{used slot} is a slot that holds an element;
used slots are always contiguous in the allocated memory.

@c ------------------------------------------------------------

@subsubheading Pointer usage charts

Pointers when some slot is used:

@example
 free     used slots           free
|'''''|.................|''''''''''''''''''''|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
^     ^              ^                    ^
|     |              |                    last_allocated_slot
|     |              |
|     |              last_used_slot
|     |
|     first_used_slot
|
first_allocated_slot
@end example

@noindent
pointers when the used area is attached to the beginning of the
allocated memory:

@example
      used slots           free
|.................|''''''''''''''''''''''''''|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
^              ^                          ^
|              |                          last_allocated_slot
|              |
|              last_used_slot
|
first_allocated_slot == first_used_slot
@end example

@noindent
pointers when the used area is attached to the end of the allocated
memory:

@example
   free slots           used slots
|''''''''''''''|.............................|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
^              ^                          ^
|              |         last_allocated_slot == last_used_slot
|              |
|              first_used_slot
|
first_allocated_slot
@end example

@noindent
pointers when the allocated memory is full (all the slots are used):

@example
                 used slots
|............................................|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
^                                         ^
|                        last_allocated_slot == last_used_slot
|
|
|
first_allocated_slot == first_used_slot
@end example

@noindent
pointers when only one slot is used:

@example
      used
 free slot              free
|'''''|..|'''''''''''''''''''''''''''''''''''|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
^     ^                                   ^
|     |                                   last_allocated_slot
|     |
|     first_used_slot == last_used_slot
|
first_allocated_slot
@end example

@noindent
pointers when the vector is empty and a non-zero pad area was
configured:

@example
  free pad           free slots
  area
|'''''''''''|''''''''''''''''''''''''''''''''|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
^        ^  ^                             ^
|        |  |                             last_allocated_slot
|        |  first_used_slot
|        |
|        last_used_slot
|
first_allocated_slot
@end example

@noindent
pointers when the vector is empty and a zero pad area was configured:

@example
                    free slots
   |''''''''''''''''''''''''''''''''''''''''''''|
|__|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
^  ^                                         ^
|  |                                         last_allocated_slot
|  |
|  first_allocated_slot == first_used_slot
|
last_used_slot
@end example

@c ------------------------------------------------------------

@subsubheading Pointers usage rules

@itemize
@item
@code{first_allocated_slot} references the first byte/slot of the
allocated memory; its value is modified only when the memory is
reallocated.

It represents the mimimum allowed value of @code{first_used_slot}; when
the two are equal: it means that the used area is attached to the
beginning of the allocated block.

@item
@code{last_allocated_slot} references the last slot of the allocated
memory (not the last byte, unless the size of the slot is one); its
value is modified only when the memory is reallocated and is always:

@example
last_allocated_slot == first_allocated_slot
  + slot_dimension * allocated_slot_number
@end example

It represents the maximum allowed value for @code{last_used_slot}; when
the two are equal: it means that the used area is attached to the end of
the allocated block.

@item
When some slot is used: @code{first_used_slot} references the first slot
that holds data and it can be casted to the type of contained elements,
to reference the first element in the array.

When the vector is empty: @code{first_used_slot} references the first
byte after a (dynamic and configurable) padding area; if the size of the
padding area is zero: its value is equal to @code{first_allocated_slot}.

@code{first_used_slot} can be accessed to start a forward iteration over
all the elements in the array.

@item
When the array is used: @code{last_used_slot} references the first byte
of the last used slot.

When the array is empty: @code{last_used_slot} has the value of
@code{first_used_slot} minus the slot dimension.

@code{last_used_slot} can be accessed to start a backward iteration over
all the elements in the array.

@item
When some slot is used, it is always:

@example
first_used_slot <= last_used_slot
@end example

@noindent
the two are equal when only one slot is used; it must always be:

@example
number_of_used_slots * slot_dimension ==
     last_used_slot - first_used_slot + slot_dimension
@end example

@item
When no slots are used, it is always:

@example
first_used_slot == last_used_slot + slot_dimension
@end example

@noindent
and @code{first_used_slot} is set to reference the beginning of the
padding area.  We use this definition of empty vector so that it is
possible to iterate with:

@example
uint8_t *   p;

for (p =  vector->first_used_slot;
     p <= vector->last_used_slot;
     p += vector->slot_dimension) @{ ... @}

for (p =  vector->last_used_slot;
     p >= vector->first_used_slot;
     p -= vector->slot_dimension) @{ ... @}
@end example
@end itemize

The padding area, whose starting size can be configured, has the purpose
of allowing fast insertion of elements at the beginning, with no
reallocation of the memory block.

@c page
@node vector typedefs
@subsection Type definitions


@deftp {Struct Typedef} ucl_vector_tag_t
@deftpx {One Element Array Typedef} ucl_vector_t
The data type of the base structure; it must be allocated by the user
code.  @ref{vector memory} for deatils on (re)allocation.
@end deftp


@deftp {Struct Typedef} ucl_vector_config_tag_t
@deftpx {One Element Array Typedef} ucl_vector_config_t
Data structure used to configure a vector; it must be allocated by the
user code; public fields description follows.

@table @code
@item size_t slot_dimension
This is the array stride, which, in simple cases, is the size, in bytes,
of the elements the vector will hold; it should be the result of the
@code{sizeof()} operator applied to the data type, possibly normalised
to a multiple of @math{4} or something.

@item size_t number_of_slots
The number of slots to allocate.

@item ucl_index_t step_up
The number of slots to add when reallocating the array to enlarge it, it
must be a non--zero positive integer.

@item ucl_index_t step_down
The number of free slots that will trigger the reallocation of he array
for restriction, it must be a non--zero positive integer.

@item ucl_index_t size_of_padding_area
The numer of slots to keep free, if possible, at the beginning of the
array when moving elements (during insertion, deletion and reallocation),
it must be non--negative integer.

@item ucl_comparison_t compar
Function and context used to compare elements; this function is used
only by the sort operations, so this field can be left blank if no sort
operations are required; @ref{typedefs compar} for details.

@item ucl_memory_allocator_t allocator
The memory allocator to use for the data area; @ref{memory typedefs} for
details.
@end table
@end deftp


@deftp {Struct Typedef} ucl_vector_array_t
Holds an array of vectors.  Public slots:

@table @code
@item size_t number_of_vectors
the number of vectors in the array;

@item ucl_vector_tag_t ** vectors
array of pointers to vectors; this type implies no assumption upon the
origin of the array memory, it can be statically or dynamically
allocated, or it can be on the stack.
@end table

To declare an array of vectors we can do:

@example
#define NUMBER  1000

ucl_vector_tag_t *    vectors[NUMBER];
ucl_vector_array_t    array = @{
  .number_of_vectors = NUMBER,
  .vectors           = vectors
@};
@end example
@end deftp

@c page
@node vector creation
@subsection Creating and destroying vectors


The construction of a new vector is a @math{3}--step sequence:
declaration, configuration, allocation:

@example
ucl_vector_config_t     C;
ucl_vector_t            V;
size_t  slot_dimension  = ...;
size_t  number_of_slots = ...;

ucl_vector_initialise_config(C, slot_dimension, number_of_slots);
ucl_vector_alloc(V, C);
@end example

@noindent
if we want to set custom values:

@example
ucl_vector_config_t     C;
ucl_vector_t            V;
size_t  slot_dimension  =   16;
size_t  number_of_slots = 1024;

ucl_vector_initialise_config(C, slot_dimension, number_of_slots);
C->step_up              = 128;
C->step_down            = 264;
C->size_of_padding_area =  32;
ucl_vector_alloc(V, C);
@end example

@c ------------------------------------------------------------

@subsubheading Configuration functions


After the invocation to the configuration functions, the user's code may
override the default values by explicitly setting them before invoking
the allocator function.  All the functions select
@cfunc{ucl_memory_alloc} as allocation function and set to zero the
comparison structure.


@deftypefun void ucl_vector_initialise_config (ucl_vector_config_t @var{C}, size_t @var{slot_dimension}, size_t @var{number_of_slots})
Initialise a vector configuration structure with default values.
@end deftypefun


@deftypefun void ucl_vector_initialise_config_buffer (ucl_vector_config_t @var{C})
Initialise a vector configuration structure for a vector used as byte
buffer.
@end deftypefun


@deftypefun void ucl_vector_initialise_config_hash (ucl_vector_config_t @var{C})
Initialise a vector configuration structure for a vector used as hash
table buckets collector.
@end deftypefun


@deftypefun void ucl_vector_initialise_config_dfs (ucl_vector_config_t @var{C})
Initialise a vector configuration structure for a vector used as
depth--first search data for the graph container.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Default values


The following are the default values
@cfunc{ucl_vector_initialise_config} puts into the
@code{ucl_vector_config_t} structure: a set of preprocessor symbols
declared in @file{ucl.h}.  The declarations allow overriding, they are
in the form:

@example
#ifndef UCL_VECTOR_DEFAULT_STEP_UP
#  define UCL_VECTOR_DEFAULT_STEP_UP     8
#endif
@end example


@defmac UCL_VECTOR_DEFAULT_STEP_UP 8
Default value for the @code{step_up} structure field.
@end defmac


@defmac UCL_VECTOR_DEFAULT_STEP_DOWN 10
Default value for the @code{step_down} structure field.
@end defmac


@defmac UCL_VECTOR_DEFAULT_PAD 3
Default value for the @code{size_of_padding_area} structure field.
@end defmac

@c ------------------------------------------------------------

@subsubheading Construction and destruction functions


@deftypefun void ucl_vector_alloc (ucl_vector_t @var{V}, ucl_vector_config_t @var{C})
Allocate memory with the selected @ucl{} allocator and initialise the
fields of @var{V}.

If the @code{step_up} field holds a value greater than the
@code{step_down} field: the @code{step_down} field is changed to
@code{step_up+1}.  @ref{vector memory} for details.
@end deftypefun


@deftypefun void ucl_vector_free (ucl_vector_t @var{V})
Release the memory allocate in @var{V} and set to zero all its fields.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_running (const ucl_vector_t @var{V})
Return true if the vector has been constructed.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Inspection functions


@deftypefun size_t ucl_vector_number_of_step_up_slots (const ucl_vector_t @var{V})
Return the number of stup up slots.
@end deftypefun


@deftypefun size_t ucl_vector_number_of_step_down_slots (const ucl_vector_t @var{V})
Return the number of step down slots.
@end deftypefun


@deftypefun size_t ucl_vector_number_of_padding_slots (const ucl_vector_t @var{V})
Return the number of padding slots.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Updating configuration functions


The following functions can be applied to an already constructed vector.


@deftypefun void ucl_vector_update_number_of_step_up_slots (ucl_vector_t @var{V}, size_t @var{step_up})
Update the number of the step up slots.
@end deftypefun


@deftypefun void ucl_vector_update_number_of_step_down_slots (ucl_vector_t @var{V}, size_t @var{step_down})
Update the number of the step down slots.
@end deftypefun


@deftypefun void ucl_vector_update_number_of_padding_slots (ucl_vector_t @var{V}, size_t @var{padding})
Update the number of the padding slots.
@end deftypefun


@deftypefun void ucl_vector_set_compar (ucl_vector_t @var{V}, ucl_comparison_t @var{compar})
Register the function+context used to compare elements.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Special functions


@deftypefun void ucl_vector_mark_all_slots_as_used (ucl_vector_t @var{V})
Set the fields of @var{V} to describe a vector that uses all the
allocated memory.  This is for special vector usage.
@end deftypefun


@deftypefun void ucl_vector_mark_allocated_range_as_used (ucl_vector_t @var{V}, ucl_range_t @var{range})
Mark a range of slots as used.  This destroys the previous concept of
used slots.  Notice that @var{range} is relative to the allocated slots,
not to the previously used slots.
@end deftypefun


@deftypefun void ucl_vector_reset (ucl_vector_t @var{V})
Reset the internal fields so that the vector appears to be empty.  The
allocated slots memory is not touched.
@end deftypefun


@deftypefun void ucl_vector_clean (ucl_vector_t @var{V})
Set all the allocated memory to null bytes, without touching anything
else.
@end deftypefun


@deftypefun void ucl_vector_swallow_block (ucl_vector_t @var{V}, ucl_vector_config_t @var{C}, ucl_block_t @var{block})
A replacement for @function{ucl_vector_alloc} that takes an already
allocated block as data area; it is mandatory for the size of the block
to be an integer multiple of the slot's dimension.  The vector is
initialised to be full: all the slots are marked as used.

The responsibility of the block memory is transferred to the vector, so
the block must be freed only by calling @function{ucl_vector_free}; this
means that the memory will be freed by the allocator registered in
@var{C}.
@end deftypefun

@c page
@node vector indexes
@subsection Converting indexes to pointers


@menu
* vector indexes i2p::          Index to pointer conversion.
* vector indexes p2i::          Pointer to index conversion.
* vector indexes validation::   Validating indexes.
* vector indexes range::        Range functions.
* vector indexes block::        Range/block conversion.
@end menu

@c page
@node vector indexes i2p
@subsubsection Index to pointer conversion


@deftypefun {void *} ucl_vector_index_to_slot (const ucl_vector_t @var{V}, ucl_index_t @var{index})
Convert @var{index} into the corresponding pointer to a slot in the
vector.  Return a pointer to the selected slot, or @cnull{} if the
selected index is out of range.  The range of valid values for
@var{index} is @code{[0, @var{size})}, where @var{size} is the return
value of @cfunc{ucl_vector_size}.

Applying @cfunc{ucl_vector_enlarge} or @cfunc{ucl_vector_restrict} to
@var{V} invalidates the return value of this function.

Example:

@example
ucl_vector_config_t     C;
ucl_vector_t            V;
int *                   P;
int                     D;

ucl_vector_initialise_config(C, sizeof(int), 1024);
ucl_vector_alloc(V, C);
fill_with_values(V);

P = ucl_vector_index_to_slot(V, 13);
if (P)
  D = *P;
else
  error();
@end example
@end deftypefun


@deftypefun {void *} ucl_vector_index_to_new_slot (const ucl_vector_t @var{V}, ucl_index_t @var{index})
Convert @var{index} into the corresponding pointer to a slot in the
vector.  This is different from @cfunc{ucl_vector_index_to_slot} in that
the requested position can be one unit greater than the last position in
the vector: that way the returned value can be used with
@cfunc{ucl_vector_insert} to append an element to the end of the vector.

Return a pointer to the selected slot, or @cnull{} if the selected index
is out of range.  The range of valid values for @var{index} is @code{[0,
@var{size}]}, where @var{size} is the return value of
@cfunc{ucl_vector_size}.

Applying @cfunc{ucl_vector_enlarge} or @cfunc{ucl_vector_restrict} to
@var{V} invalidates the return value of this function.  When adding a
new slot: we have to make room for the new slot before attempting to
convert the index to the slot's pointer.

Example:

@example
ucl_vector_config_t     C;
ucl_vector_t            V;
int *                   P;
int                     D;

ucl_vector_initialise_config(C, sizeof(int), 1024);
ucl_vector_alloc(V, C);
fill_with_values(V);

ucl_vector_enlarge(V);
P = ucl_vector_index_to_new_slot(V, 13);
if (P)
  D = *P;
else
  error();
@end example
@end deftypefun


@deftypefun {void *} ucl_vector_front (const ucl_vector_t @var{V})
A wrapper for @cfunc{ucl_vector_index_to_slot} that returns a pointer
to the first element in the array.
@end deftypefun


@deftypefun {void *} ucl_vector_back (const ucl_vector_t @var{V})
A wrapper for @cfunc{ucl_vector_index_to_slot} that returns a pointer to
the last element in the array.
@end deftypefun

@c page
@node vector indexes p2i
@subsubsection Pointer to index conversion


@deftypefun ucl_index_t ucl_vector_last_index (const ucl_vector_t @var{V})
Return the index of the last element.
@end deftypefun


@deftypefun ucl_index_t ucl_vector_slot_to_index (const ucl_vector_t @var{V}, const void * @var{pointer_to_slot_p})
Return the index corresponding to a pointer to slot.  It is the inverse
of @cfunc{ucl_vector_index_to_slot}.
@end deftypefun

@c page
@node vector indexes validation
@subsubsection Validating indexes


@deftypefun ucl_bool_t ucl_vector_pointer_is_valid_slot (const ucl_vector_t @var{V}, const void * @var{pointer_to_slot_p})
Return true if the pointer is a valid slot pointer, else return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_index_is_valid (const ucl_vector_t @var{V}, ucl_index_t @var{index})
Return true if @var{index} is a valid index for the vector.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_index_is_valid_new (const ucl_vector_t @var{V}, ucl_index_t @var{index})
Return true if @var{index} is a valid index for a new slot of the
vector.
@end deftypefun

@c page
@node vector indexes range
@subsubsection Range functions


@deftypefun ucl_bool_t ucl_vector_range_is_valid (const ucl_vector_t @var{V}, ucl_range_t @var{R})
Return true if @var{R}, interpreted as inclusive range of indexes, is
valid for @var{V}.
@end deftypefun


@deftypefun ucl_range_t ucl_vector_range (const ucl_vector_t @var{V})
Return the inclusive range of indexes representing the whole vector.
@end deftypefun


@deftypefun ucl_range_t ucl_vector_range_from_position_to_end (const ucl_vector_t @var{V}, ucl_index_t @var{position})
Return the inclusive range of indexes from @var{position} to the end of
the vector.  @var{position} must be a valid index for @var{V}.
@end deftypefun


Notice that to build the range of indexes from the beginning of a vector
to a selected position we just need to do:

@example
ucl_range_t     range;

ucl_range_set_min_max(range, 0, position);
@end example


@deftypefun ucl_range_t ucl_vector_range_from_end_to_position (const ucl_vector_t @var{V}, ucl_index_t @var{position})
Return the inclusive range of indexes from the end of the vector to
@var{position}.  @var{position} must be greater or equal to the size of
@var{V}.

The returned range of indexes is invalid for @var{V}, but it can be used
to append new elements to it; to add slots from the end to index
@math{15} included:

@example
ucl_vector_config_t     C;
ucl_vector_t            V;
int *                   P;
ucl_range_t             R;
ucl_index_t             i;

ucl_vector_initialise_config(C, sizeof(int), 10);
ucl_vector_alloc(V, C);
fill_with_10_values(V);

R = ucl_vector_range_from_end_to_position(V, 15);
for (i=ucl_range_min(T); i<=ucl_range_max(R); ++i)
  @{
    ucl_vector_enlarge(V);
    P = ucl_vector_index_to_new_slot(V, i);
    ...
  @}
@end example
@end deftypefun


@deftypefun ucl_range_t ucl_vector_range_from_end_with_span (const ucl_vector_t @var{V}, size_t @var{span})
Return the inclusive range of indexes from the end of the vector with
@var{span}.

The returned range of indexes is invalid for @var{V}, but it can be used
to append new elements to it; to add @math{5} slots to the end:

@example
ucl_vector_config_t     C;
ucl_vector_t            V;
int *                   P;
ucl_range_t             R;
ucl_index_t             i;

ucl_vector_initialise_config(C, sizeof(int), 10);
ucl_vector_alloc(V, C);
fill_with_values(V);

R = ucl_vector_range_from_end_with_span(V, 5);
for (i=ucl_range_min(R); i<=ucl_range_max(R); ++i)
  @{
    ucl_vector_enlarge(V);
    P = ucl_vector_index_to_new_slot(V, i);
  @}
@end example

@noindent
of course this is just an example, because it is much easiear to use
@function{ucl_vector_push_back}.
@end deftypefun

@c page
@node vector indexes block
@subsubsection Range/block conversion


@deftypefun ucl_block_t ucl_vector_block_from_range (const ucl_vector_t @var{V}, const ucl_range_t @var{R})
Return a block referencing the slots selected by a range.
@end deftypefun


@deftypefun ucl_range_t ucl_vector_range_from_block (const ucl_vector_t @var{V}, const ucl_block_t @var{B})
Return the range of slots referenced by a block.
@end deftypefun

@c page
@node vector adding
@subsection Adding elements to a vector


@deftypefun {void *} ucl_vector_insert (ucl_vector_t @var{V}, void * @var{target})
Insert an empty slot at a selected position.  This function assumes that
the array has a free slot to hold the new element: to make sure that
this is true, a call to this function must be preceeded by a call to
@cfunc{ucl_vector_enlarge}.

The pointer to the slot must be the return value of a previous
invocation to @cfunc{ucl_vector_index_to_new_slot}.

This function tries to move less elements as possible to create an empty
slot at the selected position.  The return value is a pointer to the
empty slot: it can be different from the value of the @var{target}
argument.
@end deftypefun


@deftypefun {void *} ucl_vector_insert_sort (ucl_vector_t @var{V}, ucl_value_t @var{data})
Find the position in the vector in which an element must be inserted to
keep the array sorted and create a new slot there; the return value is a
pointer to the empty slot.

This function assumes that:

@enumerate
@item
there's room in the vector to insert a new element;
@item
the array is sorted;
@item
a comparison function has been registered in @var{V} to be used to
compare elements.
@end enumerate

@var{data} must represent the element to be inserted, it's used as first
argument to the comparison function.  When a sequence of elements equal
to @var{data} is present: the new slot is appended at its end.
@end deftypefun


The correct sequence of function calls required to insert a new element
is: enlarge the vector, acquire the pointer, make a free slot, copy the
value.  Example of insertion:

@example
ucl_vector_t     vector;
ucl_index_t      index;
data_type_t      data;
data_type_t *    ptr;

...

data  = ...;
index = ...;
ucl_vector_enlarge(vector);
ptr   = ucl_vector_index_to_new_slot(vector, index);
ptr   = ucl_vector_insert(vector, ptr);
*ptr  = data;
@end example

@noindent
example of insert sort operation:

@example
ucl_vector_t     vector;
ucl_index_t      index;
data_type_t      data;
data_type_t *    ptr;

...

data  = ...;
index = ...;
ucl_vector_enlarge(vector);
ptr   = ucl_vector_insert_sort(vector, &data);
*ptr  = data;
@end example

@c page
@node vector removing
@subsection Removing elements from a vector


@deftypefun void ucl_vector_erase (ucl_vector_t @var{V}, void * @var{slot})
Erase an element at a selected position: the slot is overwritten by
moving less elements as possible.  After the invocation: the pointer
represented by @var{slot} is not guaranteed to be a pointer to a valid
slot in the vector.
@end deftypefun


After the invocation of this function, it's possible to attempt a
reallocation of the array to free some unused memory with a call to
@function{ucl_vector_restrict}.


Example of data erasure:

@example
ucl_vector_t     V;
ucl_index_t      index;
data_type_t *    ptr;

...

index = ...
ptr   = ucl_vector_index_to_slot(V, index);
ucl_vector_erase(V, ptr);
ucl_vector_restrict(V);
@end example

@noindent
example of data extraction:

@example
ucl_vector_t     V;
ucl_index_t      index;
data_type_t *    ptr;
data_type_t      data;

...

index = ...
ptr   = ucl_vector_index_to_slot(V, index);
data  = *ptr;
ucl_vector_erase(V, ptr);
ucl_vector_restrict(V);
@end example

@c ------------------------------------------------------------

@c page
@node vector ops
@subsection Various operations on a vector


@subsubheading Dimension inspection


@deftypefun size_t ucl_vector_size (const ucl_vector_t @var{V})
Return a value representing the number of elements in the container.
@end deftypefun


@deftypefun size_t ucl_vector_slot_dimension (const ucl_vector_t @var{V})
Return a value representing the size of the elements.
@end deftypefun


@deftypefun {void *} ucl_vector_increment_slot (const ucl_vector_t @var{V}, void * @var{slot})
Interpret @var{slot} as a pointer to a slot of @var{V} and increment it
so that it references the next element.  This function does no bounds
checking.
@end deftypefun


@deftypefun {void *} ucl_vector_decrement_slot (const ucl_vector_t @var{V}, void * @var{slot})
Interpret @var{slot} as a pointer to a slot of @var{V} and decrement it
so that it references the previous element.  This function does no
bounds checking.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Access to memory blocks


@deftypefun ucl_block_t ucl_vector_get_memory_block (const ucl_vector_t @var{V})
Return a block referencing the allocated memory block.
@end deftypefun


@deftypefun ucl_block_t ucl_vector_get_data_block (const ucl_vector_t @var{V})
Return a block referencing the data block: the used slots.
@end deftypefun


@deftypefun ucl_block_t ucl_vector_get_free_block_at_end (ucl_vector_t @var{V}, size_t @var{count})
Return a block referencing @var{count} free slots at the end of the
vector; the slots are still marked as free.

This function may haul the used slots inside the allocated memory, so
slot pointers requested early will become invalid.

This function has to be called only if there are at least @var{count}
free slots already allocated, see
@cfunc{ucl_vector_enlarge_for_slots} (@ref{vector memory} for
details).

At present, blocks returned by this function cannot be converted to a
range with @cfunc{ucl_vector_range_from_block}.
@end deftypefun


@deftypefun ucl_block_t ucl_vector_get_free_block_at_beginning (ucl_vector_t @var{V}, size_t @var{count})
Return a block referencing @var{count} free slots at the beginning of
the vector; the slots are still marked as free.

This function may haul the used slots inside the allocated memory, so
slot pointers requested early will become invalid.

This function has to be called only if there are at least @var{count}
free slots already allocated, see @cfunc{ucl_vector_enlarge_for_slots}
(@ref{vector memory} for details).

At present, blocks returned by this function cannot be converted to a
range with @cfunc{ucl_vector_range_from_block}.
@end deftypefun


@deftypefun void ucl_vector_mark_as_used (ucl_vector_t @var{V}, ucl_block_t @var{B})
Mark the range of free slots referenced by @var{B} as used.  This
function is meant to commit usage of blocks requested with
@cfunc{ucl_vector_get_free_block_at_beginning} and
@cfunc{ucl_vector_get_free_block_at_end}.

@var{B} must be adjacent to the used slots inside the vector, its size
must be an integer multiple of the slot dimension, its memory must be
completely contained in the allocated vector memory.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Sorting


@deftypefun void ucl_vector_quick_sort (ucl_vector_t @var{V})
Quick sort the vector using the C library function
@cfunc{ucl_quicksort}.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_sorted (ucl_vector_t @var{V})
Return true if the vector is sorted.  This function scans the whole
vector, so it is slow.
@end deftypefun

@c page
@node vector find
@subsection Finding elements


The functions described in this section search for an element in the
vector, given a copy of the element to be found.  The @var{D} argument
represents the element to be found, it's used as first argument to the
comparison function.

The return value is always a pointer to the found element in the array,
or @cnull{} if the element is not present.


@deftypefun {void *} ucl_vector_find (const ucl_vector_t @var{V}, const ucl_value_t @var{D})
Find an element in the array with a linear search.
@end deftypefun


@deftypefun {void *} ucl_vector_binary_search (const ucl_vector_t @var{V}, const ucl_value_t @var{D})
Find an element in the array with a binary search; this function assumes
that the array is sorted.
@end deftypefun


@deftypefun {void *} ucl_vector_sort_find (const ucl_vector_t @var{V}, const ucl_value_t @var{D})
Find an element in the array; this function assumes that the array is
sorted.  If there are few elements in the vector: a linear search is
performed, else a binary search is used.
@end deftypefun

@c page
@node vector iteration
@subsection Iteration over a vector


It's easy to iterate over all the elements of a vector.  Example of
forward iteration:

@example
ucl_vector_t    V;
data_type_t *   P;
data_type_t *   end = ucl_vector_back(V);

for (P = ucl_vector_front(V); P <= end; ++P)
  @{
    ... *P ...
  @}
@end example

@noindent
example of backward iteration:

@example
ucl_vector_t    V;
data_type_t *   P;
data_type_t *   end = ucl_vector_front(V);

for (P = ucl_vector_back(V); P >= end; --P)
  @{
    ... *P ...
  @}
@end example

@noindent
nevertheless the following iterators are provided; @ref{iterators} for
details on iteration.


@deftypefun void ucl_vector_iterator_forward (const ucl_vector_t @var{V}, ucl_iterator_t @var{I})
Initialise a forward iteration.
@end deftypefun


@deftypefun void ucl_vector_iterator_backward (const ucl_vector_t @var{V}, ucl_iterator_t @var{I})
Initialise a backward iteration.
@end deftypefun


@deftypefun void ucl_vector_iterator_range_forward (const ucl_vector_t @var{V}, ucl_range_t @var{R}, ucl_iterator_t @var{I})
Initialise a forward iteration over the inclusive range of elements
selected by @var{R}.  @var{R} must be a valid range for @var{V}, we can
test this with @cfunc{ucl_vector_range_is_valid}.
@end deftypefun


@deftypefun void ucl_vector_iterator_range_backward (const ucl_vector_t @var{V}, ucl_range_t @var{R}, ucl_iterator_t @var{I})
Initialise a backward iteration over the inclusive range of elements
selected by @var{R}.  @var{R} must be a valid range for @var{V}, we can
test this with @cfunc{ucl_vector_range_is_valid}.
@end deftypefun

@c page
@node vector memory
@subsection Allocating and freeing memory


@menu
* vector memory intro::         Introduction to vector memory handling.
* vector memory enlarge::       Enlarging allocated memory.
* vector memory restrict::      Restricting allocated memory.
* vector memory misc::          Miscellaneous memory functions.
@end menu

@c page
@node vector memory intro
@subsubsection Introduction to vector memory handling


The allocation policy for a vector container is ruled by the arguments
stored into the configuration structure (@ref{vector creation}).  The
rules are:

@itemize @bullet
@item
an initial number of slots is selected and an array of such size is
allocated;

@item
an optional number of slots to be kept free at the beginning of the
array is selected, so elements can be moved there when inserting new
slots;

@item
the function @cfunc{ucl_vector_enlarge} enlarges the array when one
of the two conditions are true:

@itemize -
@item
the array is full;

@item
a specific number of free slots is requested and there are not enough in
the array;
@end itemize

@item
a ``step up'' number is selected: when the array is reallocated to be
enlarged, the new size is the minimum multiple of this number greater
than the number of elements in the container (in units of slot size):

@example
rest = old_size % step_up
new_size = old_size + (rest)? rest : step_up
@end example

@item
a ``step down'' number is selected: when @cfunc{ucl_vector_restrict}
has to determine if the array has to be reallocated for restriction, the
operation is performed if there are at least that number of free slots;
the new size is computed with the following formula (in units of slot
size):

@example
rest = old_size % step_up
new_size = old_size - step_down
new_size += (rest)? rest : step_up
@end example

@noindent
example:

@example
old_size  = 20
step_up   = 4
step_down = 10

rest     = 20 %  4 =  0
new_size = 20 - 10 = 10
new_size = 10 +  4 = 14
@end example

@noindent
notice that if @code{step_up >= step_down} it can result that
@code{new_size >= old_size}, example:

@example
old_size  = 10
step_up   = 4
step_down = 2

rest     = 10 % 4 = 2
new_size = 10 - 2 = 8
new_size =  8 + 2 = 10
@end example

@noindent
another example:

@example
old_size  = 11
step_up   = 4
step_down = 2

rest     = 11 % 4 = 3
new_size = 11 - 2 = 9
new_size =  9 + 3 = 12
@end example

@noindent
that is why @cfunc{ucl_vector_alloc} sets @code{step_down} to a value
greater than @code{step_up}.
@end itemize


By default the @ucl{} allocator is used (@ref{memory functions}), but it
is possible to register a vector--specific allocator.

@c page
@node vector memory enlarge
@subsubsection Enlarging allocated memory


@deftypefun void ucl_vector_enlarge (ucl_vector_t @var{V})
To be used to make sure that at least one free slot exists.

Check if there are free slots in the allocated memory: if there are,
nothing happens; else the array is reallocated and enlarged according to
the reallocation rules.

An error reallocating memory does not corrupt the vector.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_will_enlarge (ucl_vector_t @var{V})
Return true if the next call to @cfunc{ucl_vector_enlarge} will
reallocate the vector.
@end deftypefun


@deftypefun size_t ucl_vector_enlarged_size (ucl_vector_t @var{V})
Return the number of allocated slots after a reallocation for
enlarging.  This function returns a meaningful value only when
@cfunc{ucl_vector_will_enlarge} returns true.
@end deftypefun


@deftypefun void ucl_vector_enlarge_for_slots (ucl_vector_t @var{V}, size_t @var{required_free_slots})
To be used to make sure that there is room for at least the selected
number of free slots.

Check if there are at least @var{required_free_slots} in the allocated
memory: if there are, nothing happens; else the array is reallocated and
enlarged to get enough room.

An error reallocating memory does not corrupt the vector.
@end deftypefun


@deftypefun void ucl_vector_enlarge_for_range (ucl_vector_t @var{V}, ucl_range_t @var{R})
Make sure that there is enough memory to hold the inclusive range of
indexes described by @var{R}.  This works despite @var{R} being: already
a valid range of indexes, completely beyond the upper index limits,
across the current upper index limit.
@end deftypefun

@c page
@node vector memory restrict
@subsubsection Restricting allocated memory


@deftypefun void ucl_vector_restrict (ucl_vector_t @var{V})
Check if there are enough free slots in the allocated memory so that
it's correct to restrict the array: if there aren't, nothing happens;
else the array is reallocated and restricted according to the
reallocation rules.

An error reallocating memory does not corrupt the vector.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_will_restrict (ucl_vector_t @var{V})
Return true if the next call to @cfunc{ucl_vector_restrict} will
reallocate the vector.
@end deftypefun


@deftypefun size_t ucl_vector_restricted_size (ucl_vector_t @var{V})
Return the number of allocated slots after a reallocation for
restricting.  This function returns a meaningful value only when
@cfunc{ucl_vector_will_restrict} returns true.
@end deftypefun

@c page
@node vector memory misc
@subsubsection Miscellaneous memory functions


@deftypefun void ucl_vector_set_memory_to_zero (ucl_vector_t @var{V})
Set all the slots to zero.  This does not change the vector size: it is
not like extracting all the elements.
@end deftypefun


@deftypefun size_t ucl_vector_number_of_free_slots (ucl_vector_t @var{V})
Returns the number of allocated but currently unused slots.  It is the
number of elements that can be added without causing a memory
reallocation.
@end deftypefun


@deftypefun void ucl_vector_register_allocator (ucl_vector_t @var{V}, ucl_memory_allocator_t @var{A})
Register a new allocator.
@end deftypefun

@c page
@node vector as pqueue
@subsection Using a vector as a priority queue


The vector structure provides all the functions required to implement a
priority queue.  This is a structure in which elements are associated
with keys: when an element is added and the structure is kept sorted
comparing its key with the keys of the elements already in the
container.

Let's say we have declared a structure like this:

@example
typedef struct pair_t @{
  key_t   key;
  val_t   val;
@} pair_t;
@end example

@noindent
and a @code{ucl_comparison_t} function+context to compare keys.

If any time a @code{pair_t} must be inserted in the vector we use the
@function{ucl_vector_insert_sort} function to determine the insertion
position, the elements will be kept sorted according to the key values
and comparison algorithm.

Then @function{ucl_vector_front} or @function{ucl_vector_back} can be
used to extract the element with lesser or greater key.

@c page
@node vector high
@subsection High level functions


The functions described in this section are built upon the basic ones;
some of them invoke the enlarge/restrict memory functions.

@menu
* vector high stack::           Stack and queue.
* vector high append::          Appending data to a vector.
* vector high insert::          Inserting into a vector.
* vector high erase::           Removing from a vector.
* vector high access::          Setters and getters.
* vector high compare::         Comparing vectors.
* vector high apply::           Applying functions.
@end menu

@c page
@node vector high stack
@subsubsection Stack and queue


@deftypefun {void *} ucl_vector_push_front (ucl_vector_t @var{V})
Add a slot to the front of the vector and return a pointer to it.

This function invokes @cfunc{ucl_vector_enlarge}.
@end deftypefun

@deftypefun {void *} ucl_vector_push_back (ucl_vector_t @var{V})
Add a slot to the tail of the vector and return a pointer to it.

This function invokes @cfunc{ucl_vector_enlarge}.
@end deftypefun


@deftypefun void ucl_vector_pop_front (ucl_vector_t @var{V})
If the vector is not empty: erase the first slot, else do nothing.

This function invokes @cfunc{ucl_vector_restrict}.
@end deftypefun

@deftypefun void ucl_vector_pop_back (ucl_vector_t @var{V})
If the vector is not empty: erase the last slot, else do nothing.

This function invokes @cfunc{ucl_vector_restrict}.
@end deftypefun

Notice that the ``top'' operations of the stack and queue are already
implemented by @cfunc{ucl_vector_front} and @cfunc{ucl_vector_back}.

@c page
@node vector high append
@subsubsection Appending data to a vector


In the following functions the @var{dst} vector must be an already
allocated vector.


@deftypefun void ucl_vector_append_block (ucl_vector_t @var{dst}, const ucl_block_t @var{B})
Append a block to the vector by copying data from @var{B} with
@cfunc{memcpy}.  The size of the block must be an integer multiple of
the destination vector's slot dimension.

This function invokes @cfunc{ucl_vector_enlarge_for_slots}.
@end deftypefun


@deftypefun void ucl_vector_append (ucl_vector_t @var{dst}, const ucl_vector_t @var{src})
Append all the elements of @var{src} to the end of @var{dst} by copying
data with @cfunc{memcpy}.  If @var{dst} is empty: this operation is
equivalent to duplicating @var{src}.

This function invokes @cfunc{ucl_vector_enlarge_for_slots}.
@end deftypefun


@deftypefun void ucl_vector_append_range (ucl_vector_t @var{dst}, const ucl_vector_t @var{src}, ucl_range_t @var{R})
Append the elements of @var{src} referenced by @var{R} to the end of
@var{dst} by copying data with @cfunc{memcpy}.

This function invokes @cfunc{ucl_vector_enlarge_for_slots}.
@end deftypefun


@deftypefun void ucl_vector_append_more (ucl_vector_t @var{dst}, const ucl_vector_t @var{src}, @dots{})
Append elements from a set of vectors to the end of @var{dst}.  The
@code{...} arguments are a list of @code{ucl_vector_t} values terminated
by a @cnull{}.

This function invokes @cfunc{ucl_vector_enlarge_for_slots}.

Example:

@example
ucl_vector_t    dst, a, b, c, d;

...
ucl_vector_append_more(dst, a, b, c, d, NULL);
@end example
@end deftypefun


@deftypefun void ucl_vector_append_more_from_array (ucl_vector_t @var{dst}, const ucl_vector_array_t * @var{vectors})
Like @cfunc{ucl_vector_append_more} but takes source vectors from an
array rather than from application parameters.
@end deftypefun

@c page
@node vector high insert
@subsubsection Inserting into a vector


@deftypefun void ucl_vector_insert_vector (ucl_vector_t @var{dst}, ucl_index_t @var{offset}, ucl_vector_t @var{src})
Insert all the elements of @var{src} into @var{dst} at @var{offset}.

@var{offset} must be a valid value for
@cfunc{ucl_vector_index_to_new_slot}.

This function invokes @cfunc{ucl_vector_enlarge_for_slots}.
@end deftypefun


@deftypefun void ucl_vector_insert_block (ucl_vector_t @var{dst}, ucl_index_t @var{offset}, const ucl_block_t @var{B})
Insert the data referenced by @var{B} into @var{dst} at @var{offset}.

The size of @var{B} must be an integer multiple of the slot's dimension
of @var{dst}.  @var{offset} must be a valid value for
@cfunc{ucl_vector_index_to_new_slot}.

This function invokes @cfunc{ucl_vector_enlarge_for_slots}.
@end deftypefun


@deftypefun void ucl_vector_insert_range (ucl_vector_t @var{dst}, ucl_index_t @var{offset}, const ucl_vector_t @var{src}, ucl_range_t @var{R})
Insert the data referenced by the inclusive @var{R} of indexes from
@var{src} into @var{dst} at @var{offset}.

The size of @var{B} must be an integer multiple of the slot's dimension
of @var{dst}.  @var{offset} must be a valid value for
@cfunc{ucl_vector_index_to_new_slot}.

This function invokes @cfunc{ucl_vector_enlarge_for_slots}.
@end deftypefun

@c page
@node vector high erase
@subsubsection Removing from a vector


@deftypefun void ucl_vector_erase_range (ucl_vector_t @var{V}, ucl_range_t @var{R})
Erase all the elements in the selected range.

This function invokes @function{ucl_vector_restrict}.
@end deftypefun

@c page
@node vector high access
@subsubsection Setters and getters


@deftypefun void ucl_vector_copy_range (ucl_vector_t @var{dst}, ucl_index_t @var{position}, ucl_vector_t @var{src}, ucl_range_t @var{src_range})
Copy slots referenced by @var{src_range} in @var{src} to @var{position}
in @var{dst}; data in @var{dst} is overwritten.

@var{position} must be a valid index for @var{dst}.  @var{src_range}
must be valid for @var{src}.  There must be enough slots after
@var{position} in @var{dst} to hold the whole range from @var{src}.
@end deftypefun


@deftypefun void ucl_vector_set_block (ucl_vector_t @var{dst}, ucl_index_t @var{position}, ucl_block_t @var{src})
Copy data from @var{src} into @var{dst} at @var{position}; data in
@var{dst} is overwritten.

@var{position} must be a valid index for @var{dst} and enough slots must
exist after it to accept the whole @var{src} block.  The length of
@var{src} must be an integer multiple of the slot's dimension in
@var{dst}.
@end deftypefun


@deftypefun void ucl_vector_get_block (ucl_block_t @var{dst}, ucl_index_t @var{position}, ucl_vector_t @var{src})
Copy data from @var{src} at @var{position} into @var{dst}, overwriting
data.

@var{position} must be a valid index for @var{dst} and there must be
enough slots in @var{dst} to fill the block.  The length of @var{src}
must be an integer multiple of the slot's dimension in @var{dst}.
@end deftypefun

@c page
@node vector high compare
@subsubsection Comparing vectors


@deftypefun int ucl_vector_compare_range (ucl_vector_t @var{a}, ucl_range_t @var{range_a}, ucl_vector_t @var{b}, ucl_range_t @var{range_b})
Compare two ranges of elements in two vectors, element by element, using
the comparison function of @var{a}.  If the size of the ranges is not
equal: only a number of elements equal to the lesser size is compared.
The comparison stops at the first pair of elements for which the
comparison function returns non--zero.

Works somewhat like @cfunc{strcmp}.  Return:

@table @code
@item 0
if all the compared elements are equal;
@item +1
if, for the last compared pair, the element from @var{a} is greater than
the last element from @var{b};
@item -1
if, for the last compared pair, the element from @var{a} is lesser than
the last element from @var{b}.
@end table

@var{a} can be equal to @var{b}.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_equal_range (ucl_vector_t @var{a}, ucl_range_t @var{range_a}, ucl_vector_t @var{b}, ucl_range_t @var{range_b})
Wrapper for @cfunc{ucl_vector_compare_range} that returns true if the
two ranges are equal.
@end deftypefun


@deftypefun int ucl_vector_compare (ucl_vector_t @var{a}, ucl_vector_t @var{b})
Wrapper for @cfunc{ucl_vector_compare_range} that compares the whole
vectors.
@end deftypefun


@deftypefun ucl_bool_t ucl_vector_equal (ucl_vector_t @var{a}, ucl_vector_t @var{b})
Wrapper for @cfunc{ucl_vector_compare}: return true if the vectors are
equal.
@end deftypefun

@c page
@node vector high apply
@subsubsection Applying functions


The functions described in this section allow us to apply a function, in
the form of a callback (@ref{typedefs callback}), to each element in a
vector or to each element in a range over a vector.  The ``for each''
kind leaves to the callback the responsibility to produce a result,
while the ``map'' kind produces a vector holding processed elements.


@deftypefun void ucl_vector_for_each (ucl_callback_t @var{cb}, ucl_vector_t @var{V})
Apply the callback @var{cb} to each element in the vector @var{V}.  The
callback function is invoked with a pointer to the element's slot as
custom value.

Example of callback that sums the values in a vector:

@example
void
callback (ucl_value_t state, ucl_value_t custom)
@{
  int * accumulator_p   = state.ptr;
  int * slot            = custom.ptr;

  *accumulator_p += *slot;
@}

int             accumulator = 0;
ucl_callback_t  cb = @{
  .func = callback,
  .data = @{ .ptr = &accumulator @}
@};

ucl_vector_t    V;
ucl_vector_for_each(cb, V);
@end example

@noindent
with this setup the operation is like a ``fold''.
@end deftypefun


@deftypefun void ucl_vector_for_each_in_range (ucl_callback_t @var{cb}, ucl_range_t @var{R}, ucl_vector_t @var{V})
Like @cfunc{ucl_vector_for_each}, but apply the callback only to the
elements selected by the inclusive @var{R}.

Example of callback that sums the values in a vector's range:

@example
void
callback (ucl_value_t state, ucl_value_t custom)
@{
  int * accumulator_p   = state.ptr;
  int * slot            = custom.ptr;

  *accumulator_p += *slot;
@}

int             accumulator = 0;
ucl_callback_t  cb = @{
  .func = callback,
  .data = @{ .ptr = &accumulator @}
@};
ucl_range_t     range;

ucl_vector_t    V;
ucl_range_set_min_max(range, 3, 8);
ucl_vector_for_each_in_range(cb, range, V);
@end example
@end deftypefun


@deftypefun void ucl_vector_for_each_multiple (ucl_callback_t @var{cb}, ucl_vector_t @var{V}, @dots{})
Like @cfunc{ucl_vector_for_each}, but apply the callback to an array of
pointers to slots from the vectors used as arguments.

This function must be invoked with a list of @code{ucl_vector_t}
arguments ended by a @cnull{}.

The callback function is invoked with a pointer to a
@code{ucl_array_of_pointers_t} structure as custom value:

@table @code
@item ucl_value_t data
the @code{t_unsigned_int} field is set to the index of the slot
currently visited;

@item size_t number_of_slots
the number of slots which is equal to the number of vectors used as
arguments;

@item void ** slots
a pointer to an array of pointers to the slots.
@end table

The iteration stops when the end of the shortest vector is found.

Example:

@example
static void
callback (ucl_value_t state, ucl_value_t custom)
@{
  int *                         sums    = state.ptr;
  ucl_array_of_pointers_t *     slots   = custom.ptr;
  int **                        values  = (int **)slots->slots;

  for (size_t i=0; i<slots->number_of_slots; ++i)
    sums[slots->data.unum] += *values[i];
@}

int            sums[5] = @{ 0, 0, 0, 0, 0 @};
ucl_callback_t cb = @{
  .func = callback,
  .data = @{ .ptr = &sums @}
@};

ucl_vector_t   A, B, C;
ucl_vector_for_each_multiple(cb, A, B, C, NULL);
@end example
@end deftypefun


@deftypefun void ucl_vector_for_each_multiple_from_array (ucl_callback_t @var{cb}, ucl_vector_array_t * @var{vectors})
Like @cfunc{ucl_vector_for_each_multiple} but the vectors are given
in an array rather than a list of arguments.
@end deftypefun


@deftypefun void ucl_vector_map (ucl_vector_t @var{R}, ucl_callback_t @var{cb}, ucl_vector_t @var{V})
Apply the callback @var{cb} to each element in the vector @var{V} and
store the result in the vector @var{R}.  New slots are added to @var{R}
using @cfunc{ucl_vector_push_back}.

The callback function is invoked with a pointer to a
@code{ucl_array_of_pointers_t} structure as custom value:

@table @code
@item ucl_value_t data
the @code{t_unsigned_int} field is set to the index of the slot
currently visited;

@item size_t number_of_slots
the number of slots: always @code{2} for this function;

@item void ** slots
a pointer to an array of pointers to the slots; the first element
(@code{slots[0]}) references the result slot, while the second element
(@code{slots[1]}) references the operand slot.
@end table

Example of callback that negates the values:

@example
void
callback (ucl_value_t state UCL_UNUSED, ucl_value_t custom)
@{
  ucl_array_of_pointers_t * slots   = custom.ptr;
  int *                     result  = slots.slots[0];
  int *                     operand = slots.slots[1];

  *result = - *operand;
@}

ucl_callback_t  cb = @{
  .func = callback,
  .data = @{ .ptr = NULL @}
@};

ucl_vector_t    result, operand;
ucl_vector_map(result, cb, operand);
@end example
@end deftypefun


@deftypefun void ucl_vector_map_range (ucl_vector_t @var{dst}, ucl_callback_t @var{cb}, ucl_range_t @var{R}, ucl_vector_t @var{src})
Like @cfunc{ucl_vector_map}, but apply the callback only to the elements
selected by the inclusive @var{R}.
@end deftypefun


@deftypefun void ucl_vector_map_multiple (ucl_vector_t @var{R}, ucl_callback_t @var{cb}, ucl_vector_t @var{first}, ...)
Like @cfunc{ucl_vector_map}, but apply the callback to an array of
pointers to slots from the vectors used as arguments.

The function must be invoked with a list of @code{ucl_vector_t}
arguments ended by @cnull{}.

The callback function is invoked with a pointer to a
@code{ucl_array_of_pointers_t} structure as custom value:

@table @code
@item ucl_value_t data
the @code{t_unsigned_int} field is set to the index of the slot
currently visited;

@item size_t number_of_slots
the number of slots which is equal to 1 plus the number of vectors used
as arguments;

@item void ** slots
a pointer to an array of pointers to the slots; the first element
(@code{slots[0]}) references the result slots, while the following
elements (@code{slots[1]}, @code{slots[2]}, @dots{}) reference the
operands.
@end table

The iteration stops when the end of the shortest operand vector is
found.

Example of callback that computes the sum of vectors:

@example
static void
callback (ucl_value_t state UCL_UNUSED, ucl_value_t custom)
@{
  ucl_array_of_pointers_t *  slots  = custom.ptr;
  int **                     values = (int **)slots->slots;

  *values[0] = 0;
  for (size_t i=1; i<slots->number_of_slots; ++i)
    *values[0] += *values[i];
@}

ucl_callback_t  cb = @{
  .func = callback,
  .data = @{ .ptr = NULL @}
@};

ucl_vector_t    R, A, B, C;
ucl_vector_map_multiple(R, cb, A, B, C, NULL);
@end example
@end deftypefun


@deftypefun void ucl_vector_map_multiple_from_array (ucl_vector_t @var{R}, ucl_callback_t @var{cb}, ucl_vector_array_t * @var{vectors})
Like @cfunc{ucl_vector_map_multiple} but the vectors are given in an
array rather than a list of arguments.
@end deftypefun

@c page
@node iterators
@chapter Container iteration


@noindent
Each container has its iteration constructors that must be invoked
explicitly, but the functions used to do the actual iterations and to
access the objects are accessed through a set of macros.


@deftp {Struct Typedef} ucl_iterator_tag_t
@deftpx {One--Element Array Typedef} ucl_iterator_t
Base structure for all the iterators.
@end deftp


@deftypefun ucl_bool_t ucl_iterator_more (ucl_iterator_t @var{iterator})
Return true if there are more elements to iterate, false if the
iteration is over.
@end deftypefun


@deftypefun void ucl_iterator_next (ucl_iterator_t @var{iterator})
Advance the iteration.
@end deftypefun


@deftypefun {void *} ucl_iterator_ptr (ucl_iterator_t @var{iterator})
Return a pointer referencing the current value.  If the iteration is
already over: return @cnull{}.
@end deftypefun


@section Examples


@noindent
Example of iterator usage:

@example
ucl_value_t       val;
ucl_iterator_t    iterator;
ucl_map_link_t *  link_p;

...

for (ucl_map_iterator_inorder(this, iterator);
     ucl_iterator_more(iterator);
     ucl_iterator_next(iterator))
  @{
    link_p = ucl_iterator_ptr(iterator);
    val = ucl_map_getval(link_p);
  @}
@end example


@c ------------------------------------------------------------

@c page
@node misc
@chapter Miscellaneous functions


@menu
* misc version::                Version functions.
* misc compar::                 Comparison functions.
* misc sort::                   Sorting functions.
@end menu

@c page
@node misc version
@section Version functions


@deftypefun {const char *} ucl_version (void)
Return a pointer to a string representing the version number.
@end deftypefun


@deftypefun unsigned ucl_interface_major_version (void)
Return a number representing the library interface major version
number.
@end deftypefun


@deftypefun unsigned ucl_interface_minor_version (void)
Return a number representing the library interface minor version
number.
@end deftypefun

@c page
@node misc compar
@section Comparison functions


All the following function have prototype matching
@code{ucl_comparison_fun_t}; for all of them @var{data} is unused and
the return value is: @code{0} if @var{a} equals @var{b}; @code{1} if
@var{a} is greater than @var{b}; @code{-1} if @var{a} is lesser than
@var{b}.


@deftypefun int ucl_compare_int_fun (ucl_value_t @var{data}, const ucl_value_t @var{a}, const ucl_value_t @var{b})
Compare the @code{t_int} fields of two values.
@end deftypefun


@deftypefun int ucl_compare_unsigned_int_fun (ucl_value_t @var{data}, const ucl_value_t @var{a}, const ucl_value_t @var{b})
Compare the @code{unum} fields of two values.
@end deftypefun


@deftypefun int ucl_compare_string_fun (ucl_value_t @var{data}, const ucl_value_t @var{a}, const ucl_value_t @var{b})
Wrapper for @cfunc{strcmp}.
@end deftypefun


@deftypefun int ucl_compare_int_pointer_fun (ucl_value_t @var{data}, const ucl_value_t @var{a}, const ucl_value_t @var{b})
Interpret the @code{ptr} fields of @var{a} and @var{b} as pointers of
type @code{int}: compare the two referenced numbers by invoking
@cfunc{ucl_compare_int}.
@end deftypefun


@deftypevar {const ucl_comparison_t} ucl_compare_int
@deftypevarx {const ucl_comparison_t} ucl_compare_unsigned_int
@deftypevarx {const ucl_comparison_t} ucl_compare_string
@deftypevarx {const ucl_comparison_t} ucl_compare_int_pointer
Statically allocated comparison structures which use the comparison
functions described above.
@end deftypevar

@c page
@node misc sort
@section Sorting functions


@deftypefun void ucl_quicksort (void * @var{array}, size_t @var{count}, size_t @var{size}, ucl_comparison_t @var{compar})
Like the standard @function{qsort}, but makes use of the comparison
function and context in @var{compar}.  @var{array} is an array of
@var{count} elements of @var{size}.

@quotation
@strong{NOTE} This is indeed the @function{qsort} function from the
@gnu{} C Library version 2.4, modified to use @var{compar}.
@end quotation
@end deftypefun

@c page

@include libversion.texiinc

@c page
@node references
@appendix Bibliography and references


@noindent
Ellis Horowitz, Sartaj  Sahni and Susan Anderson--Freed.  @emph{Strutture
dati in C}.  McGraw--Hill, 1993.

@noindent
Bjarne Stroustroup.  @emph{C++}.  Addison-Wesley, 1997.


@c ------------------------------------------------------------

@c page

@include gpl-3.0.texiinc
@include fdl-1.3.texiinc

@c page
@node concept index
@appendix An entry for each concept
@printindex cp


@node function index
@appendix An entry for each function
@printindex fn


@node type index
@appendix An entry for each type.
@printindex tp


@node variable index
@appendix An entry for each variable.
@printindex vr


@contents
@bye


@c end of file
