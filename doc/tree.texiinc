@node tree
@section The tree structure


@menu
* tree implementation::         How it's done.
* tree creation::               Creating a tree hierarchy.
* tree testing::                Testing relationships between nodes.
* tree relatives::              Accessing or setting the relatives of
                                a node.
* tree removing::               Removing elements from a tree.
* tree iterators::              Traversing a tree.
@end menu


@c ------------------------------------------------------------

@c page
@node tree implementation
@subsection How it's done


@noindent
The implementation is a binary tree with nodes of type
@code{ucl_node_t}; the only difference between the btree and the tree is
the interpretation of the bro nodes.  This means that all the functions
in the btree module can be used on a tree, and the tree module adds
functions to establish the interpretation policy.

In the following picture: the nodes @code{B}, @code{C}, @code{D} and
@code{E} are all ``children'' of the node @code{A}; the node @code{A} is
the father of the nodes @code{B}, @code{C}, @code{D} and @code{E}.  So
in a tree a node can have and indefinite number of children.

@example
   -----
  |  A  |
   -----
    ^ |son
 dad| v
   -----  bro   -----  bro   -----  bro   -----  bro
  |  B  |----->|  C  |----->|  D  |----->|  E  |----->NULL
   ----- <----- ----- <----- ----- <----- -----
    ^ |   dad    ^ |   dad          dad
 dad| vson    dad| vson
   -----        -----
  |  F  |      |  G  |
   -----        -----
@end example

Pointers condition meaning:

@table @code
@item node.dad == NULL
the node is the root node of a tree;

@item node.bro == NULL
the node has no brothers, so it's the last brother between the children
of its father;

@item node.son == NULL
the node has no children;

@item A.dad == B && B.son == A
A is the first between the children of node B;

@item A.dad == B && B.bro == A 
A and B are brothers, and children of the same parent node.
@end table


@c ------------------------------------------------------------

@c page
@node tree creation
@subsection Creating a tree hierarchy


@noindent
The node structures must be allocated by the client code and all the
bytes set to zero before usage.  The btree functions can be used
directly, but @ucl{} provides aliases for them when they must be used
for a tree.

All the following functions accept @code{void *} values as arguments:
internally these pointers are cast @code{ucl_node_t}.


@subsubsection Single link setters


@deftypefn {Inline Function} void ucl_tree_setdad (void * @var{self}, void * @var{dad})
Select a new parent node for @var{self}.
@end deftypefn


@deftypefn {Inline Function} void ucl_tree_setbro (void * @var{self}, void * @var{bro})
Select a new brother node for @var{self}.
@end deftypefn


@deftypefn {Inline Function} void ucl_tree_setson (void * @var{self}, void * @var{son})
Select a new child node for @var{self}.
@end deftypefn


@subsubsection Double link setters


@deftypefn {Inline Function} void ucl_tree_dadson (void * @var{dad}, void * @var{son})
Link @var{dad} and @var{son} to be the parent and the son respectively.
@end deftypefn


@deftypefn {Inline Function} void ucl_tree_dadbro (void * @var{dad}, void * @var{bro})
Link @var{dad} and @var{bro} to be the parent and the bro respectively.
@end deftypefn


@subsubsection Triple link setters


@deftypefn {Inline Function} void ucl_tree_dadsonbro (void * @var{dad}, void * @var{son}, void * @var{bro})
Link @var{dad}, @var{son} and @var{bro} to be the parent, the son and
the bro respectively.
@end deftypefn



@deftypefun void ucl_tree_set_son (void * @var{node}, void * @var{son})
Link together the nodes referenced by @var{node} and @var{son} so
that one is the son of the other.  The old reference to the son of
@var{node} is lost; the old reference to the dad of @var{son} is
lost.
@end deftypefun


@deftypefun void ucl_tree_set_bro (ucl_node_t  @var{node}, ucl_node_t  @var{bro})
Link together the nodes referenced by @var{node} and @var{bro} so
that one is the brother of the other.  The node referenced by @var{bro}
becomes the right brother of the node referenced by @var{node}.  The old
references to the brothers of the two nodes are lost.
@end deftypefun


The following functions are used to insert subtrees in a tree.  None of
the nodes in the target tree are detached.  The links in the new subtrees
that are not interested by the relations in these functions, are left
untouched.


@deftypefun void ucl_tree_insert_dad (ucl_node_t  @var{node}, ucl_node_t  @var{dad})
Inserts a new dad for a node.  The dad node becomes the father of the
node and the first son of the old dad (if any).

@example	
 ---       ---
| A |     | A |
 ---       ---
  |         |
 ---       ---
|nod| ->  |dad|
 ---       ---
            |
           ---
          |nod|
           ---
@end example
@end deftypefun


Example of dad insertion:

@example
ucl_tree_insert_dad( 1, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   A--C
|  |            |         |
5  6            B         1--2--3--4
                          |  |
                          5  6
@end example

@noindent
the @code{D} and @code{B} nodes are detached and will be lost if we
don't keep a reference to them.


@deftypefun void ucl_tree_insert_son (ucl_node_t  @var{node}, ucl_node_t  @var{son})
Insert a new child for a node.  The node referenced by @var{son} becomes
the last between the children of the node referenced by @var{node}.

@example
 ---         ---
|nod|       |nod|
 ---         ---
  |     ->    |
 ---         ---     ---
| A |       | A |-->|son|
 ---         ---     ---
@end example
@end deftypefun


Example of son insertion:

@example
ucl_tree_insert_son( 0, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   1--2--3--4--A--C
|  |            |         |  |        |
5  6            B         5  6        B
@end example

@noindent
the node @code{D} is detached and will be lost if we don't keep a
reference to it.


@deftypefun void ucl_tree_insert_prev (ucl_node_t  @var{node}, ucl_node_t  @var{bro})
Insert a new brother for a node.  The node referenced by @var{bro}
becomes the left brother of the node referenced by @var{node}.

@example
 ---    ---          ---    ---    ---
| A |--|nod|   ->   | A |--|bro|--|nod|
 ---    ---          ---    ---    ---
@end example
@end deftypefun


Example of prev node insertion:

@example
ucl_tree_insert_prev( 2, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   1--A--2--3--4
|  |            |         |  |  |
5  6            B         5  B  6
@end example

@noindent
the @code{D} and @code{C} nodes are detached and will be lost if we
don't keep a reference to them.


@deftypefun void ucl_tree_insert_next (ucl_node_t  @var{node}, ucl_node_t  @var{bro})
Insert a new brother for a node.  The node referenced by @var{bro}
becomes the right brother of the node referenced by @var{node}.

@example
 ---    ---          ---    ---    ---
|nod|--| A |   ->   |nod|--|bro|--| A |
 ---    ---          ---    ---    ---
@end example
@end deftypefun


Example of next brother insertion:

@example
ucl_tree_insert_next( 2, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   1--2--A--3--4
|  |            |         |  |
5  6            B         5  6
@end example

@noindent
the @code{D}, @code{B} and @code{C} nodes are detached and will be lost
if we don't keep a reference to them.

@c ------------------------------------------------------------

@c page
@node tree testing
@subsection Testing relationships between nodes


@deftypefun ucl_bool_t ucl_tree_is_dad (const ucl_node_t  @var{dad}, const ucl_node_t  @var{cld_p})
Return true if the node referenced by @var{dad} is the father of the
node referenced by @var{cld_p}, otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_is_bro (const ucl_node_t  @var{node}, const ucl_node_t  @var{bro})
Return true if the node referenced by @var{node} is a brother of the
node referenced by @var{bro}, otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_has_dad (const ucl_node_t  @var{self})
Return true if the node referenced by @var{self} has a parent,
otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_has_prev (const ucl_node_t  @var{self})
Return true if the node referenced by @var{self} has a brother to the
left, otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_has_next (const ucl_node_t  @var{self})
Return true if the node referenced by @var{self} has a brother to the
right, otherwise return false.
@end deftypefun


@deftypefun ucl_bool_t ucl_tree_has_son (const ucl_node_t  @var{self})
Return true if the node referenced by @var{self} has a son, otherwise
return false.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node tree relatives
@subsection Accessing or setting the relatives of a node


@deftypefun {ucl_node_t } ucl_tree_get_dad (const ucl_node_t  @var{self})
Return a pointer to the father of the node referenced by @var{self}; if
the node has no parent: return @null{}.
@end deftypefun


@deftypefun {ucl_node_t } ucl_tree_get_prev (const ucl_node_t  @var{self})
Return a pointer to the left brother of the node referenced by
@var{self}; if the node has no left brother: return @null{}.
@end deftypefun


@deftypefun {ucl_node_t } ucl_tree_get_next (const ucl_node_t  @var{self})
Return a pointer to the right brother of the node referenced by
@var{self}; if the node has no right brother: return @null{}.
@end deftypefun


@deftypefun {ucl_node_t } ucl_tree_get_son (const ucl_node_t  @var{self})
Return a pointer to the son of the node referenced by @var{self}; if the
node has no child: return @null{}.
@end deftypefun


@deftypefun {ucl_node_t } ucl_tree_get_first (const ucl_node_t  @var{self})
Return a pointer to the first between the brothers of the node
referenced by @var{self}; it can be a pointer to @var{self} itself, if
@var{self} is the first.
@end deftypefun


@deftypefun {ucl_node_t } ucl_tree_get_last (const ucl_node_t  @var{self})
Return a pointer to the last between the brothers of the node
referenced by @var{self}; it can be a pointer to @var{self} itself, if
@var{self} is the last.
@end deftypefun

@c ------------------------------------------------------------

@c page
@node tree removing
@subsection Removing elements from a tree


@noindent
These functions will extract a node from a tree, returning a pointer to
the extracted node.


@deftypefun {ucl_node_t } ucl_tree_extract_dad (ucl_node_t  @var{node})
Extract the dad of the node referenced by @var{node} from the tree.
The referenced node and all its brothers are inserted in place of the
extracted dad.

Returns a pointer to the extracted node, or @null{} if the selected node
has nod dad.  All the pointers in the extracted node structure are reset
to @null{}.

@example
 ---    ---    ---       ---    ---    ---    ---
| A |--|dad|--| B |     | A |--|nod|--| C |--| B |
 ---    ---    ---       ---    ---    ---    ---
         |          ->
        ---    ---              ---
       |nod|--| C |            |dad|
        ---    ---              ---
@end example
@end deftypefun


@deftypefun {ucl_node_t } ucl_tree_extract_son (ucl_node_t  @var{node})
Extract the son of the node referenced by @var{node} from the tree.
The son of the selected node is extracted from the hierarchy.  All of its
children become children of the selected node.

Return a pointer to the extracted node or @null{} if the selected node
has no son.  All the pointers in the extracted node structure are reset
to @null{}.

@example
 ---               ---
|nod|             |nod|
 ---               ---
  |                 |
 ---    ---        ---    ---    ---
|son|--| C |  ->  | A |--| B |--| C |
 ---    ---        ---    ---    ---
  |
 ---    ---            ---
| A |--| B |          |son|
 ---    ---            ---
@end example
@end deftypefun


@deftypefun {ucl_node_t } ucl_tree_extract_prev (ucl_node_t  @var{node})
Extract the left brother of the node referenced by @var{node}.  The
left brother of the selected node is extracted from the hierarchy.  Its
children become left brothers of the selected node.

Return a pointer to the extracted node, or @null{} if the selected node
has no left brother.   All the pointers in the extracted node structure
are reset to @null{}.

@example
 ---               ---
| A |             | A |
 ---               ---
  |                 |
 ---    ---        ---    ---
|prv|--|nod|  ->  | B |--|nod|
 ---    ---        ---    ---
  |
 ---                   ---
| B |                 |prv|
 ---                   ---
@end example
@end deftypefun


@deftypefun {ucl_node_t } ucl_tree_extract_next (ucl_node_t  @var{node})
Extract the right brother of the node referenced by @var{node}.   The
right brother of the selected node is extracted from the hierarchy.  Its
children become right brothers of the selected node.

Return a pointer to the extracted node, or @null{} if the selected node
has no right brother.   All the pointers in the extracted node structure
are reset to @null{}.

@example
 ---    ---    ---       ---    ---    ---
|nod|--|nxt|--| A |     |nod|--| B |--| A |
 ---    ---    ---       ---    ---    ---
         |           ->
        ---                 ---
       | B |               |nxt|
        ---                 ---
@end example
@end deftypefun

@c ------------------------------------------------------------

@c page
@node tree iterators
@subsection Traversing a tree


@noindent
For the tree iterators, the return value of @function{ucl_iterator_ptr}
is a pointer to the current node.


@deftypefun void ucl_tree_iterator_inorder (ucl_node_t @var{node}, ucl_iterator_t @var{iter})
Initialises an in--order iteration.
@end deftypefun


@deftypefun void ucl_tree_iterator_preorder (ucl_node_t @var{node}, ucl_iterator_t @var{iter})
Initialises a pre--order iteration.
@end deftypefun


@deftypefun void ucl_tree_iterator_postorder (ucl_node_t @var{node}, ucl_iterator_t @var{iter})
Initialises a post--order iteration.
@end deftypefun


@c end of file
