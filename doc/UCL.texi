\input texinfo.tex @c -*-texinfo-*-
@c %**start of header
@setfilename UCL.info
@settitle Useless Container Library
@c %**end of header

@include version.texiinc

@c ------------------------------------------------------------

@macro copyrightyears{}
2001, 2002, 2003, 2004
@end macro

@macro UCL{}
@acronym{UCL}
@end macro


@c ---------------------------------------------------------
@titlepage
@title Useless Container Library
@subtitle A poor implementation of a C language container library
@author Marco Maggi
@page
@vskip 0pt plus 1filll

@noindent
Copyright @copyright{}  @copyrightyears{}  Marco Maggi.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end titlepage


@c ------------------------------------------------------------
@ifnottex
@dircategory Development
@direntry
* UCL: (ucl).                   Useless Container Library. 
@end direntry
@end ifnottex


@c ---------------------------------------------------------------------
@node Top
@top Useless Container Library

@noindent
The Useless Container Library (@acronym{UCL}) provides a set of
containers that can hold the basic set of C language types and untyped
pointers.  This library is not good as @acronym{STL} (that's why is
called @emph{Useless}), but if you use C and not C++ maybe you can find
it useless@dots{} I mean@dots{} useful.

This document refers to version @version{}.

The @acronym{UCL} is licensed under the terms of the GNU Lesser General
Public License. See the file @file{COPYING} in the distribution archive
for details.

This manual is Copyright @copyright{} @copyrightyears{} Marco Maggi.
This manual is licensed under the terms of the GNU Free Documentation
License. See the section ``Copying'' for further details.


@menu
* Overview::                    Overview of the library.
* Typedefs::                    Data types you have to know. 
* Containers::                  The data structures. 
* Iterators::                   Container iteration.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* References::                  Bibliography and references. 
* Concept Index::               An entry for each concept. 
* Function Index::              An entry for function. 
@end menu


@c ---------------------------------------------------------------------
@node Overview
@chapter Overview of the library


@noindent
This container library may be thought of as ``low level''. Methods are
provided to handle collected data, but none of the containers can be
used without wrapping it in a module whose functions ``know'' how to
deal with the type of collected data.

The containers have to be used as ``leaves'' in the graph of
dependencies of a whole application. They provide a service: collecting
data. For example: if we need to store a data structure in a linked
list, we don't have to think that the structure ``is a'' list link, but
rather that, temporarily, the structure is ``referenced by'' a list
link.

We give to the container the responsibility to hold a reference to a
structure and come back later to take it back.


@section Error handling

@noindent
The design of methods tries to be the one that maximises the number of
functions that cannot fail. This sometimes leads to ``strange'' or
``dangerous'' methods: functions that will cause the application to
crash if an argument is incorrect. But, in these cases, the library
provides a function to test the argument separately: to assert the
precondition.

For example: if a vector index is out of range, we have to make sure not
to hand it to an insertion/extraction method; we have to test it first
and make use of it only if the test result is good.



@section Memory allocation

@noindent
The @UCL{} tries to avoid as much as possible the responsibility of
allocating and freeing memory. Dynamic structures based on trees or
linked lists don't call any memory allocation function: the
responsibility to allocate @UCL{} data structures is delegated to the
user code.

This makes the library a little more complex to use, but it also makes
the library code simpler by reducing the error cases that have to be
dealt with. Also, the user code can implement a custom allocator and
feed memory blocks to the @UCL{} functions. This may come in handy
because the @UCL{} makes use of a lot of little data structures.

Memory allocation is managed through a set of macros. 

@table @code
@item ucl_malloc()
By default is @code{#define}d to @code{malloc()}.

@item ucl_realloc()
By default is @code{#define}d to @code{realloc()}.

@item ucl_free()
By default is @code{#define}d to @code{free()}.
@end table

@noindent
If @code{UCL_CUSTOM_ALLOCATOR} is not defined, @file{stdlib.h} is
included in @file{ucl.h}, and the macros get their default values.


@c ---------------------------------------------------------------------
@node Typedefs
@chapter Data types you have to know


@noindent
The types of container structures and links/nodes are described in the
sections dedicated to containers. Here common data types are described.


@deftp {Union Typedef} ucl_value_t
The data type of objects that can be stored in the containers. It's a
@code{union} with the following members:

@table @code
@item unsigned unum
@item int num
@item int integer
@item void * ptr
@item char * str
@end table
@end deftp


@deftp {Function Typedef} ucl_valcmp_t
The type of functions used to compare values of type
@code{ucl_value_t}. Functions of this type are used by the associative
containers. The prototype is:

@example
int compar (ucl_value_t a, ucl_value_t b)
@end example

@noindent
and the behaviour of the function must be the one of @code{strcmp()}:
return @code{-1} if @code{a<b}, return @code{0} if @code{a==b}, return
@code{1} if @code{a>b}.

The function has the responsibility to provide the comparison policy:
whether to use the @code{num} or @code{ptr} union members and when a
value is greater than the other. Needless to say, the function has to
know which one is the data type of values referenced/stored in the
@code{ucl_value_t} unions.
@end deftp


@deftp {Function Typedef} ucl_hashfun_t
Type of hash functions used by the hash table. The prototype is:

@example
size_t hashfun (ucl_value_t key)
@end example

@noindent
see the hash table description for more details (@ref{Hash} the hash
table container).
@end deftp

@c ---------------------------------------------------------------------
@node Containers
@chapter The data structures


@menu
* BTree::                       The binary tree structure.
* Circular::                    The circular list structure.
* Graph::                       The graph structure.
* Hash::                        The hash table structure.
* Heap::                        The heap structure.
* List::                        The linked list structure.
* Map::                         The map structure.
* String::                      The string structure.
* Strtok::                      A different string structure.
* Tree::                        The tree structure.
* Vector::                      The vector structure.
@end menu


@c ------------------------------------------------------------
@node BTree
@section The binary tree container


@cindex Binary tree container
@cindex BTree container


@noindent
The @UCL{} btree container provides an implementation of a binary tree.


@deftp {Struct Typedef} ucl_btree_node_t
The data type of the nodes. Nodes must be allocated and freed by the
user code and a pointer to them passed as arguments to the @UCL{} btree
functions: that way the container module doesn't have to deal with
memory allocation and the user code can implement a memory allocator.
@end deftp

The btree container is built as a chain of structures; each link has a
brother, a son and a parent.

@example
                 -----    bro     -----
                | no1 |--------->| no2 |
                 ----- <--------- -----
                 |  ^     dad
             son |  | dad
                 v  |
                 ----- 
                | no3 |
                 ----- 
@end example

@noindent
each node data structure is just a collection of pointers used to keep
trace of the tree hierarchy. There's no data field: to use a tree to
store data we have to include the btree node structure in another
structure; that's what the @UCL{} map container does.

Each of the three pointers in the structure can be @code{NULL}: that
means that the node has no parent, brother or son. Functions and macros
are provided: to append nodes to other nodes; to extract nodes from the
tree; to traverse the hierarchy and to find particularly interesting
nodes.


@menu
* BTree Creation::              Building btree hierarchies.
* BTree Inspection::            Accessing nodes.
* BTree Removing::              Removing elements from a btree.
* BTree Find::                  Finding special nodes.
* BTree Iteration::             Iterations in a btree hierarchy.
@end menu

@c ------------------------------------------------------------
@node BTree Creation
@subsection Building btrees hierarchies


@deftypefun void ucl_btree_constructor (ucl_btree_node_t *@var{this}, ucl_btree_node_t *@var{dadPtr})
Initialises an already allocated btree structure referenced by
@var{this}. @var{dadPtr} is a pointer to the parent node of @var{this},
or @code{NULL} if @var{this} has no parent node.

We can use this function to initialise a new node and append it to an
existing btree in a single step.
@end deftypefun


@defmac ucl_btree_init (ucl_btree_node_t *@var{this})
Resets all the node fields to NULL. It's a wrapper for the
@code{memset()} function.
@end defmac


@defmac ucl_btree_destructor (ucl_btree_node_t *@var{this})
Just a placeholder for a destructor. It's defined to the empty string.
@end defmac


@defmac ucl_btree_setdad (ucl_btree_node_t *@var{this}, ucl_btree_node_t *@var{dad})
Select a new parent node for @var{this}.
@end defmac


@defmac ucl_btree_setbro (ucl_btree_node_t *@var{this}, ucl_btree_node_t *@var{bro})
Select a new brother node for @var{this}.
@end defmac


@defmac ucl_btree_setson (ucl_btree_node_t *@var{this}, ucl_btree_node_t *@var{son})
Select a new child node for @var{this}.
@end defmac


@defmac ucl_btree_dadson (ucl_btree_node_t *@var{dad}, ucl_btree_node_t *@var{son})
Links @var{dad} and @var{son} to be the parent and the son respectively.
@end defmac


@defmac ucl_btree_dadbro (ucl_btree_node_t *@var{dad}, ucl_btree_node_t *@var{bro})
Links @var{dad} and @var{bro} to be the parent and the bro respectively.
@end defmac


Example of btree creation (let's ignore memory allocation errors for
simplicity): we want @code{a} to be the root node; @code{b} to be the
son of @code{a}; @code{c} to be the brother of @code{a}; @code{d} to be
the son of @code{c}.

@example
ucl_btree_node_t *a, *b, *c, *d;

a = malloc(sizeof(ucl_btree_node_t));
b = malloc(sizeof(ucl_btree_node_t));
c = malloc(sizeof(ucl_btree_node_t));
d = malloc(sizeof(ucl_btree_node_t));

ucl_btree_constructor(a, NULL);

ucl_btree_constructor(b, a);
ucl_btree_setson(a, b);

ucl_btree_constructor(c, a);
ucl_btree_setbro(a, c);

ucl_btree_constructor(d, c);
ucl_btree_setson(c, d);
@end example

@noindent
now the hierarchy is:

@example
       ---  bro  ---
      | a |---->| c |
       ---       ---
        |         |
    son v     son v
       ---       ---
      | b |     | d |
       ---       ---
@end example

@noindent
the following expressions are true:

@example
(a == ucl_btree_getdad(b)) && (b == ucl_btree_getson(a))
(a == ucl_btree_getdad(c)) && (c == ucl_btree_getbro(a))
(c == ucl_btree_getdad(d)) && (d == ucl_btree_getson(c))
ucl_btree_getdad(a) == NULL
ucl_btree_getbro(c) == NULL
(ucl_btree_getson(b) == NULL) && (ucl_btree_getbro(b) == NULL)
(ucl_btree_getson(d) == NULL) && (ucl_btree_getbro(d) == NULL)
@end example

@c ------------------------------------------------------------
@node BTree Inspection
@subsection Accessing nodes


@defmac ucl_btree_getdad (ucl_btree_node_t *@var{this})
Returns a pointer to the parent of @var{this} or @code{NULL} if the node
has no parent.
@end defmac


@defmac ucl_btree_getbro (ucl_btree_node_t *@var{this})
Returns a pointer to the brother of @var{this} or @code{NULL} if the
node has no brother.
@end defmac


@defmac ucl_btree_getson (ucl_btree_node_t *@var{this})
Returns a pointer to the son of @var{this} or @code{NULL} if the node
has no son.
@end defmac

@c ------------------------------------------------------------
@node BTree Removing
@subsection Removing elements from a btree


@noindent
It's a matter of setting pointers to @code{NULL}. Care must be taken not
to loose reference to subtrees.

We just use the @code{ucl_btree_setdad()}, @code{ucl_btree_setbro()} and
@code{ucl_btree_setson()} macros.


Example: detach a subtree. The brother of the node @code{a} is detached
and made an independent tree.

@example
ucl_btree_node_t *   a;
ucl_btree_node_t *   b;

a = ...;
b = ucl_btree_getbro(a);

ucl_btree_setbro(a, NULL);
ucl_btree_setdad(b, NULL);
@end example


@c ------------------------------------------------------------
@node BTree Find
@subsection Finding special nodes



@deftypefun {ucl_btree_node_t *} ucl_btree_find_leftmost (ucl_btree_node_t *@var{this})
Find the leftmost node in the subtree of the supplied node. To do this,
we traverse the tree choosing always the son of the current node.

Example:

@example   
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
starting from @code{5} the selected node is @code{1}, starting from
@code{10} the selected node is @code{6}.

Returns a pointer to the leftmost node in the @var{this} sub--hierarchy
or to @var{this} itself if it has no son.
@end deftypefun


@deftypefun {ucl_btree_node_t *} ucl_btree_find_rightmost (ucl_btree_node_t *@var{this})
Find the rightmost node in the subtree of the supplied node. To do this,
we traverse the tree choosing always the brother of the current node.

Example:

@example   
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
starting from @code{5} the selected node is @code{12}, starting from
@code{7} the selected node is @code{9}.

Returns a pointer to the rightmost node in the @var{this} sub--hierarchy
or to @var{this} itself if it has no brother.
@end deftypefun


@deftypefun {ucl_btree_node_t *} ucl_btree_find_deepest_son (ucl_btree_node_t *@var{this})
Find the deepest leftmost son in a subtree. This is different from
@code{ucl_btree_find_leftmost()}.

Example:

@example   
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example

@noindent
starting from @code{5} the selected node is @code{2}, starting from
@code{10} the selected node is @code{6}.

Returns a pointer to the deepest son in the @var{this} sub--hierarchy,
or @var{this} itself if it has no son.
@end deftypefun


@c ------------------------------------------------------------
@node BTree Iteration
@subsection Iterations in a btree hierarchy


@menu
* BTree Inorder Iteration::     Inorder iteration.
* BTree Preorder Iteration::    Preorder iteration.
* BTree Postorder Iteration::   Postorder iteration.
* BTree Level Iteration::       Level order iteration.
@end menu


@c ------------------------------------------------------------
@node BTree Inorder Iteration
@subsubsection Inorder iteration


@deftypefun {ucl_btree_node_t *} ucl_btree_step_inorder (ucl_btree_node_t *@var{this})
Advance an inorder iteration.  Inorder iteration: visit all the nodes
from the leftmost to the rightmost. Given a node in a btree, this
function performs a single step.  Returns a pointer to the next node in
the iteration, or @code{NULL} if the iteration is over.

Example:
   
@example
      5-------10----12
      |        |     |
      1--3--4  7--9 11
      |  |     |  |
      0  2     6  8
@end example

@noindent
the order is: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12.

To perform a complete iteration, we have to start from the leftmost node
(@code{0} in the picture), already visited, and begin from
there. Example:

@example
ucl_btree_node_t *        cur;

cur     = select_a_btree(...);
cur     = ucl_btree_find_leftmost(cur);

while (cur != NULL);
  @{
    makes_use_of_node(cur);
    cur = ucl_btree_step_inorder(cur);
  @}
@end example

To restrict the iteration to a subtree of a tree or to a range of nodes
in a tree, we have to select the first and last nodes and check when the
iterator reaches the last.

Example of subtree restriction:

@example
ucl_btree_node_t *        cur, end;

cur     = select_a_node(...);
end     = ucl_btree_find_rightmost(cur);

cur     = ucl_btree_find_leftmost(cur);
makes_use_of_node(cur);

while (cur != end)
  @{
    cur = ucl_btree_step_inorder(cur);
    makes_use_of_node(cur);
  @}
@end example

@code{cur} can't be @code{NULL} because @code{end} is in the subtree of
the top node; this code should work even if: @code{cur == end}.

Example of range restriction:

@example
ucl_btree_node_t *	root, cur, end;

root	= select_a_node(...);
cur	= select_first(root, ...);
end	= ucl_btree_find_rightmost(root);

makes_use_of_node(cur);

while (cur != end)
  @{
    cur = ucl_btree_step_inorder(cur);
    makes_use_of_node(cur);
  @}
@end example

@code{cur} can't be @code{NULL} since we selected the first and last
nodes in a subtree; this code should work even if: @code{root == cur ==
end}.
@end deftypefun



@deftypefun {ucl_btree_node_t *} ucl_btree_step_inorder_backward (ucl_btree_node_t *@var{this})
Advance a backward inorder iteration.  Backward inorder iteration: visit
all the nodes from the rightmost to the leftmost.  Given a node in a
btree, this function performs a single step. Returns a pointer to the
next node in the iteration, or @code{NULL} if the iteration is over.

Example:

@example   
      5-------10----12
      |        |     |
      1--3--4  7--9 11
      |  |     |  |
      0  2     6  8
@end example

@noindent
the order is: 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0.

To perform a complete iteration, we have to start from the rightmost
node (@code{12} in the picture), already visited, and begin from
there. Example:

@example
ucl_btree_node_t *        cur;

cur     = select_a_btree(...);
cur     = ucl_btree_find_rightmost(cur);

while (cur != NULL);
  @{
    makes_use_of_node(cur);
    cur = ucl_btree_step_inorder_backward(cur);
  @}
@end example

To restrict the iteration to a subtree of a tree or to a range of nodes
in a tree, we have to select the first and last nodes and check when the
iterator reaches the last.

Example of subtree restriction:

@example
ucl_btree_node_t *        cur, end;

cur     = select_a_node(...);
end     = ucl_btree_find_leftmost(cur);
cur     = ucl_btree_find_rightmost(cur);

makes_use_of_node(cur);

while (cur != end)
  @{
    cur = ucl_btree_step_inorder_backward(cur);
    makes_use_of_node(cur);
  @}
@end example

@noindent
@code{cur} can't be @code{NULL} because @code{end} is in the subtree of
the top node; this code should work even if: @code{cur == end}.

Example of range restriction:

@example
ucl_btree_node_t *        root, cur, end;

root    = select_a_node(...);
cur     = select_first(root, ...);
end     = ucl_btree_find_leftmost(root);

makes_use_of_node(cur);

while (cur != end)
  @{
    cur = ucl_btree_step_inorder_backward(cur);
    makes_use_of_node(cur);
  @}
@end example

@noindent
@code{cur} can't be @code{NULL} since we selected the first and last
nodes in a subtree; this code should work even if: @code{root == cur ==
end}.
@end deftypefun


@c ------------------------------------------------------------
@node BTree Preorder Iteration
@subsubsection Preorder iteration


@deftypefun {ucl_btree_node_t *} ucl_btree_step_preorder (ucl_btree_node_t *@var{this})
Advance a preorder iteration.  Preorder iteration: visit the current
node then the son then the brother.  Given a node in a btree this
function performs a single step.  Returns a pointer to the next node in
the preorder iteration, or @code{NULL} if the iteration is over.

Example:

@example
      5-------10----12
      |        |     |
      1--3--4  7--9 11
      |  |     |  |
      0  2     6  8
@end example

@noindent  
the order is: 5, 1, 0, 3, 2, 4, 10, 7, 6, 9, 8, 12, 11. It's a worm that
always turns ``right''.

To perform a complete iteration, we have to start from the top node of
the tree (@code{5} in the example), already visited, and begin from
there. Example:

@example
ucl_btree_node_t *        cur;

cur     = select_a_btree(...);

while (cur != NULL);
  @{
    makes_use_of_node(cur);
    cur = ucl_btree_step_pre(cur);
  @}
@end example

To restrict the iteration to a subtree of a tree, we have to check when
the iterator reaches it the top node. Example:

@example
ucl_btree_node_t *        cur, end;

end = cur = select_a_node(...);

makes_use_of_node(cur);
cur = ucl_btree_step_preorder(cur);

while (cur != end);
  @{
    makes_use_of_node(cur);
    cur = ucl_btree_step_preorder(cur);
  @}
@end example
@end deftypefun

@c ------------------------------------------------------------
@node BTree Postorder Iteration
@subsubsection Postorder iteration


@deftypefun {ucl_btree_node_t *} ucl_btree_step_postorder (ucl_btree_node_t *@var{this})
Advance a postorder iteration.  Postorder iteration: visit the son, then
the brother, then the parent node.  Returns a pointer to the next node
in the postorder iteration, or @code{NULL} if the iteration is over.

Example:

@example
      5-------10----12
      |        |     |
      1--3--4  7--9 11
         |     |  |
         2     6  8
@end example  

@noindent
the order is: 2, 4, 3, 1, 6, 8, 9, 7, 11, 12, 10, 5.

To perform a complete iteration, we have to select the deepest leftmost
son in the tree (@code{2} in the example) and begin from there. Example:

@example
ucl_btree_node_t *        cur;

cur     = select_a_node(...);
cur     = ucl_btree_find_deepest_son(cur);

while (cur != NULL);
  @{
    makes_use_of_node(cur);
    cur = ucl_btree_step_postorder(cur);
  @}
@end example

To restrict the iteration to a subtree of a tree, we have to check when
the iterator reaches the top node. Example:

@example
ucl_btree_node_t *        cur, end;

cur = end = select_a_node(...);

makes_use_of_node(cur);
cur = ucl_btree_step_postorder(cur);

while (cur != end);
  @{
    cur = ucl_btree_step_postorder(cur);
    makes_use_of_node(cur);
  @}
@end example

@noindent
@code{cur} can't be null in the loop.
@end deftypefun


@c ------------------------------------------------------------
@node BTree Level Iteration
@subsubsection Level order iteration


@deftypefun {ucl_btree_node_t *} ucl_btree_step_levelorder (ucl_btree_node_t *@var{this})
Advance a level--order iteration.  Level order iteration: visit the tree
level by level.  Returns a pointer to the next node in the levelorder
iteration, or @code{NULL} if the iteration is over.

Example:

@example  
      5-------10----12
      |        |     |
      1--3--4  7--9 11
      |  |     |  |
      0  2     6  8
@end example

@noindent
the order is: 5, 1, 10, 0, 3, 7, 12, 2, 4, 6, 9, 11, 8

We need a moving cursor that always ``turns right'' keeping the count of
the level.

To perform a complete iteration, we just call this function until it
returns @code{NULL}. Example:

@example
ucl_btree_node_t *        cur;

cur     = select_a_btree(...);

while (cur != NULL);
  @{
    makes_use_of_node(cur);
    cur = ucl_btree_step_levelorder(cur);
  @}
@end example
@end deftypefun

@c ------------------------------------------------------------
@node Circular
@section The circular list


@noindent
The circular container provides a circular double linked list. It's
implemented as a chain of little node structures; a pointer to the
@emph{current} position is stored in a base structure. The current
position marker can be moved forward and backward as a cursor.

@deftp Struct ucl_circular_t
Base structure of the container. It must be allocated by the user code,
on the stack or in a block of dynamically allocated memory.
@end deftp

@deftp Struct ucl_circular_link_t
The data type of the nodes. Nodes must be allocated and freed by the
user code and a pointer to them passed as arguments to the @UCL{}
circular functions: that way the container module doesn't have to deal
with memory allocation and the user code can implement a memory
allocator.
@end deftp

The handling of list links is derived from the handling of elements in
the @acronym{TCL} (Tool Command Language) hash table by John Ousterhout
and others (@url{http://www.tcl.tk} for more about @acronym{TCL}).


@menu
* Circular Creation::           Creating and destroying circulars.
* Circular Adding::             Adding elements to a circular.
* Circular Removing::           Removing elements from a circular.
* Circular Ops::                Various operations on a circular.
* Circular Data::               Another usage for links.
@end menu



@c ------------------------------------------------------------
@node Circular Creation
@subsection Creating and destroying circulars


@deftypefun void ucl_circular_constructor (ucl_circular_t *@var{this})
Initialises an already allocated structure.
@end deftypefun


@deftypefun void ucl_circular_destructor (ucl_circular_t *@var{this})
Destroys the structure. All the members are reset to zero. Before
calling this function the user code has to make sure that all the links
are extracted from the list.  All the structure fields are reset to
zero.
@end deftypefun


To extract all the links from a circular list, we can do:

@example
ucl_value_t val;
ucl_circular_link_t *  circPtr;
ucl_circular_link_t *  linkPtr;

...

while (ucl_circular_size(circPtr))
  @{
    ucl_circular_stepforw(circPtr);
    linkPtr = ucl_circular_extract(circPtr);

    val = ucl_circular_getval(linkPtr);

    /* insert here the code to destroy the value */
    /* insert here the code to free the link memory */
  @}
@end example

@c ------------------------------------------------------------
@node Circular Adding
@subsection Adding elements to a circular


@deftypefun void ucl_circular_insert (ucl_circular_t *@var{this}, ucl_circular_link_t *@var{linkPtr})
Inserts an element at the current position. To do this the user code
have to allocate a new circular link structure, store the value into it
and hand a pointer to the node to this function.

The old current link becomes the next link.
@end deftypefun


Example of element insertion:

@example
ucl_circular_t *       circPtr;
ucl_circular_link_t *  linkPtr;
ucl_value_t val;

circPtr = ...;

linkPtr = malloc(sizeof(ucl_circular_link_t) + sizeof(DataType));
if (linkPtr == NULL)
  @{
    /* handle the error */
  @}

val = ...;
ucl_circular_setval(linkPtr, val);
ucl_circular_insert(circPtr, linkPtr);
@end example


@c ------------------------------------------------------------
@node Circular Removing
@subsection Removing elements from a circular


@deftypefun {ucl_circular_link_t *} ucl_circular_extract (ucl_circular_t *@var{this})
Extracts the current link. It returns a pointer to the link or
@code{NULL} if the list is empty.  The new current element is the next
in the forward direction.
@end deftypefun


Example of element removal:

@example
ucl_value_t             val;
ucl_circular_t *        circPtr;
ucl_circular_link_t *   linkPtr;

circPtr = ...;

linkPtr = ucl_circular_extract(circPtr);
if (linkPtr == NULL)
  @{
    /* handle the error */
  @}

val = ucl_circular_getval(linkPtr);
free(linkPtr);
/* do something with val */
@end example


@c ------------------------------------------------------------
@node Circular Ops
@subsection Various operations on a circular


@defmac ucl_circular_size (ucl_circular_t *@var{this})
Returns the number of elements in the container. The return value is of
@code{size_t} type.
@end defmac


@defmac ucl_circular_current (ucl_circular_t *@var{this})
Returns a pointer to the current link or @code{NULL} if the container is
empty. The return value is of type @code{ucl_circular_link_t *}.
@end defmac


@defmac ucl_circular_data (ucl_circular_link_t *@var{linkPtr})
@defmacx ucl_circular_getval (ucl_circular_link_t *@var{linkPtr})
Returns a the data value in the link. The return value is of
@code{ucl_value_t} type.
@end defmac


@defmac ucl_circular_setval (ucl_circular_link_t *@var{linkPtr}, ucl_value_t @var{val})
Stores a value in a link.
@end defmac


@deftypefun void ucl_circular_forward (ucl_circular_t *@var{this}, size_t @var{times})
Moves forward the current position, @var{times} is the forward
offset. If the container is empty or the offset is zero nothing happens.
@end deftypefun


@deftypefun void ucl_circular_backward (ucl_circular_t *@var{this}, size_t @var{times})
Moves backward the current position, @var{times} is the backward
offset. If the container is empty or the offset is zero nothing happens.
@end deftypefun


@defmac ucl_circular_stepforw (ucl_circular_t *@var{this})
Move the current position one step forward. This macro assumes that the
container is not empty. Returns the pointer to the new current link.
@end defmac


@defmac ucl_circular_stepback (ucl_circular_t *@var{this})
Move the current position one step backward. This macro assumes that the
container is not empty. Returns the pointer to the new current link.
@end defmac


@deftypefun {ucl_circular_link_t *} ucl_circular_find (@var{this}, @var{val}, @var{compar})
Moves the current position to the an element whose value is equal to a
selected one. This function performs a forward element--by--element
search comparing the values in the container to the given one, using the
@var{compar} function.

Arguments:

@table @code
@item ucl_circular_t * @var{this}
pointer to the base structure;

@item ucl_value_t @var{val}
the value to find;

@item ucl_valcmp_t @var{compar}
pointer to a @code{strcmp()}--like function that's used to compare the
given value with the contained ones; @var{val} is used as first argument
to this function.
@end table
@end deftypefun


@c ------------------------------------------------------------
@node Circular Data
@subsection Another usage for links


@noindent
It's possible to allocate memory for a value together with the link
structure.

@example
typedef struct MyLink @{
  ucl_circular_link_t   link;
  Data                bigdata;
@} MyLink;

MyLink *             myPtr;
ucl_circular_link_t *  linkPtr;

linkPtr = malloc(sizeof(MyData));
myPtr   = (MyLink *) linkPtr;
linkPtr->val.ptr = &(myPtr->bigdata);
@end example

Now we can use @code{linkPtr} as a normal circular list link and access
the @code{bigdata} member through the link @code{void *} pointer.

@example
Data *  ptr;

ptr = (Data *) ucl_circular_getval(linkPtr).ptr;
@end example


@c ------------------------------------------------------------
@node Graph
@section The graph structure


@noindent
@strong{THE GRAPH STRUCTURE IS NOT IMPLEMENTED YET}.


@deftp {Struct Typedef} ucl_graph_node_t
The type of the node structure. Holds the pointer to the first outgoing
link.
@end deftp


@deftp {Struct Typedef} ucl_graph_link_t
The type of the link structure. Links originating from the same node are
organised in a linked list. Each one references the destination node.
@end deftp



@menu
* Graph Implementation::        How it's done.
* Graph Creation::              Creating and destroying graphs.
* Graph Adding::                Adding elements to a graph.
* Graph Removing::              Removing elements from a graph.
* Graph Ops::                   Various operations on a graph.
@end menu


@c ------------------------------------------------------------
@node Graph Implementation
@subsection How it's done


@noindent
A graph is a network of little structures holding pointers.


@example   
 ----     ----     ----     ----
|nod1|-->|lnk1|-->|nod2|-->|lnk4|
 ----     ----     ----     ----
            |
            v
          ----     ----
         |lnk2|-->|nod3|
          ----     ----
            |
            v 
          ----     ----
         |lnk3|-->|nod4|
          ----     ----
@end example

@c ------------------------------------------------------------
@node Graph Creation
@subsection Creating and destroying graphs


@deftypefun void ucl_graph_initnode (ucl_graph_node_t * @var{nodPtr})
A wrapper for @code{memset()}. Initialises the node structure.
@end deftypefun


@deftypefun void ucl_graph_initlink (ucl_graph_link_t * @var{lnkPtr})
A wrapper for @code{memset()}. Initialises the link structure.
@end deftypefun



@c ------------------------------------------------------------
@node Graph Adding
@subsection Adding elements to a graph


@deftypefun void ucl_graph_link	(@var{lnkPtr}, @var{fromPtr}, @var{toPtr})
Links together two nodes with a link. Arguments: 

@table @code
@item ucl_graph_link_t * @var{lnkPtr}
pointer to the link structure;

@item ucl_graph_node_t * @var{fromPtr}
pointer to the source node structure;

@item ucl_graph_node_t * @var{toPtr}
pointer to the destination node structure.
@end table
@end deftypefun


@defmac ucl_graph_setlink (ucl_graph_node_t *@var{nodPtr}, ucl_graph_link_t *@var{newPtr})
Sets the link structure referenced by @var{newPtr} as first outgoing
link for the node structure referenced by @var{nodPtr}. The pointer to
the old link (if present) is overwritten.
@end defmac


@defmac ucl_graph_getlink (ucl_graph_node_t *@var{nodPtr})
Returns a @code{ucl_graph_link_t} pointer to the first outgoing link
from the node referenced by @var{nodPtr}.
@end defmac


@defmac ucl_graph_setnext (ucl_graph_link_t *@var{lnkPtr}, ucl_graph_link_t *@var{newPtr})
Sets the link structure referenced by @var{newPtr} as next link for the
link structure referenced by @var{lnkPtr}. The pointer to the old link
(if present) is overwritten. The link referenced by @var{newPtr} becomes
an outgoing link from the same node as @var{lnkPtr} is.
@end defmac


@defmac ucl_graph_getnext (ucl_graph_link_t *@var{lnkPtr})
Returns a @code{ucl_graph_link_t} pointer referencing the next link in
the chain from the link referenced by @var{lnkPtr}.
@end defmac


@defmac ucl_graph_setnode (ucl_graph_link_t *@var{lnkPtr}, ucl_graph_node_t *@var{newPtr})
Sets the node referenced by @var{newPtr} as the destination node for the
link referenced by @var{lnkPtr}.
@end defmac


@defmac ucl_graph_getnode (lnkPtr)
Return a @code{ucl_graph_node_t} pointer referencing the destination node
of the link referenced by @var{lnkPtr}.
@end defmac



@c ------------------------------------------------------------
@node Graph Removing
@subsection Removing elements from a graph


@noindent
The extraction of links and nodes from a graph is impossible.


@c ------------------------------------------------------------
@node Graph Ops
@subsection Various operations on a graph


@defmac ucl_graph_setval (@var{ptr}, ucl_value_t @var{newval})
Stored in the link or node structure referenced by @var{ptr} a new
value.
@end defmac


@defmac ucl_graph_getval (@var{ptr})
Returns a copy of the @code{ucl_value_t} data stored in the node or link
structure referenced by @var{ptr}.
@end defmac

@c ------------------------------------------------------------
@node Hash
@section The hash table structure


@cindex Hash table container


@noindent
A hash table is a structure that maps keys to values in a way that
allows the search operation to be performed with constant for all the
keys.

@deftp {Struct Typedef} ucl_hash_t
The base structure. Two interesting fields are: @code{dim}, the number
of buckets allocated; @code{used}, the number of used buckets.
@end deftp

@deftp {Struct Typedef} ucl_hash_entry_t
The type of table elements. Both the key and the value stored in a hash
table entry are of type @code{ucl_value_t} (@ref{Typedefs}).
@end deftp

@deftypefn {Function Typedef} size_t ucl_hashfun_t (ucl_value_t @var{val})
The prototype  of the hash function.  The hash container  code will take
care of  mapping the @code{size_t}  value to an  index in the  vector of
buckets.
@end deftypefn

The hash was inspired by the book on C++ by Bjarne Stroustrup and the
hash structure in the @acronym{TCL} (Tool Command Language) source code,
by John Ousterhout and others (@url{http://www.tcl.tk/} for more about
@acronym{TCL}).


@menu
* Hash Implementation::         How it's done.
* Hash Creation::               Creating and destroying hash tables.
* Hash Adding::                 Adding elements to a hash table.
* Hash Removing::               Removing elements from a hash table.
* Hash Ops::                    Various operations on a hash table.
* Hash Resizing::               Resizing a hash table.
* Hash Iterator::               Visiting elements in the table.
* Hash Functions::              Provided hash function.
@end menu


@c ------------------------------------------------------------
@node Hash Implementation
@subsection How it's done


@noindent
A vector of pointers is allocated by the constructor. Each pointer,
called ``bucket'' in this document, can be @code{NULL} (empty bucket) or
referencing an entry structure. Entry structures are chained in a linked
list.

Let's say that the vector has @code{dim} buckets.

When inserting a new entry in the table, the hash function converts the
keys to integers in the range 0@dots{}@code{dim}-1, selecting a bucket;
then the bucket is examined: if it's @code{NULL}, it's set to the entry
pointer; if it's not @code{NULL}, the referenced entry is appended to
the new entry and the bucket is set to a pointer to the new entry.

@example
 ----                          ----
|    |                        |    |
 ----     ---     ---          ----     ---     ---     ---
|    |-->|en1|-->|en2|   ->   |    |-->|new|-->|en1|-->|en2|
 ----     ---     ---          ----     ---     ---     ---
|    |                        |    |
 ----                          ----
@end example

It's obvious how the extraction operation works.

If the keys are such that the hash function distributes entries
uniformly over all the buckets, the time spent to find an entry is (more
or less) constant.

When the hash table is resized, say to @code{newdim}, the vector is
enlarged. Now the hash function converts keys in indexes in the range
0@dots{}@code{newdim}-1, so all the entries already in the table are in
the wrong position. They must be extracted and rehashed. This is
expensive.

Can the vector be restricted? Sure! But all the entries must be rehashed
with a lesser @code{dim} before the reallocation. This operation is
currently not supported, but the algorithm is not different from the one
used to enlarge (and you have the code).

@c ------------------------------------------------------------
@node Hash Creation
@subsection Creating and destroying hash tables


@deftypefun {void *} ucl_hash_constructor (@var{this}, @var{dim}, @var{keycmp}, @var{hash})
Initialises a hash table. Arguments:

@table @code
@item ucl_hash_t * @var{this}
pointer to the already allocated structure;

@item size_t @var{dim}
the initial number of buckets;

@item ucl_valcmp_t * @var{keycmp}
pointer to a @code{strcmp()}--like function used to compare keys;

@item ucl_hashfun_t * @var{hash}
pointer to the hash function.
@end table

The vector of buckets is allocated with a call to @code{ucl_malloc()}.

Returns @code{NULL} if an error allocating the vector of buckets
occurred.
@end deftypefun


@deftypefun void ucl_hash_destructor (ucl_hash_t * @var{this})
Destroys a hash table. The vector of buckets is freed with a call to
@code{ucl_free()}. Before invoking this function all the entries must be
extracted from the table.
@end deftypefun

@c ------------------------------------------------------------
@node Hash Adding
@subsection Adding elements to a hash table


@deftypefun void ucl_hash_insert (ucl_hash_t *@var{this}, ucl_hash_entry_t *@var{entPtr})
Inserts a new entry in the table. The entry structure must be allocated
and filled with key and value by the user code. Inserting an entry with
a key that already exists in the table will work, but future invocations
of @code{ucl_hash_find()} will return one or the other: nobody knows
which.
@end deftypefun

To avoid collision of keys, we have to check the existence of a key with
@code{ucl_hash_find()} before attempting to insert a new entry.

Example:

@example
ucl_hash_t *         hashPtr;
ucl_hash_entry_t *   entryPtr;
ucl_value_t            value;

entryPtr = malloc(sizeof(ucl_hash_entry_t));
if (!entryPtr)
  @{
  @}

value = ...;
ucl_hash_setkey(entryPtr, value);
value = ...;
ucl_hash_setval(entryPtr, value);

ucl_hash_insert(hashPtr, entryPtr);
@end example


@c ------------------------------------------------------------
@node Hash Removing
@subsection Removing elements from a hash table



@deftypefun void ucl_hash_extract (ucl_hash_t *@var{this}, ucl_hash_entry_t *@var{entPtr})
Extracts an entry from the table. @var{entPtr}, a pointer to the entry
to be removed, must be the return value of a previous invocation to
@code{ucl_hash_find()}. The entry structure is not destroyed nor freed,
just extracted.
@end deftypefun


Example:

@example
ucl_hash_t *         hashPtr;
ucl_hash_entry_t *   entryPtr;
ucl_value_t            value, key, key1;

hashPtr  = ...;
key      = ...;
entryPtr = ucl_hash_find(hashPtr, key);
ucl_hash_extract(hashPtr, entPtr);

key1  = ucl_hash_getkey(entryPtr);
/* destroy key1 */

value = ucl_hash_getval(entryPtr);
/* destroy value */

free(entryPtr);
@end example

@c ------------------------------------------------------------
@node Hash Ops
@subsection Various operations on a hash table


@deftypefun {ucl_hash_entry_t *} ucl_hash_find (ucl_hash_t *@var{this}, ucl_value_t @var{key})
Search in the table an entry associated with the selected key. Returns a
pointer to the entry or @code{NULL} if the key was not found.
@end deftypefun


@defmac ucl_hash_size (ucl_hash_t *@var{this})
Returns a @code{size_t} value representing the number of entries in the
table.
@end defmac


@defmac ucl_hash_setkey (ucl_hash_entry_t *@var{entPtr}, ucl_value_t @var{newkey})
Stores a new key in an entry structure. The old key, if present, is
overwritten.
@end defmac


@defmac ucl_hash_getkey (ucl_hash_entry_t *@var{entPtr})
Returns the key stored in an entry structure.
@end defmac


@defmac ucl_hash_setval (entPtr, newval)
Stores a new value in an entry structure. The old avlue, if present, is
overwritten.
@end defmac


@defmac ucl_hash_getval (entPtr)
Returns the value stored in an entry structure.
@end defmac


@c ------------------------------------------------------------
@node Hash Resizing
@subsection Resizing a hash table


@noindent
At present the hash table is not enlarged automatically. The decision is
delegated to the user code; we have to examine the @code{dim} and
@code{used} members of the base structure and implement a reallocation
policy ourselves.

@code{dim} is the current number of allocated buckets: the second
argument to @code{ucl_hash_constructor()}. @code{used} is the number of
used buckets.


@deftypefun {void *} ucl_hash_enlarge (ucl_hash_t *@var{this}, size_t @var{newdim})
Enlarge the table. The new number of buckets is @var{newdim}: it must be
greater (not equal) to the current dimension.  This is an expensive
operation because it requires rehashing all the entries.

Returns @code{NULL} if an error reallocating the vector occurred. In
this case the table is still usable, unless you redefined the
@code{ucl_realloc()} macro to a function that messes with the input.
@end deftypefun


@c ------------------------------------------------------------
@node Hash Iterator
@subsection Visiting elements in the table


@deftypefun void ucl_hash_iterator (ucl_hash_t *@var{this}, ucl_iterator_t *@var{iterator})
Initialises the table iterator. The iterator pointer references the
entries in the table. The order in which the entries are visited is
unknown.
@end deftypefun


Example:

@example
ucl_hash_t *         hashPtr;
ucl_hash_entry_t *   entryPtr;
ucl_value_t          key, value;
ucl_iterator_t       iterator;

hashPtr  = ...;

for (ucl_hash_iterator(hashPtr, &iterator);
     ucl_iterator_more(&iterator);
     ucl_iterator_next(&iterator))
  @{
    entryPtr = ucl_iterator_ptr(&iterator);
    key      = ucl_hash_getkey(entryPtr);
    ...
  @}
@end example

@c ------------------------------------------------------------
@node Hash Functions
@subsection Provided hash function


@deftypefun size_t ucl_hash_string (ucl_value_t @var{val})
Returns an unsigned integer representing the hash value for the string
in @var{val}. The @code{str} member of @var{val} must be a pointer to a
@code{NULL}--terminated string of characters.

The hashing algorithm comes from a C++ book by Bjarne Stroustrup
(@ref{References}).
@end deftypefun


@c ------------------------------------------------------------
@node Heap
@section The heap structure


@cindex Heap container


@noindent
The heap container allows us to insert a bunch of values and extract
them sorted, from the lesser to the greater. The concept of ``lesser''
and ``greater'' are established by a user--provided function, so they
are customisable.

The heap is implemented as a binary tree. The heap node structure is
compatible with the link structure of the @code{ucl_list_t} container
(@ref{List}), so it's possible to sort a list converting it to a heap
and then rebuilding it, using list links as heap nodes directly.


@deftp {Struct Typedef} ucl_heap_t
The base structure for the heap container.
@end deftp


@deftp {Struct Typedef} ucl_heap_node_t
The type of heap nodes.
@end deftp



@menu
* Heap Creation::             Creating and destroying heaps.
* Heap Adding::               Adding elements to a heaps.
* Heap Removing::             Removing elements from a heaps.
* Heap Ops::                  Various operations on a heaps.
@end menu



@c ------------------------------------------------------------
@node Heap Creation
@subsection Creating and destroying heap


@deftypefun void ucl_heap_constructor (ucl_heap_t *@var{this}, ucl_valcmp_t *@var{valcmp})
Initialises the heap structure. @var{this} is a pointer to an already
allocated heap structure, @var{valcmp} is a pointer to a
@code{strcmp()}--like function used to compare values.
@end deftypefun


@deftypefun void ucl_heap_destructor (ucl_heap_t *@var{this})
Resets a heap structure. Before invoking this function all the nodes
must be extracted and freed by the user code.
@end deftypefun


@c ------------------------------------------------------------
@node Heap Adding
@subsection Adding elements to a heap


@deftypefun void ucl_heap_insert (ucl_heap_t *@var{this}, ucl_heap_node_t *@var{node})
Inserts a new node in the heap. @var{node} is a pointer to an already
allocated heap node structure.
@end deftypefun


Example of node insertion:

@example
ucl_heap_t *       heapPtr;
ucl_heap_node_t *  nodePtr;
ucl_value_t          value;


nodePtr = malloc(sizeof(ucl_heap_node_t));
if (nodePtr == NULL)
  @{
    /* ... */
  @}

heapPtr = ...;
value.integer = ...;
ucl_heap_setval(nodePtr, value);
ucl_heap_insert(heapPtr, nodePtr);
@end example

@c ------------------------------------------------------------
@node Heap Removing
@subsection Removing elements from a heap


@deftypefun {ucl_heap_node_t *} ucl_heap_extract (ucl_heap_t *@var{this})
Extracts a node from the heap. The node is the one with the smallest
value. Returns a pointer to the node.
@end deftypefun


Example of node extraction:

@example
ucl_heap_t *       heapPtr;
ucl_heap_node_t *  nodePtr;
ucl_value_t          value;

heapPtr = ...;
nodePtr = ucl_heap_extract(heapPtr);
value   = ucl_heap_getval(nodePtr);
free(nodePtr);
@end example

@c ------------------------------------------------------------
@node Heap Ops
@subsection Various operations on a heap


@defmac ucl_heap_size (ucl_heap_t *@var{this})
Returns a value of type @code{size_t} representing the number of nodes
in the heap.
@end defmac


@defmac ucl_heap_setval (ucl_heap_node_t *@var{nodePtr}, ucl_value_t @code{newval})
Stores a new value in a heap node.
@end defmac


@defmac ucl_heap_getval (ucl_heap_node_t *@var{nodePtr})
Returns a copy of the value, of type @code{ucl_value_t}, stored in a heap
node.
@end defmac

@c ------------------------------------------------------------
@node List
@section The linked list structure


@noindent
The @UCL{} list container is an implementation of the classic double
linked list: elements are stored in little structures chained together
with pointers that allow the user code to iterate forward and backward.

@deftp Struct ucl_list_t
The data type of the base structure. It must be allocated by the user
code, on the stack or in a block of dynamically allocated memory.
@end deftp

@deftp Struct ucl_list_link_t
The data type of the nodes. Nodes must be allocated and freed by the
user code and a pointer to them passed as arguments to the @UCL{} list
functions: that way the container module doesn't have to deal with
memory allocation and the user code can implement a memory allocator.
@end deftp

The handling of  list links is derived from the  handling of elements in
the @acronym{TCL} (Tool Command  Language) hash table by John Ousterhout
and others (@url{http://www.tcl.tk} for more about @acronym{TCL}).


@menu
* List Creation::               Creating and destroying lists.
* List Adding::                 Adding elements to a list.
* List Removing::               Removing elements from a list.
* List Ops::                    Various operations on a list.
* List Iteration::              Iteration over a list.
@end menu


@c ------------------------------------------------------------
@node List Creation
@subsection Creating and destroying lists


@deftypefun void ucl_list_constructor (ucl_list_t *@var{this})
Initialises an already allocated structure to build a new list
container.
@end deftypefun


@deftypefun void ucl_list_destructor (ucl_list_t *@var{this})
Destroys the structure pointed by @var{this}. The structure itself is
not deallocated. Before calling this the user code has to make sure that
all the links are extracted from the list.

All the structure fields are reset to zero.  This concept of
``destruction'' is still in development in the head of the author, so it
may change in future releases; it's better, though, to have the code
invoke a destructor, so if things will change we have it in place. It
may even be replaced by a do--nothing @code{#define}.
@end deftypefun


To extract all the links from a list, we can do:

@example
ucl_list_t *       listPtr;
ucl_list_link_t *  linkPtr;
ucl_value_t        val;

...

while(ucl_list_size(listPtr))
 @{
    linkPtr = ucl_list_popfront(listPtr);
    val     = ucl_list_getval(linkPtr);

    /* insert here the code to destroy the object */
    /* insert here the code to free the link memory */
 @}
@end example

@noindent
popping elements from the front or from the back no difference.

@c ------------------------------------------------------------
@node List Adding
@subsection Adding elements to a list


@deftypefun void ucl_list_insertafter (@var{this}, @var{linkPtr}, @var{newPtr})
Inserts an element after a link.  The new link is inserted after the
selected one; if the selected link is the last in the chain, the new
link becomes the last in the chain.

This function can't be used to insert an element in an empty list.

Arguments:

@table @code
@item ucl_list_t *@var{this}
pointer to the base structure;

@item ucl_list_link_t *@var{linkPtr}
pointer to a link in the list, it must be the return value of a previous
invocation of @code{ucl_list_index()};

@item ucl_list_link_t *@var{newPtr}
pointer to a new list link.
@end table
@end deftypefun


@deftypefun void ucl_list_insertbefore (@var{this}, @var{linkPtr}, @var{newPtr})
Inserts an element before a link.  The new link is inserted before the
selected one; if the selected link is the first in the chain, the new
link becomes the first in the chain.

This function can't be used to insert an element in an empty list.

Arguments:

@table @code
@item ucl_list_t *@var{this}
pointer to the base structure;

@item ucl_list_link_t *@var{linkPtr}
pointer to a link in the list, it must be the return value of a previous
invocation of @code{ucl_list_index()};

@item ucl_list_link_t *@var{newPtr}
pointer to a new list link.
@end table
@end deftypefun


@deftypefun void ucl_list_pushfront (ucl_list_t *@var{this}, ucl_list_link_t *@var{linkPtr})
Inserts an element at the beginning of the list. This function can be
used to insert an element in an empty list.
@end deftypefun


@deftypefun void ucl_list_pushback (ucl_list_t *@var{this}, ucl_list_link_t *@var{linkPtr})
Inserts an element at the end of the list. This function can be used to
insert an element in an empty list.
@end deftypefun


@c ------------------------------------------------------------
@node List Removing
@subsection Removing elements from a list


@deftypefun void ucl_list_extract (ucl_list_t *@var{this}, ucl_list_link_t *@var{linkPtr})
Extracts a selected link. @var{linkPtr} is pointer to a list link, it
must be the return value of a previous invocation of
@code{ucl_list_index()}.
@end deftypefun


Example of element removal:

@example
ucl_list_t *      listPtr;
ucl_list_link_t * linkPtr;
size_t            position;

position = ...

linkPtr = ucl_list_index(this, position);
if (linkPtr == NULL)
  @{
    ...
  @}
ucl_list_extract(this, linkPtr);
@end example


@defmac ucl_list_popfront (ucl_list_t *@var{this})
Removes an element at the beginning of the list. This is a wrapper for
@code{ucl_list_extract()}.
@end defmac


@defmac ucl_list_popback (ucl_list_t *@var{this})
Removes an element at the end of the list. This is a wrapper for
@code{ucl_list_extract()}.
@end defmac

@c ------------------------------------------------------------
@node List Ops
@subsection Various operations on a list



@defmac ucl_list_size (ucl_list_t *@var{this})
Returns a @code{size_t} value representing the number of elements in the
container.
@end defmac


@defmac ucl_list_index (ucl_list_t *@var{this}, size_t @var{index})
Converts a position in a pointer to the corresponding list link.
Returns a pointer to the selected link, or @code{NULL} if the index is
out of range.
@end defmac


@defmac ucl_list_getval (ucl_list_link_t *@var{linkPtr})
Returns a @code{ucl_value_t} value representing the data of a link.
@end defmac


@defmac ucl_list_setval (ucl_list_link_t *@var{linkPtr}, ucl_value_t @var{val})
Stores a new value in a link.
@end defmac


@defmac ucl_list_front (const ucl_list_t *@var{this})
Returns a pointer to the first link in the list or @code{NULL} if the
list is empty.
@end defmac


@defmac ucl_list_back (const ucl_list_t *@var{this})
Returns a pointer to the last link in the list or @code{NULL} if the
list is empty.
@end defmac


@defmac ucl_list_next (ucl_list_link_t * @var{linkPtr})
Returns a pointer to the link next to @var{linkPtr} or @code{NULL} if
@var{linkPtr} is the last in the chain.
@end defmac


@defmac ucl_list_prev (ucl_list_link_t * @var{linkPtr})
Returns a pointer to the previous link of @var{linkPtr} or @code{NULL}
if @var{linkPtr} is the first in the chain.
@end defmac


@c ------------------------------------------------------------
@node List Iteration
@subsection Iteration over a list


@noindent
Example of forward iteration:

@example
ucl_list_t *       this;
ucl_list_link_t *  linkPtr;
ucl_value_t        val;

...

for (linkPtr = ucl_list_front(listPtr);
     linkPtr != NULL;
     linkPtr = ucl_list_next(linkPtr))
  @{
    val = ucl_list_getval(linkPtr);
    ...
  @}
@end example


Example of backward iteration:

@example
ucl_list_t *       this;
ucl_list_link_t *  linkPtr;
ucl_value_t        val;

...

for (linkPtr = ucl_list_back(listPtr);
     linkPtr != NULL;
     linkPtr = ucl_list_prev(linkPtr))
  @{
    val = ucl_list_data(linkPtr);
    ...
  @}
@end example

@c ------------------------------------------------------------
@node Map
@section The map structure


@cindex Map container


@noindent
The @code{ucl_map_t} structure can be used to implement an associative
array; it's implemented as an AVL tree.


@deftp Struct ucl_map_t
Base structure for the container. It must be allocated by the user code,
on the stack or in a block of dynamically allocated memory.
@end deftp


@deftp Struct ucl_map_link_t
The data type of the nodes. Nodes must be allocated and freed by the
user code and a pointer to them passed as arguments to the @UCL{} map
functions: that way the container module doesn't have to deal with
memory allocation and the user code can implement a memory allocator.
@end deftp


The map/multimap idea was inspired by the book on C++ by Bjarne
Stroustrup and by the STL C++ (Standard Template Library) by Stepanov
and Lee.

The handling of nodes is influenced by the handling of elements in the
@acronym{TCL} (Tool Command Language) hash table by John Ousterhout and
others (@url{http://www.tcl.tk/} for more about @acronym{TCL}).

@menu
* Map Intro::                   Introduction to the operations and the
                                selected implementation.
* Map Creation::                Creating and destroying maps.
* Map Adding/Removing::         Adding and removing elements to a map.
* Map Accessors::               Accessing values and keys.
* Map Ops::                     Various operations on a map.
* Map Iterators::               Iteration over a map.
* Set Iterators::               Composing map iterators.
@end menu


@c ------------------------------------------------------------
@node Map Intro
@subsection Introduction to the operations and the selected implementation


@noindent
Maps are often used as associative arrays, that is: as collections of
key/value pairs.  The operations we want to do on a map are:

@itemize
@item
add a key/value pair, if the element already exists replace the old
value with the new one or add a new key/value pair;

@item
find a key/value pair with a specified key;

@item
remove all key/value pairs with a selected key, or the one with a
selected value among the ones having the same key;

@item
traverse the collection of key/value pairs from the lesser key to the
greater;

@item
traverse the collection of key/value pairs from the greater key to the
lesser.
@end itemize

Clearly there are two sub--types of map container: the one that allows
multiple values to be associated to the same key, and the one that
doesn't. We call the first a @dfn{multimap} and the second a @dfn{simple
map}.


@c ------------------------------------------------------------
@node Map Creation
@subsection Creating and destroying maps


@deftypefun void ucl_map_constructor (@var{this}, @var{flags}, @var{keycmp})
Initialises an already allocated map structure.

Arguments:

@table @code
@item ucl_map_t * @var{this}
pointer to the already allocated map structure;

@item unsigned int @var{flags}
map behaviour flags;

@item ucl_valcmp_t * @var{keycmp}
pointer to the @code{strcmp()}--like function used to compare keys.
@end table

Map configuration @var{flags} can be an ORed combination of:

@table @code
@item UCL_ALLOW_MULTIPLE_OBJECTS
allows more than one object to be associated to the same key, with this
the map behaves like a multimap.
@end table
@end deftypefun


@deftypefun void ucl_map_destructor (ucl_map_t *@var{this})
Destroys a map structure, the structure itself is not deallocated. The
elements are reset to zero.

Before invoking this function the user code has to extract all the nodes
from the map.  If the elements are not extracted before this function is
invoked, at least memory leakage will happen.
@end deftypefun


@c ------------------------------------------------------------
@node Map Adding/Removing
@subsection Adding and removing elements to a map


@deftypefun void ucl_map_insert (ucl_map_t *@var{this}, ucl_map_link_t *@var{linkPtr})
Given an already allocated and constructed map link, inserts it in the
map. This functions always succeeds if @var{this} references a multimap,
can lead to an error if @var{this} is a simple map and an element with
the same key already exists. If such a condition occurs, this function
@strong{silently does nothing}; it's our responsibility to use
@code{ucl_map_find()} to check for the element existence.
@end deftypefun

Example of link insertion in a simple map:

@example
ucl_map_t *      this;
ucl_map_link_t * link;

ucl_value_t        key;
ucl_value_t        obj;

/* ... */

key = ...;
obj = ...;

link = ucl_map_find(this, key);
if (link == NULL)
  @{
    link = (ucl_map_link_t *) malloc(sizeof(ucl_map_link_t));
    ucl_map_setkey(link, key);
    ucl_map_setval(link, obj);
    ucl_map_insert(this, link);
  @}
@end example


@deftypefun {ucl_map_link_t *} ucl_map_remove (ucl_map_t *@var{this}, ucl_map_link_t *@var{linkPtr})
Removes from the map the key/value pair in the element referenced by
@var{linkPtr}. This must be the return value of a previous invocation of
@code{ucl_map_find()}. This function only removes the link from the map:
it's our responsibility to free the key, the object and the link
structure itself.

Returns a pointer to the extracted link.
@end deftypefun


Example of link removal:

@example
ucl_map_t *      this;
ucl_map_link_t * link;

ucl_value_t        key;
ucl_value_t        obj;

/* ... */

link = ucl_map_find(this, key);
if (link != NULL)
  @{
    ucl_map_remove(this, link);
    key = ucl_map_getkey(link);
    obj = ucl_map_getval(link);
    free(link);

    /* free "key" and "obj" */
  @}
@end example

@c ------------------------------------------------------------
@node Map Accessors
@subsection Accessing values and keys


@defmac ucl_map_setkey (ucl_map_link_t *@var{linkPtr}, ucl_value_t @var{newKey})
Stores a key in a link. Returns nothing.
@end defmac


@defmac ucl_map_setval (ucl_map_link_t *@var{linkPtr}, ucl_value_t @var{newObj})
Stores an object in a link. Returns nothing.
@end defmac


@defmac ucl_map_getkey (ucl_map_link_t *@var{linkPtr})
Returns the key in a map link. It's of type @code{ucl_value_t}.
@end defmac


@defmac ucl_map_getval (ucl_map_link_t *@var{linkPtr})
Returns the object in a map link. It's of type @code{ucl_value_t}.
@end defmac


@c ------------------------------------------------------------
@node Map Ops
@subsection Various operations on a map


@deftypefun size_t ucl_map_count (const ucl_map_t *@var{this}, const ucl_value_t @var{key})
Returns the number of elements with @var{key}; this is always 0 or 1 for
simple maps
@end deftypefun


@deftypefun {ucl_map_link_t *} ucl_map_find (const ucl_map_t *@var{this}, const ucl_value_t @var{key});
Returns a pointer to the (first found) element associated with
@var{key}. The return value is @code{NULL} if such an element doesn't
exist.

For a multimap, this function returns a pointer to the first element
with the selected key, so that the others can be found with repeated
invocations of @code{ucl_map_next()}.
@end deftypefun


@deftypefun {ucl_map_link_t *} ucl_map_first (const ucl_map_t *@var{this})
Returns a pointer to the element with lesser key in the map, or
@code{NULL} if the map is empty.
@end deftypefun


@deftypefun {ucl_map_link_t *} ucl_map_last (const ucl_map_t *@var{this})
Returns a pointer to the element with greater key in the map, or
@code{NULL} if the map is empty.
@end deftypefun


@deftypefun {ucl_map_link_t *} ucl_map_next (ucl_map_link_t *@var{linkPtr})
Returns a pointer to the element adjacent to the one referenced by
@var{linkPtr} with greater key, or @code{NULL} if @var{linkPtr} has the
greater key in the map.
@end deftypefun


@deftypefun {ucl_map_link_t *} ucl_map_prev (ucl_map_link_t *@var{linkPtr})
Returns a pointer to the element adjacent to the one referenced by
@var{linkPtr} with lesser key, or @code{NULL} if @var{linkPtr} has the
lesser key in the map.
@end deftypefun


@deftypefun {ucl_map_link_t *} ucl_map_find_or_next (ucl_map_t *@var{this}, ucl_value_t * @var{key})
Given a key find the element in the map associated with it, or the
element with the lesser key greater than the selected one.  Returns a
pointer to the requested link or @code{NULL} if all the keys in the map
are lesser than the selected one.
@end deftypefun


@deftypefun {ucl_map_link_t *} ucl_map_find_or_prev (ucl_map_t *@var{this}, ucl_value_t * @var{key})
Given a key find the element in the map associated with it, or the
element with the greater key lesser than the selected one.  Returns a
pointer to the requested link or @code{NULL} if all the keys in the map
are greater than the selected one.
@end deftypefun


@defmac ucl_map_size (const ucl_map_t *@var{this})
Returns the number of elements in the map. It's of type @code{size_t}
@end defmac


@c ------------------------------------------------------------
@node Map Iterators
@subsection Iteration over a map


@noindent
For the map, the iteration is over the map links: the macro
@code{ucl_iterator_ptr()} returns a pointer to the current map link.
We can use the @code{ucl_map_getkey()} and @code{ucl_map_setkey()} to
acquire the keys and values.


@deftypefun void ucl_map_iterator_inorder (@var{this}, @var{iterator})
Initalises an inorder iteration.

@table @code
@item const ucl_map_t *@var{this}
pointer to the map structure;

@item ucl_iterator_t *@var{iterator}
pointer to the iterator structure.
@end table
@end deftypefun


@deftypefun void ucl_map_iterator_preorder (@var{this}, @var{iterator})
Initialises a preorder iteration.

@table @code
@item const ucl_map_t *@var{this}
pointer to the map structure;

@item ucl_iterator_t *@var{iterator}
pointer to the iterator structure.
@end table
@end deftypefun


@deftypefun void ucl_map_iterator_postorder (@var{this}, @var{iterator})
Initialises a postorder iteration.

@table @code
@item const ucl_map_t *@var{this}
pointer to the map structure;

@item ucl_iterator_t *@var{iterator}
pointer to the iterator structure.
@end table
@end deftypefun


@deftypefun void ucl_map_iterator_levelorder (@var{this}, @var{iterator})
Initialises a level order iteration.

@table @code
@item const ucl_map_t *@var{this}
pointer to the map structure;

@item ucl_iterator_t *@var{iterator}
pointer to the iterator structure.
@end table
@end deftypefun


@deftypefun void ucl_map_lower_bound (@var{this}, @var{iterator}, @var{key})
Initialises an iteration over the elements with the selected key,
starting with the first element.

@table @code
@item const ucl_map_t *@var{this}
pointer to the map structure;

@item ucl_iterator_t *@var{iterator}
pointer to the iterator structure;

@item const ucl_value_t @var{key}
the selected key.
@end table
@end deftypefun



@deftypefun void ucl_map_upper_bound (@var{this}, @var{iterator}, @var{key})
Initialises an iteration over the elements with the selected key,
starting with the last element.

@table @code
@item const ucl_map_t *@var{this}
pointer to the map structure;

@item ucl_iterator_t *@var{iterator}
pointer to the iterator structure;

@item const ucl_value_t @var{key}
the selected key.
@end table
@end deftypefun


@c ------------------------------------------------------------
@node Set Iterators
@subsection Composing map iterators


@cindex Set iterators


@noindent
It's possible to compose map iterators to implement set operations: the
keys from a map are used as set elements. The values are not
considered. A set operation is implemented as an iterator that visits
one by one the result of the operation itself.

The key values must be of the same data type. That means that the
compare function used by both the maps, must accept the same type of
values and return the same values when called with the same arguments.

For all the set iterators, the arguments are:

@table @code
@item ucl_iterator_t * @var{it1}
pointer to an in--order iterator over set 1, already initialised;

@item ucl_iterator_t * @var{it2}
pointer to an in--order iterator over set 2, already initialised;

@item ucl_iterator_t * @var{iter}
pointer to the set iterator structure.
@end table

The input map iterators must be of in--order type: if the sequences are
visited from the lesser to the greater key, the minimum amount of key
comparison is performed.

If the sequences are not visited with the in--order iterator, the result
is not defined.

The set iterators are used in the same fashion of all the other
iterators in the @acronym{UCL} (@ref{Iterators}). The value retrieved
with the @code{ucl_iterator_ptr()} macro is the pointer to the
referenced map link.

@deftypefun void ucl_map_iterator_union (@var{it1}, @var{it2}, @var{iter})
Initialises the iteration over all the elements from both the
sequences. Elements present in both sequences are included twice.
@end deftypefun


@deftypefun void ucl_map_iterator_intersection (@var{it1}, @var{it2}, @var{iter})
Initialises  the iteration  over all  the elements  present in  both the
sequences. Elements included in only one sequence are discarded.
@end deftypefun


@deftypefun void ucl_map_iterator_complintersect (@var{it1}, @var{it2}, @var{iter})
Initialises the iteration over all the elements present in only one of
the two sequences.
@end deftypefun


@deftypefun void ucl_map_iterator_subtraction (@var{it1}, @var{it2}, @var{iter})
Initialises the iteration over all the elements from sequence 1 that are
not present in sequence 2.
@end deftypefun


Example:

@example
Sequence 1: 0 1 2 3 4 5 6
Sequence 2: 4 5 6 7 8 9
Union: 0 1 2 3 4 4 5 5 6 6 7 8 9
Intersection: 4 5 6
Complementary intersection: 0 1 2 3 7 8 9
Subtraction: 0 1 2 3
@end example


@c ------------------------------------------------------------
@node String
@section The string structure


@cindex String container


@noindent
The @UCL{} string container is an implementation of the classic array
with redundant memory allocation.

@deftp {Struct Typedef} ucl_string_t
The data type of the base structure. With this type of string, the
metadata (length, buffer size) is stored in the same dynamically
allocated memory block as the characters data. It is supposed to be used
in the same fashion of a normal array of characters.
@end deftp

This data type represents the string with a null--terminated array of
characters and can allocate more memory than strictly required, so that
the number of reallocations when appending data to a string can be
minimised. The @UCL{} string functions will use @code{ucl_malloc()},
@code{ucl_realloc()} and @code{ucl_free()} to handle memory allocation.

The structure has the following data members:

@table @code
@item size_t size
the number of bytes actually allocated for the array of characters;
being the string representation null--terminated, this is one unit
higher than the maximum possible string length;

@item size_t len
the actual length of the string in the array of character; this is the
index of the terminating null character;

@item char * ptr
pointer to the array, we use it to access the data.
@end table


This module was inspired by the book on C++ by Bjarne Stroustrup, by the
STL C++ (Standard Template Library) and the TCL (Tool Command Language)
string manipulation functions.


@menu
* String Creation::             Creating and destroying strings.
* String Adding::               Adding elements to a string.
* String Removing::             Removing elements from a string.
* String Access::               Accessing string data.
* String Ops::                  Various operations on a string.
* String Memory::               Allocating and freeing memory.
@end menu



@c ------------------------------------------------------------
@node String Creation
@subsection Creating and destroying strings


@deftypefun {ucl_string_t *} ucl_string_constructor (size_t @var{size})
Allocates and initialises an empty string. Returns a pointer to the
allocated structure or @code{NULL} if an error occurred allocating
memory. @var{size} is the exact size of the allocated data buffer.
@end deftypefun


@defmac ucl_string_destructor (ucl_string_t *@var{this})
Destroys the structure pointed by @var{this}. The block of dynamically
allocated memory is freed.  After the call to this function the pointer
is no more valid.
@end defmac


@deftypefun {ucl_string_t *} ucl_string_duplicate (ucl_string_t *@var{this})
Duplicates a string. A new memory block is allocated and the string
referenced by @var{this} is duplicated into it. The size of the new
string buffer may be different from the size of the original string.

Returns a pointer to the new string structure or @code{NULL} if an error
allocating memory occurs.
@end deftypefun


Example of @code{ucl_string_t} allocation:

@example
ucl_string_t *   strPtr;

strPtr = ucl_string_constructor(23);
if (! strPtr)
  @{
    /* handle the error */
  @}
/* do something with strPtr */
ucl_string_destructor(strPtr);
@end example

@c ------------------------------------------------------------
@node String Adding
@subsection Adding elements to a string


@deftypefun void ucl_string_insert (@var{this}, @var{position}, @var{c})
Inserts an element at a selected position.  It assumes that there's a
free slot to hold the new element, to make sure that it's there we have
to call @code{ucl_string_enlarge()} (@ref{String Memory}).

Arguments:

@table @code
@item ucl_string_t *this
pointer to the base structure;
@item size_t position
the position of the new element;
@item const char c
the element to insert.
@end table
@end deftypefun


@defmac ucl_string_pushfront (ucl_string_t *@var{this}, const char @var{val})
Inserts an element at the beginning of the string. This is a wrapper for
@code{ucl_string_insert()} and so it returns the same value.
@end defmac


@defmac ucl_string_pushback (ucl_string_t *@var{this}, const char @var{val})
Inserts an element at the end of the string. This is a wrapper for
@code{ucl_string_insert()} and so it returns the same error value.
@end defmac


@c ------------------------------------------------------------
@node String Removing
@subsection Removing elements from a string


@deftypefun void ucl_string_erase (ucl_string_t *@var{this}, size_t @var{position})
Removes an element at a selected @var{position}: the slot is overwritten
moving the characters following it. The memory is not reallocated to
restrict the block: to do this we have to invoke
@code{ucl_string_restrict()} (@ref{String Memory}).
@end deftypefun


@defmac ucl_string_popfront (ucl_string_t *@var{this})
Removes an element at the beginning of the string. This is a wrapper for
@code{ucl_string_erase()} and so it returns the same value.
@end defmac


@defmac ucl_string_popback (ucl_string_t *@var{this})
Removes an element at the end of the string. This is a wrapper for
@code{ucl_string_insert()} and so it returns the same value.
@end defmac


@c ------------------------------------------------------------
@node String Access
@subsection Accessing string data.


@defmac ucl_string_data (ucl_string_t *@var{this})
Returns a pointer to the first character in the string.
@end defmac


@defmac ucl_string_back (ucl_string_t *@var{this})
Accesses the last element in the string. It supposes that the container
is not empty, so that the element it's there; we have to make sure of
this, for example, by checking the size of the string first.
@end defmac


@defmac ucl_string_front (ucl_string_t *@var{this})
Accesses the first element in the string. It supposes that the container
is not empty, so that the element it's there; we have to make sure of
this, for example, by checking the size of the string first.
@end defmac


@defmac ucl_string_getval (ucl_string_t *@var{this}, size_t @var{position})
Accesses the element at @var{position}. It supposes that @var{position}
is a valid index for the string, we can check this with
@code{ucl_string_isindex()}.
@end defmac


@defmac ucl_string_setval (ucl_string_t *@var{this}, size_t @var{position}, char @var{c})
Stores a new element at @var{position}. It supposes that @var{position}
is a valid index for the string, we can check this with
@code{ucl_string_isindex()}. The old element is overwritten.
@end defmac


@defmac ucl_string_size (ucl_string_t *@var{this})
Returns a @code{size_t} value represenging the buffer size.
@end defmac


@defmac ucl_string_len (ucl_string_t *@var{this})
Returns a @code{size_t} value representing the number of characters in
the string.
@end defmac


@defmac ucl_string_isindex (ucl_string_t *@var{this}, size_t @var{position})
Returns true (an integer) if @var{position} is a valid index for the
string referenced by @var{this}. It must be a positive integer greater
or equal to zero and lesser than the number of elements in the
container (@code{size_t} should be an unsigned type).
@end defmac

@c ------------------------------------------------------------
@node String Ops
@subsection Various operations on a string



@deftypefun void ucl_string_randomise (ucl_string_t *@var{this})
Shuffles the string characters. @code{rand()} is used to generate the
entropy.
@end deftypefun


@deftypefun void ucl_string_swap (ucl_string_t *@var{this}, size_t @var{a}, size_t @var{b})
Swaps two elements in the string.  This function assumes that the
indexes are not out of range.
@end deftypefun


@defmac ucl_string_compare (ucl_string_t *@var{one}, ucl_string_t *@var{two})
A wrapper for @code{strcmp()} that applies to string structures.
@end defmac

@c ------------------------------------------------------------
@node String Memory
@subsection Allocating and freeing memory


@defmac ucl_string_isfull (ucl_string_t *@var{this})
Returns true if the string buffer is full.
@end defmac


@deftypefun {void *} ucl_string_resize (ucl_string_t *@var{this}, size_t @var{size})
Reallocates a string to resize the buffer. If the new size is lesser
than the length of the string, the tail is truncated.  Returns the new
pointer to the string, or @code{NULL} if an error occurred reallocating
memory.
@end deftypefun


@deftypefun {void *} ucl_string_enlarge (ucl_string_t *@var{this})
If the string is full, enlarge the buffer size to the next multiple of
@code{UCL_STRING_STEP_UP} starting from the buffer size. Returns the new
pointer to the string, or @code{NULL} if an error occurred reallocating
memory.
@end deftypefun


@deftypefun {void *} ucl_string_restrict (ucl_string_t *@var{this})
Restrict the buffer size to the next multiple of
@code{UCL_STRING_STEP_UP} starting from the string length. Returns the
new pointer to the string, or @code{NULL} if an error occurred
reallocating memory.
@end deftypefun


@c ------------------------------------------------------------
@node Strtok
@section The string structure


@cindex Strtok container


@noindent
The @UCL{} string token container is an implementation of the classic
array with redundant memory allocation.

@deftp {Struct Typedef} ucl_strtok_t
The data type of the base structure.
@end deftp

This data type represents the string with a null--terminated array of
characters and can allocate more memory than strictly required, so that
the number of reallocations when appending data to a string can be
minimised. The @UCL{} string functions will use @code{ucl_malloc()},
@code{ucl_realloc()} and @code{ucl_free()} to handle memory allocation.

The structure has the following data members:

@table @code
@item size_t size
the number of bytes actually allocated for the array of characters;
being the string representation null--terminated, this is one unit
higher than the maximum possible string length;

@item size_t len
the actual length of the string in the array of character; this is the
index of the terminating null character;

@item char * ptr
pointer to the array, we use it to access the data.
@end table


This module was inspired by the book on C++ by Bjarne Stroustrup, by the
STL C++ (Standard Template Library) and the TCL (Tool Command Language)
string manipulation functions.


@menu
* Strtok Creation::             Creating and destroying strings.
* Strtok Adding::               Adding elements to a string.
* Strtok Removing::             Removing elements from a string.
* Strtok Access::               Accessing string data.
* Strtok Ops::                  Various operations on a string.
* Strtok Memory::               Allocating and freeing memory.
@end menu



@c ------------------------------------------------------------
@node Strtok Creation
@subsection Creating and destroying strings


@deftypefun {char *} ucl_strtok_constructor (ucl_strtok_t *@var{this}, size_t @var{size})
Initialises an already allocated string token. Returns a pointer to the
allocated buffer or @code{NULL} if an error occurred allocating
memory. @var{size} is the exact size of the allocated data buffer.
@end deftypefun


@deftypefun void ucl_strtok_destructor (ucl_strtok_t *@var{this})
Destroys the string pointed by @var{this}. The block of dynamically
allocated memory is freed.
@end deftypefun


@deftypefun {char *} ucl_strtok_duplicate (ucl_strtok_t *@var{dst}, ucl_strtok_t *@var{src})
Duplicates a the string in @var{src} into the string @var{dst}.  The
size of the new string buffer may be different from the size of the
original one. Returns a pointer to the new buffer in @var{dst}, or
@code{NULL} if an error allocating memory occurs.
@end deftypefun


Example of @code{ucl_strtok_t} allocation:

@example
char *         ptr;
ucl_strtok_t *   strPtr;

ptr = ucl_strtok_constructor(strPtr, 23);
if (! ptr)
  @{
    /* handle the error */
  @}
/* do something with strPtr */
ucl_strtok_destructor(strPtr);
@end example

@c ------------------------------------------------------------
@node Strtok Adding
@subsection Adding elements to a string


@deftypefun void ucl_strtok_insert (@var{this}, @var{position}, @var{c})
Inserts an element at a selected position.  It assumes that there's a
free slot to hold the new element, to make sure that it's there we have
to call @code{ucl_strtok_enlarge()} (@ref{Strtok Memory}).

Arguments:

@table @code
@item ucl_strtok_t *this
pointer to the base structure;
@item size_t position
the position of the new element;
@item const char c
the element to insert.
@end table
@end deftypefun


@defmac ucl_strtok_pushfront (ucl_strtok_t *@var{this}, const char @var{val})
Inserts an element at the beginning of the string. This is a wrapper for
@code{ucl_strtok_insert()} and so it returns the same value.
@end defmac


@defmac ucl_strtok_pushback (ucl_strtok_t *@var{this}, const char @var{val})
Inserts an element at the end of the string. This is a wrapper for
@code{ucl_strtok_insert()} and so it returns the same error value.
@end defmac


@c ------------------------------------------------------------
@node Strtok Removing
@subsection Removing elements from a string


@deftypefun void ucl_strtok_erase (ucl_strtok_t *@var{this}, size_t @var{position})
Removes an element at a selected @var{position}: the slot is overwritten
moving the characters following it. The memory is not reallocated to
restrict the block: to do this we have to invoke
@code{ucl_strtok_restrict()} (@ref{Strtok Memory}).
@end deftypefun


@defmac ucl_strtok_popfront (ucl_strtok_t *@var{this})
Removes an element at the beginning of the string. This is a wrapper for
@code{ucl_strtok_erase()} and so it returns the same value.
@end defmac


@defmac ucl_strtok_popback (ucl_strtok_t *@var{this})
Removes an element at the end of the string. This is a wrapper for
@code{ucl_strtok_insert()} and so it returns the same value.
@end defmac


@c ------------------------------------------------------------
@node Strtok Access
@subsection Accessing string data.


@defmac ucl_strtok_data (ucl_strtok_t *@var{this})
Returns a pointer to the first character in the string.
@end defmac


@defmac ucl_strtok_back (ucl_strtok_t *@var{this})
Accesses the last element in the string. It supposes that the container
is not empty, so that the element it's there; we have to make sure of
this, for example, by checking the size of the string first.
@end defmac


@defmac ucl_strtok_front (ucl_strtok_t *@var{this})
Accesses the first element in the string. It supposes that the container
is not empty, so that the element it's there; we have to make sure of
this, for example, by checking the size of the string first.
@end defmac


@defmac ucl_strtok_getval (ucl_strtok_t *@var{this}, size_t @var{position})
Accesses the element at @var{position}. It supposes that @var{position}
is a valid index for the string, we can check this with
@code{ucl_strtok_isindex()}.
@end defmac


@defmac ucl_strtok_setval (ucl_strtok_t *@var{this}, size_t @var{position}, char @var{c})
Stores a new element at @var{position}. It supposes that @var{position}
is a valid index for the string, we can check this with
@code{ucl_strtok_isindex()}. The old element is overwritten.
@end defmac


@defmac ucl_strtok_size (ucl_strtok_t *@var{this})
Returns a @code{size_t} value represenging the buffer size.
@end defmac


@defmac ucl_strtok_len (ucl_strtok_t *@var{this})
Returns a @code{size_t} value representing the number of characters in
the string.
@end defmac


@defmac ucl_strtok_isindex (ucl_strtok_t *@var{this}, size_t @var{position})
Returns true (an integer) if @var{position} is a valid index for the
string referenced by @var{this}. It must be a positive integer greater
or equal to zero and lesser than the number of elements in the
container (@code{size_t} should be an unsigned type).
@end defmac

@c ------------------------------------------------------------
@node Strtok Ops
@subsection Various operations on a string



@deftypefun void ucl_strtok_randomise (ucl_strtok_t *@var{this})
Shuffles the string characters. @code{rand()} is used to generate the
entropy.
@end deftypefun


@deftypefun void ucl_strtok_swap (ucl_strtok_t *@var{this}, size_t @var{a}, size_t @var{b})
Swaps two elements in the string.  This function assumes that the
indexes are not out of range.
@end deftypefun


@defmac ucl_strtok_compare (ucl_strtok_t *@var{one}, ucl_strtok_t *@var{two})
A wrapper for @code{strcmp()} that applies to string structures.
@end defmac

@c ------------------------------------------------------------
@node Strtok Memory
@subsection Allocating and freeing memory


@defmac ucl_strtok_isfull (ucl_strtok_t *@var{this})
Returns true if the string buffer is full.
@end defmac


@deftypefun {char *} ucl_strtok_resize (ucl_strtok_t *@var{this}, size_t @var{size})
Reallocates a string to resize the buffer. If the new size is lesser
than the length of the string, the tail is truncated.  Returns the new
pointer to the string, or @code{NULL} if an error occurred reallocating
memory.
@end deftypefun


@deftypefun {void *} ucl_strtok_enlarge (ucl_strtok_t *@var{this})
If the string is full, enlarge the buffer size to the next multiple of
@code{UCL_STRTOK_STEP_UP} starting from the buffer size. Returns the new
pointer to the string, or @code{NULL} if an error occurred reallocating
memory.
@end deftypefun


@deftypefun {void *} ucl_strtok_restrict (ucl_strtok_t *@var{this})
Restrict the buffer size to the next multiple of
@code{UCL_STRTOK_STEP_UP} starting from the string length. Returns the
new pointer to the string, or @code{NULL} if an error occurred
reallocating memory.
@end deftypefun


@c ------------------------------------------------------------
@node Tree
@section The tree structure


@noindent
The tree container is basically different from the others in the
@acronym{UCL}.  There is no ``base struct'', like @code{ucl_list_t} and
@code{ucl_map_t}, that holds fundamental data and that can be used to
``keep a grab'' on the structure itself.

Instead, the tree is just a collection of nodes linked together, and we
control the struct keeping a pointer to one of the nodes.  Which one
doesn't matter. Nothing prevents us from storing somewhere a pointer to
the ``root node'', but this is not required.

At any time we must take care of holding a pointer to at least one tree
node; if we loose it, we will not be able to free the struct. Keeping
two or more references to nodes is possible but dangerous: if we delete
a subtree we may end up with a pointer to a memory block already freed.

The referenced node is called ``current''. To handle the tree we use a
``walking'' pattern. We can add/remove nodes relative to the ``current'' and
move step by step from the ``current'' to adjacent nodes.

Care must be taken to distinguish between the node's classification from
the ``logic'' point of view and the ``implementation'' point of view. A
tree is implemented as a binary tree.  Here we talk about the logic
point of view; so: the ``dad'' of a node is the uplevel node in the
hierarchy, the ``brother'' of a node is in the same level of the
``current'' node.


@deftp {Struct Typedef} ucl_tree_node_t
The type of the tree nodes.
@end deftp


@menu
* Tree Implementation::         How it's done.
* Tree Creation::               Creating tree nodes.
* Tree Testing::                Testing relationships between nodes.
* Tree Relatives::              Accessing or setting the relatives of
                                a node.
* Tree Adding::                 Adding elements to a tree.
* Tree Removing::               Removing elements from a tree.
* Tree Iterators::              Traversing a tree.
@end menu


@c ------------------------------------------------------------
@node Tree Implementation
@subsection How it's done


@noindent
The implementation is a binary tree in which: the son of the node A is
the first child of the node A, the brother of the child is the second
son of the node A, and so on.

@example
   -----
  | dad |
   -----
    ^ |son
dad | v
   -----  bro   -----  bro   -----  bro   -----  bro
  | 1st |----->| 2nd |----->| 3rd |----->| 4th |----->NULL
   -----        -----        -----        -----
    |            |
    v son        v son
   -----        -----
  | nep |      |     |
   -----        -----
@end example

Pointers condition meaning:

@table @code
@item node.broPtr == NULL
the node has no brothers, so it's the last brother between the children
of its father;

@item node.sonPtr == NULL
the node has no children;

@item node.dadPtr == NULL
the node is the root node of a tree;

@item A.dadPtr == B && B.sonPtr == A
A is the first between the children of node B;

@item A.dadPtr == B && B.broPtr == A 
A and B are brothers, and children of the same parent node.
@end table


@c ------------------------------------------------------------
@node Tree Creation
@subsection Creating tree nodes


@noindent
The tree node structures must be allocated by the user code, none of the
@acronym{UCL} tree methods will invoke memory allocation/release
functions.


@defmac ucl_tree_constructor (ucl_tree_node_t * @var{nodPtr})
A wrapper for the @code{memset()} function. Initialises to zero all the
members of the structure referenced by @var{nodPtr}. This is recommended
before inserting a node into a tree.
@end defmac


@c ------------------------------------------------------------
@node Tree Testing
@subsection Testing relationships between nodes


@deftypefun int ucl_tree_is_dad (ucl_tree_node_t *@var{dadPtr}, ucl_tree_node_t *@var{cldPtr})
Returns true if the node referenced by @var{dadPtr} is the father of the
node referenced by @var{cldPtr}, otherwise returns false.
@end deftypefun


@deftypefun int ucl_tree_is_bro (ucl_tree_node_t *@var{nodPtr}, ucl_tree_node_t *@var{broPtr})
Returns true if the node referenced by @var{nodPtr} is a brother of the
node referenced by @var{broPtr}, otherwise returns false.
@end deftypefun


@deftypefun int	ucl_tree_has_dad (ucl_tree_node_t *@var{this})
Returns true if the node referenced by @var{this} has a parent,
otherwise returns false.
@end deftypefun


@deftypefun int	ucl_tree_has_prev (ucl_tree_node_t *@var{this})
Returns true if the node referenced by @var{this} has a brother to the
left, otherwise returns false.
@end deftypefun


@defmac ucl_tree_has_next (ucl_tree_node_t *@var{this})
Returns true (a non--@code{NULL} pointer) if the node referenced by
@var{this} has a brother to the right, otherwise returns false.
@end defmac


@defmac ucl_tree_has_son (ucl_tree_node_t *@var{this})
Returns true (a non--@code{NULL} pointer) if the node referenced by
@var{this} has a son, otherwise returns false.
@end defmac


@c ------------------------------------------------------------
@node Tree Relatives
@subsection Accessing or setting the relatives of a node


@deftypefun {ucl_tree_node_t *} ucl_tree_get_dad (ucl_tree_node_t *@var{this})
Returns a pointer to the father of the node referenced by @var{this}; if
the node has no parent, it returns @code{NULL}.
@end deftypefun


@deftypefun {ucl_tree_node_t *} ucl_tree_get_prev (ucl_tree_node_t *@var{this})
Returns a pointer to the left brother of the node referenced by
@var{this}; if the node has no left brother, it returns @code{NULL}.
@end deftypefun


@defmac ucl_tree_get_next (ucl_tree_node_t *@var{this})
Returns a pointer to the right brother of the node referenced by
@var{this}; if the node has no right brother, it returns @code{NULL}.
@end defmac


@defmac ucl_tree_get_son (ucl_tree_node_t *@var{this})
Returns a pointer to the son of the node referenced by @var{this}; if
the node has no child, returns @code{NULL}
@end defmac


@deftypefun {ucl_tree_node_t *} ucl_tree_get_first (ucl_tree_node_t *@var{this})
Returns a pointer to the first between the brothers of the node
referenced by @var{this}; it can be a pointer to @var{this} itself, it
@var{this} is the first.
@end deftypefun


@deftypefun {ucl_tree_node_t *} ucl_tree_get_last (ucl_tree_node_t *@var{this})
Returns a pointer to the last between the brothers of the node
referenced by @var{this}; it can be a pointer to @var{this} itself, it
@var{this} is the last.
@end deftypefun

@c ------------------------------------------------------------
@node Tree Adding
@subsection Adding elements to a tree


@noindent
The @code{ucl_tree_set_*()} macros are used to append a new subtree to
a tree.


@defmac ucl_tree_set_son (ucl_tree_node_t * @var{nodPtr}, ucl_tree_node_t * @var{sonPtr})
Links together the nodes referenced by @var{nodPtr} and @var{sonPtr} so
that one is the son of the other. The old reference to the son of
@var{nodPtr} is lost; the old reference to the dad of @var{sonPtr} is
lost.
@end defmac


@defmac ucl_tree_set_bro (ucl_tree_node_t * @var{nodPtr}, ucl_tree_node_t * @var{broPtr})
Links together the nodes referenced by @var{nodPtr} and @var{broPtr} so
that one is the brother of the other. The node referenced by
@var{broPtr} becomes the right brother of the node referenced by
@var{nodPtr}. The old references to the brothers of the two nodes are
lost.
@end defmac


The following functions are used to insert subtrees in a tree. None of
the nodes in the target tree are detached. The links in the new subtrees
that are not interested by the relations in these functions, are left
untouched.


@deftypefun void ucl_tree_insert_dad (ucl_tree_node_t *@var{nodPtr}, ucl_tree_node_t *@var{dadPtr})
Inserts a new dad for a node. The dad node becomes the father of the
node and the first son of the old dad (if any).

@example	
 ---       ---
| A |     | A |
 ---       ---
  |         |
 ---       ---
|nod| ->  |dad|
 ---       ---
            |
           ---
          |nod|
           ---
@end example
@end deftypefun


Example of dad insertion:

@example
ucl_tree_insert_dad( 1, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   A--C
|  |            |         |
5  6            B         1--2--3--4
                          |  |
                          5  6
@end example

@noindent
the @code{D} and @code{B} nodes are detached and will be lost if we
don't keep a reference to them.


@deftypefun void ucl_tree_insert_son (ucl_tree_node_t *@var{nodPtr}, ucl_tree_node_t *@var{sonPtr})
Inserts a new child for a node. The node referenced by @var{sonPtr}
becomes the last between the children of the node referenced by
@var{nodPtr}.

@example
 ---         ---
|nod|       |nod|
 ---         ---
  |     ->    |
 ---         ---     ---
| A |       | A |-->|son|
 ---         ---     ---
@end example
@end deftypefun


Example of son insertion:

@example
ucl_tree_insert_son( 0, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   1--2--3--4--A--C
|  |            |         |  |        |
5  6            B         5  6        B
@end example

@noindent
the node @code{D} is detached and will be lost if we don't keep a
reference to it.


@deftypefun void ucl_tree_insert_prev (ucl_tree_node_t *@var{nodPtr}, ucl_tree_node_t *@var{broPtr})
Inserts a new brother for a node. The node referenced by @var{broPtr}
becomes the left brother of the node referenced by @var{nodPtr}.

@example
 ---    ---          ---    ---    ---
| A |--|nod|   ->   | A |--|bro|--|nod|
 ---    ---          ---    ---    ---
@end example
@end deftypefun


Example of prev node insertion:

@example
ucl_tree_insert_prev( 2, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   1--A--2--3--4
|  |            |         |  |  |
5  6            B         5  B  6
@end example

@noindent
the @code{D} and @code{C} nodes are detached and will be lost if we
don't keep a reference to them.


@deftypefun void ucl_tree_insert_next (ucl_tree_node_t *@var{nodPtr}, ucl_tree_node_t *@var{broPtr})
Inserts a new brother for a node. The node referenced by @var{broPtr}
becomes the right brother of the node referenced by @var{nodPtr}.

@example
 ---    ---          ---    ---    ---
|nod|--| A |   ->   |nod|--|bro|--| A |
 ---    ---          ---    ---    ---
@end example
@end deftypefun


Example of next brother insertion:

@example
ucl_tree_insert_next( 2, A )

0               D         0
|               |         |
1--2--3--4  +   A--C  =   1--2--A--3--4
|  |            |         |  |
5  6            B         5  6
@end example

@noindent
the @code{D}, @code{B} and @code{C} nodes are detached and will be lost
if we don't keep a reference to them.
@c ------------------------------------------------------------
@node Tree Removing
@subsection Removing elements from a tree


@noindent
These functions will extract a node from a tree, returning a pointer to
the extracted node.


@deftypefun {ucl_tree_node_t *} ucl_tree_extract_dad (ucl_tree_node_t *@var{nodPtr})
Extracts the dad of the node referenced by @var{nodPtr} from the tree.
The referenced node and all its brothers are inserted in place of the
extracted dad.

Returns a pointer to the extracted node, or @code{NULL} if the selected
node has nod dad. All the pointers in the extracted node structure are
reset to @code{NULL}.

@example
 ---    ---    ---       ---    ---    ---    ---
| A |--|dad|--| B |     | A |--|nod|--| C |--| B |
 ---    ---    ---       ---    ---    ---    ---
         |          ->
        ---    ---              ---
       |nod|--| C |            |dad|
        ---    ---              ---
@end example
@end deftypefun


@deftypefun {ucl_tree_node_t *} ucl_tree_extract_son (ucl_tree_node_t *@var{nodPtr})
Extracts the son of the node referenced by @var{nodPtr} from the tree.
The son of the selected node is extracted from the hierarchy. All of its
children becomes children of the selected node.

Returns a pointer to the extracted node or @code{NULL} if the selected
node has no son. All the pointers in the extracted node structure are
reset to @code{NULL}.

@example
 ---               ---
|nod|             |nod|
 ---               ---
  |                 |
 ---    ---        ---    ---    ---
|son|--| C |  ->  | A |--| B |--| C |
 ---    ---        ---    ---    ---
  |
 ---    ---            ---
| A |--| B |          |son|
 ---    ---            ---
@end example
@end deftypefun


@deftypefun {ucl_tree_node_t *} ucl_tree_extract_prev (ucl_tree_node_t *@var{nodPtr})
Extracts the left brother of the node referenced by @var{nodPtr}.  The
left brother of the selected node is extracted from the hierarchy. Its
children becomes left brothers of the selected node.

Returns a pointer to the extracted node, or @code{NULL} if the selected
node has no left brother.  All the pointers in the extracted node
structure are reset to @code{NULL}.

@example
 ---               ---
| A |             | A |
 ---               ---
  |                 |
 ---    ---        ---    ---
|prv|--|nod|  ->  | B |--|nod|
 ---    ---        ---    ---
  |
 ---                   ---
| B |                 |prv|
 ---                   ---
@end example
@end deftypefun


@deftypefun {ucl_tree_node_t *} ucl_tree_extract_next (ucl_tree_node_t *@var{nodPtr})
Extracts the right brother of the node referenced by @var{nodPtr}.  The
right brother of the selected node is extracted from the hierarchy. Its
children becomes right brothers of the selected node.

Returns a pointer to the extracted node, or @code{NULL} if the selected
node has no right brother.  All the pointers in the extracted node
structure are reset to @code{NULL}.

@example
 ---    ---    ---       ---    ---    ---
|nod|--|nxt|--| A |     |nod|--| B |--| A |
 ---    ---    ---       ---    ---    ---
         |           ->
        ---                 ---
       | B |               |nxt|
        ---                 ---
@end example
@end deftypefun


@c ------------------------------------------------------------
@node Tree Iterators
@subsection Traversing a tree


@noindent
For the tree iterators, the return value of @code{ucl_iterator_ptr()} is
a pointer to the current node.


@deftypefun void ucl_tree_iterator_inorder (ucl_tree_node_t *@var{nodPtr}, ucl_iterator_t *@var{iter})
Initialises an in--order iteration.
@end deftypefun


@deftypefun void ucl_tree_iterator_preorder (ucl_tree_node_t *@var{nodPtr}, ucl_iterator_t *@var{iter})
Initialises a pre--order iteration.
@end deftypefun


@deftypefun void ucl_tree_iterator_postorder (ucl_tree_node_t *@var{nodPtr}, ucl_iterator_t *@var{iter})
Initialises a post--order iteration.
@end deftypefun


@c ------------------------------------------------------------
@node Vector
@section The vector structure

@cindex Vector container


@noindent
The @UCL{} vector container is an implementation of the classic array
with redundant memory allocation.

@deftp Struct ucl_vector_t
The data type of the base structure. It must be allocated by the user
code, on the stack or in a block of dynamically allocated memory.
@end deftp

This module was inspired by the book on C++ by Bjarne Stroustrup and by
the STL C++ (Standard Template Library).


@menu
* Vector Creation::             Creating and destroying vectors.
* Vector Indexes::              Converting indexes to pointers.
* Vector Adding::               Adding elements to a vector.
* Vector Removing::             Removing elements from a vector.
* Vector Ops::                  Various operations on a vector.
* Vector Iteration::            Iteration over a vector.
* Vector Memory::               Allocating and freeing memory.
* Vector as PQueue::            Using a vector as a priority queue.
@end menu


@c ------------------------------------------------------------
@node Vector Creation
@subsection Creating and destroying vectors


@deftypefun {void *} ucl_vector_constructor1 (@var{this}, @var{size}, @var{step_up}, @var{step_down}, @var{pad}, @var{dim})

Initialise a structure to build a new vector container.

Arguments:

@table @code
@item ucl_vector_t *this
pointer to an already allocated @code{ucl_vector_t} structure;

@item size_t size
the number of slots to allocate for the new vector, it must be a
non--null positive integer;

@item size_t step_up
select the number of slots to add when reallocating the array, it must
be a non--null positive integer;

@item size_t step_down
the number of free slots that will cause the array to be reallocated and
restricted, it must be a non--null positive integer;

@item size_t pad
the numer of free slots to keep at the beginning of the array when
moving elements, it must be a positive or null integer no lesser than
@var{size};

@item size_t dim
the size in bytes of the element that the vector will hold, this should
be the result of the @code{sizeof()} operator applied to the data type.
@end table

Returns a pointer to the first allocated slot, or NULL if an error
allocating memory occurs or if the selected values are incorrect.
@end deftypefun


@defmac ucl_vector_constructor (@var{this}, @var{dim})
A wrapper for @code{ucl_vector_constructor1} that initialises the
structure with the default values (declared in @file{ucl.h}):

@table @code
@item UCL_VECTOR_DEFAULT_SIZE (16)
@item UCL_VECTOR_DEFAULT_STEP_UP (8)
@item UCL_VECTOR_DEFAULT_STEP_DOWN (10)
@item UCL_VECTOR_DEFAULT_PAD (3)
@end table
@end defmac


@deftypefun void ucl_vector_destructor (ucl_vector_t * @var{this})
Destroys the structure pointed by @var{this}. The structure itself is
not deallocated. Any block of dynamically allocated memory is freed.
All the structure fields are reset to zero.
@end deftypefun


@c ------------------------------------------------------------
@node Vector Indexes
@subsection Converting indexes to pointers


@deftypefun {void *} ucl_vector_index (ucl_vector_t *@var{this}, size_t @var{index})
Converts @var{index} into the corresponding pointer in the array.
Returns a pointer to the selected slot, or @code{NULL} if the selected
index is out of range.
@end deftypefun


@deftypefun {void *} ucl_vector_newindex (ucl_vector_t *@var{this}, size_t @var{index})
Converts @var{index} into the corresponding pointer in the array.

This is different from @code{ucl_vector_index()} in that the requested
position can be one unit greater than the last position in the vector:
that way the returned value can be used with @code{ucl_vector_insert()}
to append an element to the end of the vector.

Returns a pointer to the selected slot, or @code{NULL} if the selected
index is out of range.
@end deftypefun


Example:

@example
ucl_vector_t *  vectPtr;
DataType *    ptr;
DataType      val;

ptr = ucl_vector_index(vectPtr, 13);
val = *ptr;
@end example


@c ------------------------------------------------------------
@node Vector Adding
@subsection Adding elements to a vector


@deftypefun {void *} ucl_vector_insert (ucl_vector_t *@var{this}, void *@var{target})
Inserts an empty slot at a selected position.  This function assumes
that the array has a free slot to hold the new element: to make sure
that this is true a call to this function must be preceeded by a call to
@code{ucl_vector_enlarge()}.

The pointer to the slot must be the return value of a previous
invocation to @code{ucl_vector_newindex()}.

This function tries to move as less elements as possible to create an
empty slot at the selected position. The return value is a pointer to
the empty slot: this could be different from the value of the
@var{target} argument.
@end deftypefun


@deftypefun {void *} ucl_vector_insertsort (@var{this}, @var{elmPtr}, @var{compar})
Finds the position in the vector in which an element must be inserted to
keep the array sorted and creates a new slot there. This function
assumes that: there's room in the vector to insert a new element; the
array is sorted.

Arguments:

@table @code
@item ucl_vector_t * @var{this}
pointer to the base structure;

@item void * @var{elmPtr}
pointer to a variable holding a copy of the element to be inserted, it's
used as first argument to the @code{compar} function;

@item int (*@var{compar})(const void *a, const void *b)
pointer to a @code{strcmp()}--like function that's used to compare
elements.
@end table

The return value is a pointer to the empty slot.
@end deftypefun


The correct sequence of function calls required to insert a new element
is: enlarge the vector, acquire the pointer, make a free slot, copy the
value. Example:

@example
ucl_vector_t *    vectPtr;
DataType *      ptr;
size_t          index;

...

ptr = ucl_vector_enlarge(vectPtr);
if (ptr == NULL)
  @{
    handle_the_error();
  @}

ptr  = ucl_vector_newindex(vectPtr, index);
ptr  = ucl_vector_insert(vectPtr, ptr);
*ptr = data_value;
@end example


@c ------------------------------------------------------------
@node Vector Removing
@subsection Removing elements from a vector


@deftypefun void ucl_vector_erase (ucl_vector_t *@var{this}, void *@var{target})
Erases an element at a selected position: the slot is overwritten by
moving as less elements as possible to cover it.

After  the invocation  the pointer  represented by  the @var{target}
argument value, it's  not guaranteed to be a  pointer to a valid
slot in the vector.
@end deftypefun

After  the invocation  of  this  function, it's  possible  to attempt  a
reallocation of  the array  to free  some unused memory  with a  call to
@code{ucl_vector_restrict()}.

Example:

@example
ucl_vector_t *    vectPtr;
DataType *      ptr;
size_t          index;

...

ptr  = ucl_vector_index(vectPtr, index);
data_value = *ptr;
ucl_vector_erase(vectPtr, ptr);

ptr = ucl_vector_restrict(vectPtr);
if (ptr == NULL)
  @{
    handle_the_error();
  @}
@end example


@c ------------------------------------------------------------
@node Vector Ops
@subsection Various operations on a vector


@defmac ucl_vector_size (ucl_vector_t *@var{this})
Returns a @code{size_t} value representing the number of elements in the
container.
@end defmac


@defmac ucl_vector_front (ucl_vector_t *@var{this})
A wrapper for @code{ucl_vector_index()} thath returns a pointer to the
first element in the array.
@end defmac


@defmac ucl_vector_back (ucl_vector_t *@var{this})
A wrapper for @code{ucl_vector_index()} that returns a pointer to the
last element in the array.
@end defmac


@deftypefun void ucl_vector_qsort (this, compar)
Quick sort the vector using the C library function @code{qsort()}.

@table @code
@item ucl_vector_t *this
pointer to the structure;
@item int (*compar)(const void *a, const void *b)
pointer to the function to use to compare elements.
@end table
@end deftypefun


@deftypefun {void *} ucl_vector_find (@var{this}, @var{elmPtr}, @var{compar})
Finds an element in the array with a linear search.

Arguments:

@table @code
@item ucl_vector_t * @var{this}
pointer to the base structure;

@item void * @var{elmPtr}
pointer to a variable holding a copy of the element to be found, it's
used as first argument to the @code{compar} function;

@item int (*@var{compar})(const void *a, const void *b)
pointer to a @code{strcmp()}--like function that's used to compare
elements.
@end table

Returns a pointer to the found element in the array, or @code{NULL} if
the element is not present.
@end deftypefun


@deftypefun {void *} ucl_vector_sortfind (@var{this}, @var{elmPtr}, @var{compar})
Finds an element in the array with a binary search.  This function
assumes that the array is sorted.  If there are few elements in the
vector, a linear search is performed.

Arguments:

@table @code
@item ucl_vector_t * @var{this}
pointer to the base structure;

@item void * @var{elmPtr}
pointer to a variable holding a copy of the element to be found, it's
used as first argument to the @code{compar} function;

@item int (*@var{compar})(const void *a, const void *b)
pointer to a @code{strcmp()}--like function that's used to compare
elements.
@end table

Returns a pointer to the found element in the array, or @code{NULL} if
the element is not present.
@end deftypefun



@c ------------------------------------------------------------
@node Vector Iteration
@subsection Iteration over a vector


@noindent
It's easy to iterate over all the elements of a vector.

Example of forward iteration:

@example
ucl_vector_t     this;
DataType *     ptr

...

for (ptr = ucl_vector_front(vectPtr);
     ptr <= (DataType *) ucl_vector_back(vectPtr);
     ++ptr)
  @{
    /* do something with "*ptr" */
  @}
@end example

Example of backward iteration:

@example
ucl_vector_t     this;
DataType *     ptr

...

for (ptr = ucl_vector_back(vectPtr);
     ptr >= (DataType *) ucl_vector_front(vectPtr);
     --ptr)
  @{
    /* do something with "*ptr" */
  @}
@end example


@c ------------------------------------------------------------
@node Vector Memory
@subsection Allocating and freeing memory


@noindent
The allocation behaviour for a vector container are ruled by the
arguments handed to the constructor (@ref{Vector Creation}). The rules
are:

@itemize @bullet
@item
an initial number of element slots is selected and an array of such size
is allocated;

@item
a number of slots to be kept free at the beginning of the array is
selected, so it can be used to move elements during the insert
operation, saving some time when new elements are added at the
beginning;

@item
a ``step up'' number is selected: when the array is reallocated to be
enlarged, the new size is the minimum multiple of this number greater
than the number of elements in the container;

@item
a ``step down'' number is selected: when the code has to determine if
the array has to be reallocated for restriction, the operation is
performed if there are that number of free slots; 
@end itemize

@noindent
the step up and step down numbers provide the hysteresis required to
minimise the number of reallocations.


@deftypefun {void *} ucl_vector_enlarge (ucl_vector_t *@var{this})
Checks if there are free slots in the allocated memory: if there are,
nothing happens; else the array is reallocated and enlarged according to
the reallocation rules.

Returns a pointer to the first element in the array, or @code{NULL} if
the reallocation failed. An error doesn't invalidate the array.
@end deftypefun


@deftypefun {void *} ucl_vector_restrict (ucl_vector_t *@var{this})
Checks if there are enough free slots in the allocated memory so that
it's correct to restrict the array: if there aren't, nothing happens;
else the array is reallocated and restricted according to the
reallocation rules.

Returns a pointer to the first element in the array, or @code{NULL} if
the reallocation failed. An error doesn't invalidate the array.
@end deftypefun


@c ------------------------------------------------------------
@node Vector as PQueue
@subsection Using a vector as a priority queue


@noindent
The vector structure provides all the functions required to implement a
priority queue.  This is a structure in which elements are associated
with keys: when an element is added and the structure is kept sorted
comparing its key with the keys of the elements already in the
container.

Let's say we have declared a structure like this:

@example
typedef struct Pair @{
  Key   key;
  Val   val;
@} Pair;
@end example

@noindent
and a function used to compare @code{Pair}'s keys:

@example
int keycmp (Key *a, Key *b);
@end example

If any time a @code{Pair} must be inserted in the vector we use the
@code{ucl_vector_insertsort()} function to determine the insertion
position, the elements will be kept sorted according to the key values
and @code{keycmp()} algorithm.

Then @code{ucl_vector_front()} or @code{ucl_vector_back()} can be used
to extract the element with lesser or greater key.



@c end of file
@c Local Variables:
@c mode: texinfo
@c End:

@c ------------------------------------------------------------
@node Iterators
@chapter Container iteration


@noindent
Each container has its iteration constructors that must be invoked
explicitly, but the functions used to do the actual iterations and to
access the objects are accessed through a set of macros.


@deftp Struct ucl_iterator_t
Base structure for all the iterators.
@end deftp


@defmac ucl_iterator_more (ucl_iterator_t *@var{iterator})
Returns true if there are more elements to iterate, false if the
iteration is over.
@end defmac


@defmac ucl_iterator_next (ucl_iterator_t *@var{iterator})
Advances the iteration.
@end defmac


@defmac ucl_iterator_ptr (ucl_iterator_t *@var{iterator})
Returns a @code{void *} pointer referencing the current value. If the
iteration is already over returns @code{NULL}.
@end defmac


Example of iterator usage:

@example
ucl_value_t       val;
ucl_iterator_t    iterator;
ucl_map_link_t *  linkPtr;

...

for (ucl_map_iterator_inorder(this, &iterator);
     ucl_iterator_more(&iterator);
     ucl_iterator_next(&iterator))
  @{
    linkPtr = ucl_iterator_ptr(&iterator);
    val = ucl_map_getval(linkPtr);
  @}
@end example

@c ---------------------------------------------------------------------
@node References
@appendix Bibliography and references

Ellis Horowitz, Sartaj  Sahni and Susan Anderson--Freed. @emph{Strutture
dati in C}. McGraw--Hill, 1993.

Bjarne Stroustroup. @emph{C++}. Addison-Wesley, 1997. Terza edizione.

@c ------------------------------------------------------------

@include lgpl.texiinc
@include fdl.texiinc

@c ---------------------------------------------------------------------
@node Concept Index
@appendix An entry for each concept
     
@printindex cp



@c ---------------------------------------------------------------------
@node Function Index
@appendix An entry for each function
     
@printindex fn
     
@contents
@bye


@c end of file
