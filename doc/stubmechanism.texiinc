@c stubmechanism.texiinc --
@node stub mechanism
@appendix The stub mechanism


@noindent
The author has learned to use and implement the stub mechanism from the
source code of the @emph{Tool Command Language} (@tcl{}) by John
Ousterhout; the language is currently maintained by the @tcl{} Core Team
with help from the @tcl{} community (@url{http://www.tcl.tk/}).

No code in this library comes from the @tcl{} sources, but the logic and
the use of preprocessor macros to invoke functions is the same.


@menu
* stub what::                   What the mechanism allows.
* stub how::                    How it works.
@end menu

@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node stub what
@appendixsec What the mechanism allows


@noindent
With the stubs mechanism:

@enumerate
@item
programs coded for interface version @code{1.0} of the library can use,
without recompilation, all the libraries with major interface number
@code{1} (@code{1.0}, @code{1.1}, @code{1.2}, @dots{});
@item
programs coded for interface version @code{1.4} can use, without
recompilation, all the libraries with major interface number @code{1}
and minor interface number greater or equal to @code{4} (@code{1.4},
@code{1.5}, @code{1.6}, @dots{}).
@end enumerate

This is not for free:

@enumerate
@item
the library's developer has to keep all the functions of previous
versions, without changing the interface;
@item
to use the mechanism the library's users have to statically link the
code with a small stub library provided with this package.
@end enumerate

@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node stub how
@appendixsec How it works


@noindent
The stub mechanism is based upon the @code{dl} library and makes use of
the functions: @function{dlopen}, @function{dlclose}, @function{dlsym},
@function{dlerror}. The code of the static stub library needs the @gnu{}
C Library version 2.2 (see the @code{dlopen(3)} manual page to
understand why).

@menu
* stub shared scenario::        Scenario: using a shared library.
* stub dl scenario::            Scenario: loading a shared library.
* stub scenario::               Scenario: the stub mechanism.
* stub automation::             The stub library automation.
@end menu

@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node stub shared scenario
@appendixsubsec Shared library


@noindent
The scenario of usage of a function in a shared library is:

@enumerate
@item
the library declares the function prototype in a header file:

@example
extern void library_function (void);
@end example

@noindent
and its implementation in the code:

@example
void
library_function (void)
@{
  ...
@}
@end example

@item
in the application's code we include the header and invoke the function
in the code:

@example
#include <library.h>

...
@{
   library_function();
@}
@end example

@item
we dynamically link the application's code with the shared library:

@example
gcc ourcode.o -llib
@end example
@end enumerate

@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node stub dl scenario
@appendixsubsec Dl loaded library


@noindent
The scenario of usage of a function in a shared library loaded with the
@code{dl} mechanism is:

@enumerate
@item
the library declares the function prototype in a header file:

@example
extern void library_function (void);
@end example

@noindent
and its implementation in the code:

@example
void
library_function (void)
@{
  ...
@}
@end example

@item
in the application we include the header, declare a global variable to
hold the function pointer and invoke the function through the pointer:

@example
#include <library.h>

void (*my_library_function) (void);

...
@{
   my_library_function();
@}
@end example

@noindent
before invoking the function we load the library and request a pointer
to the function:

@example
#include <dlfcn.h>

@{
  handle = dlopen("lib.so", RTLD_GLOBAL|RTLD_NOW);
  my_library_function = dlsym(handle, "library_function");
@}
@end example

@item
we dynamically link the application's code with the @code{dl} library:

@example
gcc ourcode.o -ldl
@end example
@end enumerate

@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node stub scenario
@appendixsubsec Stubs mechanism


@noindent
With the pure @code{dl} mechanism we have to invoke @function{dlsym} for
each library function that we need. A faster way is to have a table of
pointers to functions in the library and retrieve with @function{dlsym}
a pointer to it.

@enumerate
@item
the library defines a table of pointers to exported functions in its
header file;

@example
typedef struct table_t @{
  void (*library_function_p) (void);
@} table_t;

extern const table_t library_stub_table;
@end example

@noindent
in the library's code the table and the function are declared:

@example
void
library_function (void)
@{
  ...
@}

const table_t library_stub_table = @{
  library_function;
@};
@end example

@item
in the application's code we include the header, declare a global
variable to hold a pointer to the table and invoke the function through
it:

@example
#include <library.h>

table_t * my_stub_table_p;
#define library_function   (my_stub_table_p->library_function)

@{
  library_function();
@}
@end example

@item
before invoking the function we load the library and initialise the
pointer to the table:

@example
#include <dlfcn.h>

@{
  handle = dlopen("lib.so", RTLD_GLOBAL|RTLD_NOW);
  my_stub_table_p = dlsym(handle, "library_stub_table");
@}
@end example

@item
we dynamically link our code with the @code{dl} library:

@example
gcc ourcode.o -ldl
@end example
@end enumerate

@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node stub automation
@appendixsubsec The stub library automation


@noindent
We want to be able to choose: use the stub mechanism or not; it is also
useful to have the loading of the library automated. The library in this
package makes use of a script to automatically build what is needed to
use the stub mechanism; we @strong{do not} need to know the details to
use the library.

Let's take as example a library whose identifier is @code{ucl} and whose
interface version number is @code{2.0}; the library identifier is used
to define a namespace for symbols.

The package builds and installs 3 libraries:

@table @emph
@item the shared library
this is a ``normal'' C shared library to which we can link our programs;
its name is @file{libucl2.0.so};

@item the shared stub library
a C shared library that holds the table (or tables) of pointers to
functions; its name is @file{libuclstub2.0.so};

@item the static stub library
a C static library that we must link in our application: the code in it
takes care to load the shared stub library and to initialise the pointer
(or pointers) to the stub tables; its name is
@file{libuclstaticstub2.0.a};
@end table

@noindent
the static stub library loads the shared stub library via a symbolic
link that must be created at installation time; the symbolic link's name
has no minor version number in it: @file{libuclstub2.so}.

@example
 ----------------------------
|         application        |
|                            |           --------------
|   -------------------------| dlopen() | UCL shared   |
|  | UCL static stub library +--------->| stub library |
|   -------------------------|           --------------
 ----------------------------                 |
                                  dynamically |
                                  linked      |
                                              v
                                         ------------
                                        | UCL shared |
                                        | library    |
                                         ------------
@end example


There is a unique interface header file that we have to include to use
the library, let's say that it is @file{ucl.h}. To directly use the
shared library: if we just include it. To use the stub mechanism we
define the symbol @code{UCL_ENABLE_STUB} and the include it:

@example
#define UCL_ENABLE_STUB 1
#include <ucl.h>
@end example

@noindent
of course it is possible to arrange the building infrastrucure of the
application to select the shared library or the stub mechanism at
compilation time.

The header file (conceptually) looks like this:

@example
/* ucl.h */

#ifdef UCL_ENABLE_STUB

typedef void ucl_function_proto_t (void);

typedef struct ucl_stub_table_t @{
  ucl_function_proto_t *        stub_ucl_function;
@} ucl_stub_table_t;

extern const char * ucl_init_stub_table (void);
extern int ucl_final_stub_table (void);

extern const ucl_stub_table_t   ucl_stub_table;
extern const ucl_stub_table_t * ucl_stub_table_p;

#define ucl_function   (ucl_stub_table_p->stub_ucl_function)

#else /* not defined UCL_ENABLE_STUB */

extern void library_function_p (void);

#endif /* defined UCL_ENABLE_STUB */

/* end of file */
@end example

@noindent
we link our application with the static stub library and invoke
@function{ucl_init_stub_table}: the shared stub library is loaded, if
the return value is @null{} we can go on, else the return value is a
pointer to the error string returned by @function{dlerror}.

We can also unload the stub shared library by invoking
@function{ucl_final_stub_table}: if the return value is zero we can go
on, else the return value is the return value of @function{dlclose}.


@appendixsubsubsec What to do


@noindent
If we @strong{do not} want the stub mechanism we do:

@example
gcc application.c -c -o application.o
gcc -o application application.o -lucl2.0
@end example

@noindent
and go home as usual.

If we want the stub mechanism on we compile our code with:

@example
gcc application.c -DUCL_ENABLE_STUB=1 -c -o application.o
gcc -ldl -o application application.o libuclstaticstub2.0.a
@end example

@noindent
and invoke @function{ucl_init_stub_table}, for example from
@function{main}.

@c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


@c end of file
@c Local Variables:
@c mode: texinfo
@c End:
